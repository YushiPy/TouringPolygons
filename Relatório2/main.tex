
\documentclass[11pt]{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

% make conditions/keyword arguments use text mode
\renewcommand{\algorithmcfname}{Algoritmo}

\SetKwInOut{Input}{Entrada}
\SetKwInOut{Output}{Saída}
\SetKwIF{If}{ElseIf}{Else}{se}{:}{senão se}{senão}{end}
\SetKwFor{For}{para cada}{:}{end}
\SetKwRepeat{Do}{do}{enquanto}

\SetKwProg{Function}{define}{:}{}
\SetKw{Return}{retorna}
\SetProgSty{upshape} % tell it not to italicize
\renewcommand{\ProgSty}[1]{\textnormal{#1}\unskip} % enforce upright text


\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{#1}%
}

\newcommand{\algref}[1]{\ref{#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
% \usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}
\usepackage{csquotes}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{cleveref}
\usepackage{desclist}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blank}{}{} % Blank enviroment for folding sections in editors

\newenvironment{blockQuote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}
\DeclarePairedDelimiter{\anglebrackets}{\langle}{\rangle}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

% Footnote spacing
\setlength{\skip\footins}{0.5cm}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}


\title{\textbf{O Problema de Visita de Polígonos}\thanks{Esse trabalho foi parcialmente apoiado pela agência FAPESP (processo 2025/13861-1).}}

\author{
	Gabriel F. Ushijima\thanks{Instituto de Matemática e Estatística, Universidade de São Paulo, Rua do Matão, 1010, Cidade Universitária,
05508-090, São Paulo, SP, Brazil (e-mail: gabriel\_ushijima@ime.usp.br, egbirgin@ime.usp.br).\vspace{0.5cm}}
	\and
	\(\text{Ernesto G. Birgin}^\dagger\)
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}

Este trabalho apresenta diferentes implementações de algoritmos para o Problema de Visita de Polígonos (Touring Polygons Problem - TPP), que consiste em encontrar um caminho de comprimento mínimo que visite uma sequência de polígonos no plano. Em sua forma geral, o problema é NP-difícil. Por esse motivo, inicialmente consideramos uma versão simplificada em que os polígonos são convexos e não se sobrepõem, para a qual apresentamos um algoritmo exato baseado em mapas de último passo. Em seguida, discutimos heurísticas para o caso geral, utilizando técnicas de programação inteira mista. Por fim, realizamos experimentos computacionais para avaliar o desempenho dos algoritmos propostos em instâncias de diferentes tamanhos e características, comparando-os com solvers comerciais. Os resultados indicam que as abordagens desenvolvidas são eficazes em uma ampla variedade de cenários práticos.

\vspace{10pt}

\noindent \textbf{Palavras-chave:} problema de visita de polígonos, otimização geométrica, complexidade, experimentos numéricos.
\end{abstract}

\section{Introdução}

O Problema de Visita de Polígonos (Touring Polygons Problem - TPP), introduzido por Dror et al. (2003) \cite{tpp-dror2003}, é um problema de otimização geométrica que consiste em determinar um caminho de comprimento mínimo que visite uma sequência de polígonos no plano. Esse tipo de problema surge naturalmente em aplicações de roteirização e planejamento de trajetórias, especialmente no contexto de veículos autônomos, nos quais é necessário garantir a visita eficiente a regiões específicas do espaço, como em tarefas de inspeção automatizada de armazéns \cite{jianxian2023, karl2009}. Podemos interpretar esse problema como um caso específico do Problema do Caixeiro Viajante com Regiões (Traveling Salesman Problem with Neighborhoods - TSPN) \cite{tspn-arkin2005}, no qual o objetivo é encontrar um caminho de comprimento mínimo que visite um conjunto de regiões arbitrárias no plano, sendo que, no TPP, essas regiões são representadas por polígonos e a ordem de visita é pré-definida.

Dentre as diversas variações do problema, consideramos inicialmente uma versão simplificada em que os polígonos são convexos e não se sobrepõem. Para esse caso, apresentamos três abordagens distintas. A primeira é uma implementação direta das ideias descritas por Dror et al. (2003) \cite{tpp-dror2003}, baseada em mapas de último passo. A segunda abordagem melhora a eficiência da primeira ao empregar uma estratégia de busca binária para a localização de pontos nesses mapas. A terceira abordagem utiliza uma técnica de memoização, com o objetivo de evitar cálculos redundantes e reduzir o custo computacional. Por fim, mostramos que a primeira abordagem possui complexidade \(O(n^2)\), enquanto as outras duas apresentam complexidade \(O(n k \log (n / k))\), onde \(n\) é o número total de vértices de todos os polígonos e \(k\) é o número de polígonos.

Em seguida, discutimos heurísticas para o caso geral do TPP, no qual os polígonos podem ser côncavos. Baseamo-nos principalmente na ideia de particionar polígonos côncavos em subconjuntos convexos e aplicar, sobre eles, as soluções desenvolvidas para o caso convexo. Além disso, exploramos técnicas de programação inteira mista para modelar o problema e empregar solvers comerciais na obtenção de soluções aproximadas, como o \href{https://www.gurobi.com}{Gurobi}. Por fim, comparamos os resultados obtidos por essas abordagens com aqueles produzidos pelas implementações propostas neste trabalho.
\section{O Problema de Visita de Polígonos Convexos}

Inicialmente, consideramos o TPP em sua versão mais simples, na qual os polígonos são convexos e não se sobrepõem, denominada TPP Irrestrito. Utilizamos tanto a formulação quanto a solução apresentadas por Dror et al. (2003) \cite{tpp-dror2003} como base para nossas implementações. Para nossos propósitos, definimos o problema da seguinte forma:

\begin{blockQuote}

	{\large \textbf{Problema 1: TPP Irrestrito}}

	\noindent Dado um ponto inicial \(s \in \mathbb{R}^2\), um ponto final \(t \in \mathbb{R}^2\) e uma sequência de polígonos convexos e disjuntos \(P_1, \dots, P_k\), dados por sequências de vértices ordenados em sentido anti-horário, encontre um caminho \(\pi\) de comprimento mínimo que se inicia em \(s\), termina em \(t\), e para o qual existem pontos \(p_1, \dots, p_k\) tais que \(p_i \in P_i\) para todo \(i = 1, 2, \dots, k\), e o caminho \(\pi\) passa por esses pontos nessa mesma ordem.

\end{blockQuote}

Todas as implementações a seguir têm como base as definições e propriedades apresentadas por Dror et al. (2003) \cite{tpp-dror2003}. Assumimos que o leitor possui familiaridade com o conteúdo desse artigo. A seguir, retomamos as principais definições que serão utilizadas.

\begin{itemize}

	\item \textbf{Caminho Ótimo} (\(i\)-path): Um \(i\)-path até um ponto \(p\) é um caminho de comprimento mínimo que se inicia em \(s\), termina em \(p\) e visita os polígonos \(P_1, P_2, \dots, P_i\) em ordem. É fácil notar que qualquer \(i\)-path deve ser a união de segmentos de reta; assim, tratamos caminhos como sequências ordenadas de pontos em \(\mathbb{R}^2\).
	
	\item \textbf{Região de Primeiro Contato} (\(T_i\)): Denotamos por \(T_i\) a região de primeiro contato de um polígono \(P_i\), definida como o conjunto de pontos \(p\) em seu perímetro tais que o último segmento do \((i - 1)\)-path até \(p\) intersecta \(P_i\) exclusivamente nesse ponto. Intuitivamente, \(T_i\) representa os pontos no perímetro de \(P_i\) onde o último segmento do \((i - 1)\)-path não atravessa o interior de \(P_i\).
	
	\item \textbf{Mapa de Último Passo} (\(S_i\)): Denotamos por \(S_i\) o mapa de último passo de um polígono \(P_i\), que consiste em uma partição do plano em um número finito de regiões tais que dois pontos em \(\mathbb{R}^2\) pertencem à mesma região se, e somente se, o último segmento do \(i\)-path até esses pontos possui a mesma origem: um vértice de \(P_i\), uma aresta de \(P_i\), ou atravessa o interior de \(P_i\).

\end{itemize}

Como demonstrado em \cite[\textbf{Lemma 3}]{tpp-dror2003}, se dispomos de \(S_1, \dots, S_i\), então é possível determinar o \(i\)-path até qualquer ponto \(p\) de maneira eficiente. Para tal, consideramos os três casos possíveis para o último segmento do \(i\)-path até \(p\), que dependem da região de \(S_i\) à qual \(p\) pertence:

\begin{itemize}

	\item \textbf{Região de Vértice}: Se \(p\) pertence a uma região associada a um vértice \(v\) de \(P_i\), então o último segmento do \(i\)-path até \(p\) é o segmento \(\overline{vp}\). Assim, o \(i\)-path até \(p\) é simplesmente o \((i - 1)\)-path até \(v\), seguido do segmento \(\overline{vp}\).
	
	\item \textbf{Região de Aresta}: Se \(p\) pertence a uma região associada a uma aresta \(e = \overline{v^1 v^2}\) de \(P_i\), então refletimos o ponto \(p\) em relação à reta que contém \(e\), obtendo um ponto refletido \(p'\). Calculamos o  \((i - 1)\)-path até \(p'\) cujo último segmento parte de um ponto \(q'\), então chamamos de \(q\) a interseção do segmento \(\overline{q'p'}\) com a aresta \(e\). O \(i\)-path até \(p\) é então o \((i - 1)\)-path até \(p'\) até o ponto \(p\), seguido do segmento \(\overline{qp}\). 
	
	A seguir, apresentamos a fórmula para calcular o ponto refletido \(p'\) e o ponto de interseção \(q\), onde usamos o operador \(\cdot\) para denotar o produto escalar, o operador \(\|\cdot\|\) para denotar a norma euclidiana e o operador \(\times\) para denotar o produto vetorial\footnote{Para dois vetores \(a = (a_x, a_y)\) e \(b = (b_x, b_y)\), temos \(a \times b = a_x b_y - a_y b_x\).}, todos em \(\mathbb{R}^2\):
	
	\begin{align}
		&p' = p + 2 \frac{(v^1 - p) \cdot (v^2 - v^1)}{\|v^2 - v^1\|^2} (v^2 - v^1) \label{eq:reflection_on_edge} \\
		&q = q' + \frac{(v^1 - q') \times (v^2 - v^1)}{(p' - q') \times (v^2 - v^1)} (p' - q') \label{eq:intersection_on_edge}
	\end{align}
	
	\item \textbf{Região de Atravessar}: Se \(p\) pertence à região de atravessar \(P_i\), então o último segmento do \(i\)-path até \(p\) atravessa o interior de \(P_i\). Nesse caso, o \(i\)-path até \(p\) é simplesmente o \((i - 1)\)-path até \(p\).

\end{itemize}

A Figura~\ref{fig:casos_em_consulta} ilustra esses três casos. O caso (a) mostra o ponto em uma região de vértice, (b) ilustra o ponto em uma região de aresta, bem como o processo de reflexão e construção do caminho, e (c) apresenta o ponto na região de travessia do polígono. 

\begin{figure}[!ht]
    \centering
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{solução_vértice.png}
        \caption{\(t\) em região de vértice}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{solução_aresta.png}
        \caption{\(t\) em região de aresta}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{solução_atravessar.png}
        \caption{\(t\) em região de travessia}
    \end{subfigure}

    \caption{Três casos possíveis no caminho mínimo do ponto \(s\) (em verde) até \(t\) (em vermelho) ao visitar um polígono. 
	Em vermelho, regiões de vértice; em verde, regiões de aresta; em azul, região de atravessar.}
	\label{fig:casos_em_consulta}
\end{figure}

Com base nessas ideias, implementamos o Algoritmo~\algref{alg:consulta-caminho}, que, dado um ponto \(p\) e um índice \(i\), retorna o \(i\)-path até \(p\) como uma sequência de pontos em \(\mathbb{R}^2\), desconsiderando o último ponto do caminho, \(p\), que é conhecido. Assumimos também a existência de uma função \texttt{LocalizaPonto}, que localiza o ponto \(p\) no mapa de último passo \(S_i\) de \(P_i\) e retorna a região \(R\) à qual \(p\) pertence. Essa região carrega informações suficientes para determinar seu tipo (vértice, aresta ou atravessar) e os dados necessários para reconstruir o caminho conforme descrito anteriormente.

\begin{algorithm}[!ht]
\alglabel{alg:consulta-caminho}
\caption{Consulta Caminho}
\Input{\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\)}
\Output{\(i\)-path até \(p\) como uma sequência de pontos em \(\mathbb{R}^2\), desconsiderando \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}
 
\Function {ConsultaCaminho(\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\))} {

	\If {\(i = 0\)} {
		\Return {} \([s]\)
	}
	
	\(R \leftarrow \text{LocalizaPonto}(p, P_i, T_i, S_i)\) \\
	
	\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
		\(\mathbb{P} \leftarrow \text{ConsultaCaminho}(v, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\Return {} \(\mathbb{P} \oplus [v]\) \tcp{Adiciona \(v\) ao final do caminho \(\mathbb{P}\)}
	}
	
	\ElseIf {\(R\) corresponde a uma aresta \(e = \overline{v^1 v^2}\) de \(P_i\)} {
		\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) \\
		\(\mathbb{P} \leftarrow \text{ConsultaCaminho}(p', i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(q' \leftarrow\) último ponto de \(\mathbb{P}\) \\
		\(q \leftarrow\) ponto de interseção entre as retas que passam por \(\overline{q' p'}\) e \(e\) \\
		\Return {} \(\mathbb{P} \oplus [q]\) \tcp{Adiciona \(q\) ao final do caminho \(\mathbb{P}\)}
	}
	
	\ElseIf {\(R\) corresponde a atravessar \(P_i\)} {
		\Return {} \(\text{ConsultaCaminho}(p, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
	}
}

\end{algorithm}

O Algoritmo~\algref{alg:consulta-caminho} permite calcular o \(i\)-path até qualquer ponto \(p\) de forma eficiente, podendo ser utilizado para obter o \(k\)-path até \(t\), que corresponde exatamente à solução do problema. No entanto, frequentemente nos interessamos apenas no último segmento do \(i\)-path até \(p\). Além disso, no caso em que um ponto pertence a uma região associada a um vértice de \(P_i\), é possível determinar o último segmento diretamente, sem a necessidade de calcular o restante do caminho. Dessa forma, implementamos o Algoritmo~\algref{alg:consulta-ultimo-passo}, que, dado um ponto \(p\) e um índice \(i\), retorna o ponto inicial do último segmento do \(i\)-path até \(p\).

\begin{algorithm}[!ht]
\alglabel{alg:consulta-ultimo-passo}
\caption{Consulta Último Passo}
\Input{\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\)}
\Output{Ponto que precede \(p\) no \(i\)-path até \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {ConsultaÚltimoPasso(\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\))} {

	\If {\(i = 0\)} {
		\Return {} \(s\)
	}

	\(R \leftarrow \text{LocalizaPonto}(p, P_i, T_i, S_i)\) \\

	\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
		\Return {} \(v\)
	}
	\ElseIf {\(R\) corresponde a uma aresta \(e\) de \(P_i\)} {
		\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) \\
		\(q' \leftarrow \text{ConsultaÚltimoPasso}(p', i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(q \leftarrow\) ponto de interseção entre \(\overline{q' p'}\) e \(e\) \\
		\Return {} \(q\)
	}
	\ElseIf {\(R\) corresponde a atravessar \(P_i\)} {
		\Return {} \(\text{ConsultaÚltimoPasso}(p, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
	}
}

\end{algorithm}

Esses dois algoritmos serão utilizados em todas as implementações discutidas a seguir. A diferença entre elas estará na implementação do algoritmo \texttt{LocalizaPonto} e na forma como calculamos as regiões de primeiro contato \(T_i\) e os mapas de último passo \(S_i\) para cada polígono \(P_i\).
\subsection{Primeira Abordagem}

Primeiramente, calculamos a região de primeiro contato \(T_i\) de um polígono \(P_i\). Sabemos que essa região é a união de arestas de \(P_i\), sendo delimitada por vértices de \(P_i\) \cite[\textbf{Lemma 2.}]{tpp-dror2003}. Assim, precisamos apenas determinar quais arestas de \(P_i\) pertencem a \(T_i\). Seja \(e = \overline{v^1 v^2}\) uma aresta de \(P_i\), \(p\) um ponto qualquer dessa aresta e \(q\) o ponto que precede \(p\) no \((i - 1)\)-path até \(p\). Note que \(e \in T_i\) se, e somente se, a direção \((q - p)\) está do lado externo de \(P_i\). Como isso vale para qualquer ponto \(p\) em~\(e\), o critério pode ser testado nos vértices da aresta.

A Figura~\ref{fig:first_contact_region} ilustra como podemos usar essa ideia para determinar a região de primeiro contato de um polígono, realizando o teste para ambos os vértices de cada aresta do polígono. Implementamos essa ideia no Algoritmo~\algref{alg:first_contact_region}, utilizando o vértice \(v^1\) como o ponto \(p\) para determinar se a aresta~\(e\) pertence a \(T_i\).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.6\textwidth]{utpp-first_contact.png}
	\caption{Usamos o Algoritmo~\ref{alg:first_contact_region} para determinar a região de primeiro contato do polígono. Pintamos em verde as arestas que pertencem a \(T_i\) e em vermelho as que não pertencem.}
	\label{fig:first_contact_region}
\end{figure}

\begin{algorithm}[!ht]
\alglabel{alg:first_contact_region}
\caption{Região de Primeiro Contato}
\Input{\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1})\)}
\Output{Região de primeiro contato \(T_i\) de \(P_i\) como um conjunto de arestas de \(P_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {RegiãoDePrimeiroContato(\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1})\))} {

	\(T_i \leftarrow \emptyset\)
	
	\For {cada aresta \(e\) de \(P_i\)} {
	
		\(v^1 \leftarrow\) vértice anterior de \(e\) \\
		\(v^2 \leftarrow\) vértice posterior de \(e\) \\
	
		\(q \leftarrow \text{ConsultaÚltimoPasso}(v^1, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	
		\If {\((q - v^1) \times (v^2 - v^1) < 0\)} {
			\(T_i \leftarrow T_i \cup e\)
		}
	}
	
	\Return {} \(T_i\)
}

\end{algorithm}

Uma vez que temos \(T_0, \dots, T_i\), podemos calcular o mapa de último passo~\(S_i\) de~\(P_i\). Para isso, observamos que~\(S_i\) possui exatamente três tipos de regiões: regiões associadas a vértices de~\(P_i\) pertencentes a~\(T_i\), regiões associadas a arestas de~\(P_i\) pertencentes a~\(T_i\) e uma única região de atravessar \(P_i\), que corresponde às arestas que não estão em~\(T_i\). Além disso, uma região associada a uma aresta~\(e\) é delimitada pelas regiões associadas aos vértices extremos de~\(e\) e pela própria aresta~\(e\). A região de atravessar~\(P_i\) é definida como o complemento das regiões associadas a vértices e arestas de~\(P_i\). Dessa forma, para construir~\(S_i\), precisamos apenas determinar as regiões associadas aos vértices de~\(P_i\) pertencentes a~\(T_i\).

Pelas condições de otimalidade discutidas em \cite[\textbf{Local Optimality Conditions.}]{tpp-dror2003}, sabemos que, para cada vértice \(v\) de \(P_i\) que pertence a \(T_i\), a região associada a \(v\) em \(S_i\) é um cone definido pelo ponto \(v\) e por um par ordenado de raios que partem de \(v\). Esses raios podem ser calculados a partir do último segmento do \((i - 1)\)-path até \(v\) e de sua reflexão em relação às arestas de \(P_i\) incidentes em \(v\). Mais especificamente, se \(e^1\) e \(e^2\) são as arestas de \(P_i\), em sentido anti-horário, que contêm \(v\), e \(q\) é o ponto que precede \(v\) no \((i - 1)\)-path até \(v\), então o primeiro raio é a reflexão do vetor \(\overrightarrow{qv}\) em relação à reta que contém \(e^1\), caso \(e^1\) pertença a \(T_i\), ou simplesmente o vetor \(\overrightarrow{qv}\), caso contrário. De forma análoga, o segundo raio é a reflexão do vetor \(\overrightarrow{qv}\) em relação à reta que contém \(e^2\), caso \(e^2\) pertença a \(T_i\), ou simplesmente o vetor \(\overrightarrow{qv}\), caso contrário. Repetimos esse processo para todos os vértices de \(P_i\), obtendo assim todas as regiões associadas a vértices de \(P_i\) em \(S_i\). Essa ideia é implementada no Algoritmo~\algref{alg:last_step_map}.

\begin{algorithm}[!ht]
\alglabel{alg:last_step_map}
\caption{Mapa de Último Passo}

\Input{\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1})\)}
\Output{Mapa de último passo \(S_i\) de \(P_i\) como uma associação de pares ordenados de raios aos vértices das arestas de \(T_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {MapaDeÚltimoPasso(\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1})\))} {

	\(S_i \leftarrow \emptyset\)

	\For{vértice \(v\) de \(P_i\) tal que existe uma aresta \(e\) em \(T_i\) incidente a \(v\)} {
		
		\(e^1 \leftarrow\) aresta anterior de \(v\) em \(P_i\) \\
		\(e^2 \leftarrow\) aresta posterior de \(v\) em \(P_i\) \\

		\(q \leftarrow \text{ConsultaÚltimoPasso}(v, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(d \leftarrow v - q\)

		\If {\(e^1\) pertence a \(T_i\)} {
			\(r^1 \leftarrow\) reflexão de \(d\) em relação à reta que contém \(e^1\)
		}
		\Else {
			\(r^1 \leftarrow d\)
		}

		\If {\(e^2\) pertence a \(T_i\)} {
			\(r^2 \leftarrow\) reflexão de \(d\) em relação à reta que contém \(e^2\)
		}
		\Else {
			\(r^2 \leftarrow d\)
		}

		Associa \((r^1, r^2)\) a \(v\) e adiciona à \(S_i\)
	}

	\Return {} \(S_i\)
}

\end{algorithm}

Uma vez que sabemos calcular \(T_i\) e \(S_i\), desejamos implementar o algoritmo \texttt{LocalizaPonto}, que localiza um ponto \(p\) no mapa de último passo \(S_i\). Na primeira abordagem, implementamos esse procedimento de forma direta, verificando inicialmente todas as regiões associadas a vértices, depois todas as regiões associadas a arestas e, caso o ponto não pertença a nenhuma dessas regiões, retornando a região de atravessar \(P_i\). Para verificar se um ponto \(p\) pertence a uma região associada a um vértice \(v\) de \(P_i\) com raios \(r^1\) e \(r^2\), primeiro determinamos se o ângulo de abertura entre \(r^1\) e \(r^2\) é menor ou maior que \(180^\circ\). Se o ângulo for menor que \(180^\circ\), então \(p\) pertence à região associada a \(v\) se o produto vetorial entre \(r^1\) e \(\overrightarrow{vp}\) for positivo \textbf{e} o produto vetorial entre \(\overrightarrow{vp}\) e \(r^2\) for negativo. Caso contrário, \(p\) pertence à região associada a \(v\) se o produto vetorial entre \(r^1\) e \(\overrightarrow{vp}\) for positivo \textbf{ou} o produto vetorial entre \(\overrightarrow{vp}\) e \(r^2\) for negativo. Essas situações são ilustradas na Figura~\ref{fig:point_in_cone}.

\begin{figure}[!ht]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{cone_check_small.png}
		\caption{Ângulo de abertura menor que \(180^\circ\).}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{cone_check_large.png}
		\caption{Ângulo de abertura maior que \(180^\circ\).}
	\end{subfigure}
	\caption{Verificação de pertinência de um ponto a uma região associada a um vértice em um mapa de último passo.}
	\label{fig:point_in_cone}
\end{figure}

Além disso, desejamos verificar se um ponto \(p\) pertence a uma região associada a uma aresta \(e\) de \(P_i\). Para isso, consideramos que \(v^1\) e \(v^2\) são os vértices que definem a aresta \(e\), em sentido anti-horário, e tomamos \(r^1\) como o segundo raio associado ao vértice \(v^1\) e \(r^2\) como o primeiro raio associado ao vértice \(v^2\) em \(S_i\). Então, \(p\) pertence à região associada a \(e\) se estiver do lado externo da aresta \(e\) e entre os raios \(r^1\) e \(r^2\), como ilustrado na Figura~\ref{fig:point_in_edge_region}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{edge_region_check.png}
	\caption{Verificando se um ponto pertence a uma região associada a uma aresta.}
	\label{fig:point_in_edge_region}
\end{figure}

Uma vez que conseguimos verificar se um ponto pertence a uma região associada a um vértice ou a uma aresta de \(P_i\), podemos implementar o algoritmo \texttt{LocalizaPonto} de forma direta, como mostrado no Algoritmo~\algref{alg:locate_point_first_approach}. Realizamos dois laços: o primeiro verifica todas as regiões associadas a vértices de \(P_i\) pertencentes a \(T_i\) e o segundo verifica todas as regiões associadas a arestas de \(P_i\) pertencentes a \(T_i\). Caso o ponto \(p\) não pertença a nenhuma dessas regiões, retornamos a região de atravessar \(P_i\).

\begin{algorithm}[!ht]
\alglabel{alg:locate_point_first_approach}
\caption{Localiza Ponto — Primeira Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {LocalizaPonto(\(p, P_i, T_i, S_i\))} {

	\For {vértice \(v\) de \(P_i\) tal que existe uma aresta \(e\) em \(T_i\) incidente a \(v\)} {

		\((r^1, r^2) \leftarrow\) raios associados a \(v\) em \(S_i\) \\

		\If {\(r^1 \times r^2 \geq 0\)} {
			\If {\((r^1 \times (p - v) > 0) \land (r^2 \times (p - v) < 0)\)} {
				\Return {} região associada a \(v\)
			}
		}
		\Else {
			\If {\((r^1 \times (p - v) > 0) \lor (r^2 \times (p - v) < 0)\)} {
				\Return {} região associada a \(v\)
			}
		}
	}

	\For {aresta \(e = \overline{v^1 v^2}\) de \(P_i\) pertencente a \(T_i\)} {
		\(r^1 \leftarrow\) segundo raio associado a \(v^1\) em \(S_i\) \\
		\(r^2 \leftarrow\) primeiro raio associado a \(v^2\) em \(S_i\) \\

		\If {\((r^1 \times (p - v^1) > 0) \land (r^2 \times (p - v^2) < 0) \land ((p - v^1) \times (v^2 - v^1) < 0)\)} {
			\Return {} região associada a \(e\)
		}
	}

	\Return {} região de atravessar \(P_i\)
}

\end{algorithm}

Finalmente, uma vez que sabemos calcular \(T_i\), \(S_i\) e localizar um ponto \(p\) em \(S_i\), podemos implementar o algoritmo completo para resolver o TPP, conforme mostrado no Algoritmo~\algref{alg:tpp_complete-1-2}. Esse algoritmo itera sobre todos os polígonos \(P_1, \dots, P_k\), calculando \(T_i\) e \(S_i\) para cada polígono por meio dos algoritmos discutidos anteriormente. Após calcular todas as regiões de primeiro contato e mapas de último passo, o algoritmo retorna o \(k\)-path até o ponto \(t\) utilizando o Algoritmo~\algref{alg:consulta-caminho}. Esse algoritmo também será utilizado na segunda abordagem, na qual apenas o algoritmo~\texttt{LocalizaPonto} será modificado.

\begin{algorithm}[!ht]
\alglabel{alg:tpp_complete-1-2}
\caption{TPP Irrestrito — Implementação Completa}
\Input{Pontos \(s\) e \(t\), sequência de polígonos convexos disjuntos (\(P_1, \dots, P_k\))}

\Output{\(k\)-path até \(t\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {TPP\_Irrestrito(\(s, t, (P_1, \dots, P_k)\))} {

	\((T_1, \dots, T_k) \leftarrow \emptyset\) \\
	\((S_1, \dots, S_k) \leftarrow \emptyset\) \\

	\For {\(i \leftarrow 1\) até \(k\)} {
		
		\(T_i \leftarrow \text{RegiãoDePrimeiroContato}(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(S_i \leftarrow \text{MapaDeÚltimoPasso}(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1}))\)
	}

	\Return {} \(\text{ConsultaCaminho}(t, k, s, (P_1, \dots, P_k), (T_1, \dots, T_k), (S_1, \dots, S_k))\)

}

\end{algorithm}
\subsection{Segunda Abordagem}

Na segunda abordagem, alteramos apenas a implementação do algoritmo \texttt{LocalizaPonto}, utilizando uma estratégia de busca binária para localizar o ponto \(p\) no mapa de último passo \(S_i\). Definimos \(u^1, \dots, u^m\) como os vértices de \(P_i\) que pertencem a \(T_i\), ordenados em sentido anti-horário. A ideia central do algoritmo é utilizar \emph{arestas fictícias} que conectam dois vértices \(u^i\) e \(u^j\), formando uma nova região \(R\). Essa região possui a propriedade de que é possível verificar se \(p\) pertence a \(R\) em tempo \(O(1)\), e \(p\) está em \(R\) se e somente se está em alguma região de vértice ou de aresta entre \(u^i\) e \(u^j\). Dessa forma, podemos empregar uma estratégia de busca binária para localizar \(p\) em \(S_i\).

Assumimos que o ponto \(p\) não está no interior do polígono \(P_i\). Esse fato é garantido pela hipótese de que os polígonos são disjuntos, incluindo os pontos \(s\) e \(t\). Caso seja necessário lidar com situações em que \(p\) possa estar no interior de \(P_i\), o algoritmo pode ser iniciado com uma verificação de pertinência em tempo \(O(\log(\lvert P_i \rvert))\). Essa verificação, no entanto, não será discutida aqui, pois não é o foco deste trabalho.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.65\textwidth]{binary_search-1.png}
	\caption{Estratégia de busca binária para localizar um ponto em um mapa de último passo.}
	\label{fig:binary_search-1}
\end{figure}

A Figura~\ref{fig:binary_search-1} será utilizada para descrever cada etapa do algoritmo. O primeiro quadro apresenta um polígono \(P_i\) com 8 vértices, dos quais 5 pertencem a \(T_i\), denotados por \(u^1, \dots, u^5\). As regiões de vértice estão destacadas em vermelho, as regiões de aresta em verde e a região de travessia em azul. O objetivo é localizar um ponto nesse mapa de último passo. O algoritmo possui dois passos iniciais e, em seguida, inicia a busca binária, conforme descrito a seguir:

\begin{blockQuote}

\textbf{Algoritmo para localizar um ponto \(p\) em \(S_i\):}

\vspace{1em}

\noindent \textbf{Passo 1.} Verificar se \(p\) está na região de travessia de \(P_i\) (Quadro 2): criamos uma aresta fictícia entre \(u^5\) e \(u^1\), gerando uma região \(R\) que contém exatamente a região de travessia e parte de \(P_i\). A verificação se \(p\) pertence a \(R\) é feita utilizando a mesma estratégia do Algoritmo~\algref{alg:locate_point_first_approach}, considerando \(u^5\) e \(u^1\) como os vértices que definem a aresta fictícia e o segundo raio de \(u^5\) e o primeiro raio de \(u^1\) como os raios que delimitam \(R\). Caso \(p\) pertença a \(R\), retornamos a região de travessia.

\vspace{1em}

\noindent \textbf{Passo 2.} Verificar se \(p\) está em alguma região de vértice de \(u^1\) ou \(u^5\) (Quadro 3): utilizamos a mesma verificação do Algoritmo~\algref{alg:locate_point_first_approach}. Se \(p\) pertencer a alguma dessas regiões, retornamos a região correspondente.

\vspace{1em}

\noindent \textbf{Passo 3.} Busca binária (Quadro 4): sabendo que \(p\) não está nem na região de travessia nem nas regiões de vértice de \(u^1\) ou \(u^5\), iniciamos a busca binária entre os vértices \(u^1\) e \(u^5\). Selecionamos \(u^3\) como vértice intermediário e verificamos se \(p\) pertence à região de vértice de \(u^3\). Em caso afirmativo, retornamos essa região.

Caso contrário, criamos duas arestas fictícias, uma entre \(u^1\) e \(u^3\) e outra entre \(u^3\) e \(u^5\), gerando as regiões \(R_1\) (em roxo) e \(R_2\) (em laranja). Verificamos se \(p\) pertence a \(R_1\); se sim, repetimos o processo recursivamente considerando apenas os vértices entre \(u^1\) e \(u^3\). Caso contrário, sabemos que \(p\) pertence a \(R_2\) e repetimos o processo considerando apenas os vértices entre \(u^3\) e \(u^5\). Esse procedimento é repetido até que \(p\) pertença a uma região de vértice ou restem apenas dois vértices. Nesse último caso, concluímos que \(p\) está na região de aresta entre esses vértices.

\end{blockQuote}

A maior parte desse algoritmo é direta de implementar, exceto pela verificação se \(p\) pertence à região \(R_1\). Isso ocorre porque essa região pode assumir formas que não são cobertas pela verificação original do Algoritmo~\algref{alg:locate_point_first_approach}. Em particular, ao criar uma aresta fictícia entre dois vértices \(v^1\) e \(v^2\) com raios \(r^1\) e \(r^2\), pode ocorrer que esses raios formem um ângulo maior que \(180^\circ\) ou estejam em lados distintos da aresta fictícia, como ilustrado na Figura~\ref{fig:binary_search-2}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.7\textwidth]{binary_search-2.png}
	\caption{Quatro casos possíveis ao criar uma região de aresta fictícia.}
	\label{fig:binary_search-2}
\end{figure}

Desejamos determinar se um ponto \(p\) pertence à região de aresta fictícia entre os vértices \(v^1\) e \(v^2\), delimitada pelos raios \(r^1\) partindo de \(v^1\) e \(r^2\) partindo de \(v^2\). Os casos são definidos pelo lado em que \(r^1\) e \(r^2\) se encontram em relação à direção \(d = v^2 - v^1\), e tratamos cada situação separadamente:

\begin{itemize}

	\item \(d \times r^1 < 0 \land d \times r^2 < 0\): caso ilustrado no primeiro quadro da Figura~\ref{fig:binary_search-2}. Verificamos se \(p\) está entre os raios \(r^1\) e \(r^2\) e do lado externo da aresta \(\overline{v^1 v^2}\).

	\item \(d \times r^1 > 0 \land d \times r^2 > 0\): ilustrado no segundo quadro da Figura~\ref{fig:binary_search-2}. Esse caso é o complemento do anterior. Verificamos se \(p\) não está entre os raios \(r^1\) e \(r^2\) e se está do lado interno da aresta \(\overline{v^1 v^2}\).

	\item \(d \times r^1 < 0 \land d \times r^2 > 0\): ilustrado no terceiro quadro da Figura~\ref{fig:binary_search-2}. Inicialmente verificamos de que lado da reta que contém \(\overline{v^1 v^2}\) o ponto \(p\) se encontra. Se \(p\) estiver do lado externo, verificamos se está do lado negativo de \(r^2\); caso contrário, verificamos se está do lado positivo de \(r^1\).

	\item \(d \times r^1 > 0 \land d \times r^2 < 0\): ilustrado no quarto quadro da Figura~\ref{fig:binary_search-2}. Procedemos de forma análoga ao caso anterior, invertendo os testes correspondentes aos raios.

\end{itemize}

Com essas verificações, podemos implementar o algoritmo \texttt{LocalizaPonto} utilizando a estratégia de busca binária, conforme apresentado no Algoritmo~\algref{alg:locate_point_second_approach}. Nesse algoritmo, implementamos a função auxiliar \texttt{VerificaAresta}, responsável por verificar se \(p\) pertence à região de uma aresta fictícia entre dois vértices \(v^1\) e \(v^2\), de acordo com os casos discutidos anteriormente. A verificação se \(p\) pertence à região de vértice de um dado vértice \(u^{mid}\) é abstraída, pois é idêntica àquela utilizada no Algoritmo~\algref{alg:locate_point_first_approach}.

A principal vantagem dessa abordagem é que a busca binária reduz o número de regiões de vértice verificadas para localizar \(p\) em \(S_i\) de \(O(\lvert T_i \rvert)\) para \(O(\log(\lvert T_i \rvert))\), o que pode representar uma melhoria significativa quando \(P_i\) possui muitos vértices em \(T_i\). Analisaremos o impacto dessa modificação com mais detalhes na análise de complexidade.

\begin{algorithm}[!ht]
\alglabel{alg:locate_point_second_approach}
\caption{Localiza Ponto — Segunda Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {LocalizaPonto(\(p, P_i, T_i, S_i\))} {

	\Function {VerificaAresta(\(v^1, v^2\))} {
		\(r^1 \leftarrow\) segundo raio associado a \(v^1\) em \(S_i\) \\
		\(r^2 \leftarrow\) primeiro raio associado a \(v^2\) em \(S_i\) \\

		\(d \leftarrow v^2 - v^1\) \\

		\If {\(d \times r^1 < 0 \land d \times r^2 < 0\)} {
			\Return {} \(r^1 \times (p - v^1) > 0 \land r^2 \times (p - v^2) < 0 \land (p - v^1) \times (v^2 - v^1) < 0\)
		}
		\ElseIf {\(d \times r^1 > 0 \land d \times r^2 > 0\)} {
			\Return {} \(r^1 \times (p - v^1) \leq 0 \land r^2 \times (p - v^2) \geq 0 \land (p - v^1) \times (v^2 - v^1) \geq 0\)
		}
		\ElseIf {\(d \times r^1 < 0 \land d \times r^2 > 0\)} {
			\If {\((p - v^1) \times (v^2 - v^1) < 0\)} {
				\Return {} \(r^2 \times (p - v^2) < 0\)
			}
			\Else {
				\Return {} \(r^1 \times (p - v^1) > 0\)
			}
		}
		\Else {
			\If {\((p - v^1) \times (v^2 - v^1) < 0\)} {
				\Return {} \(r^1 \times (p - v^1) > 0\)
			}
			\Else {
				\Return {} \(r^2 \times (p - v^2) < 0\)
			}
		}
	}

	\(u_1, \dots, u_m \leftarrow\) vértices de \(P_i\) em \(T_i\), ordenados em sentido anti-horário \\

	\If {VerificaAresta(\(u^m, u^1\))} {
		\Return {} região de atravessar \(P_i\)
	}
	\If {\(p\) está na região de vértice de \(u^1\)} {
		\Return {} região associada a \(u^1\)
	}

	\If {\(p\) está na região de vértice de \(u^m\)} {
		\Return {} região associada a \(u^m\)
	}

	\(l \leftarrow 1\) \\
	\(r \leftarrow m\)

	\While {\(l + 1 \ne r\)} {

		\(mid \leftarrow \floor{(l + r) / 2}\)

		\If {\(p\) está na região de vértice de \(u^{mid}\)} {
			\Return {} região associada a \(u^{mid}\)
		}

		\If {VerificaAresta(\(u^{l}, u^{mid}\))} {
			\(r \leftarrow mid\)
		}
		\Else {
			\(l \leftarrow mid\)
		}
	}

	\Return {} região associada a aresta \(\overline{u^{l} u^{r}}\)
}

\end{algorithm}
\subsection{Terceira Abordagem}

Antes de discutirmos a terceira abordagem, apresentamos a motivação para essa nova implementação do algoritmo \texttt{LocalizaPonto}. Considere o caso de um único polígono \(P_1\) com um grande número de vértices, por exemplo, um milhão. Pela segunda abordagem, calculamos \(T_1\), em seguida \(S_1\) e, finalmente, realizamos uma única consulta ao mapa de último passo \(S_1\) para localizar o ponto \(t\). No entanto, essa consulta utiliza no máximo cerca de 20 regiões de vértice de \(P_1\) para localizar \(t\) em \(S_1\). Assim, acabamos calculando aproximadamente 999\,980 regiões de vértice que nunca são utilizadas. Diante disso, na terceira abordagem buscamos empregar uma estratégia de memoização, de modo a calcular apenas as regiões de vértice de \(P_i\) que são efetivamente necessárias para localizar os pontos consultados no mapa de último passo \(S_i\).

O primeiro problema a ser resolvido é determinar se uma dada aresta \(e = \overline{v^1 v^2}\) de \(P_i\) pertence a \(T_i\) realizando apenas uma única chamada ao algoritmo \texttt{ConsultaÚltimoPasso}. Para isso, reutilizamos a ideia do Algoritmo~\algref{alg:first_contact_region}, que originalmente calculava \(T_i\) por completo. Agora, ao invés de verificar todas as arestas de \(P_i\), verificamos apenas a aresta \(e\). Calculamos o último passo \(q\) do \((i-1)\)-path até o vértice \(v^1\) da aresta \(e\) e verificamos o sinal de \((q - v^1) \times (v^2 - v^1)\). Se esse valor for negativo, então \(e\) pertence a \(T_i\); caso contrário, não pertence.

Em seguida, precisamos calcular os raios associados a um vértice \(v\) de \(P_i\) em \(S_i\), novamente realizando apenas uma única chamada ao algoritmo \texttt{ConsultaÚltimoPasso}. Para isso, adaptamos a ideia do Algoritmo~\algref{alg:last_step_map}, que originalmente calculava \(S_i\) por completo. Agora, em vez de calcular os raios para todos os vértices de \(P_i\), calculamos apenas os raios associados ao vértice \(v\). Contudo, esse algoritmo pressupõe que sabemos quais arestas de \(P_i\) pertencem a \(T_i\), de modo que precisamos determinar se as arestas incidentes em \(v\) pertencem a \(T_i\) sem realizar chamadas adicionais ao algoritmo \texttt{ConsultaÚltimoPasso}.

Para resolver isso, retomamos a caracterização de que, dada uma aresta \(e\) de \(P_i\), um ponto \(p\) em \(e\) e o último passo \(q\) do \((i-1)\)-path até \(p\), temos que \(e \in T_i\) se e somente se \((q - p)\) está do lado externo de \(e\). Assim, seja \(v\) um vértice de \(P_i\) e sejam \(e^1\) e \(e^2\) as arestas incidentes em \(v\). Calculamos o último passo \(q\) do \((i-1)\)-path até \(v\) e verificamos se o vetor \((q - v)\) está do lado externo de \(e^1\) e de \(e^2\), determinando, assim, se essas arestas pertencem a \(T_i\). Com essa informação, podemos adaptar diretamente o Algoritmo~\algref{alg:last_step_map} para calcular apenas os raios associados a \(v\) em \(S_i\).

Uma observação importante é que, como não conhecemos previamente \(T_i\), pode ocorrer de tentarmos calcular os raios associados a um vértice \(v\) de \(P_i\) em \(S_i\) sem que nenhuma das arestas incidentes em \(v\) pertença a \(T_i\). Nesse caso, o algoritmo não precisa de qualquer modificação, pois seu comportamento natural é retornar dois raios com a mesma direção do último segmento do \((i-1)\)-path que chega a \(v\). Isso corresponde a uma região vazia em \(S_i\), o que é consistente com o fato de que \(v\) não pertence a \(T_i\).

Com essas ideias, podemos finalmente descrever a implementação do algoritmo \texttt{LocalizaPonto} utilizando a estratégia de memoização. Reutilizamos a busca binária da segunda abordagem, mas agora os passos iniciais são simplificados, pois a verificação da região de travessia é postergada para o final do algoritmo. O procedimento segue da seguinte forma:

\begin{blockQuote}

\textbf{Algoritmo para localizar um ponto \(p\) em \(S_i\):}

\vspace{1em}

\noindent \textbf{Passo 1.} Sejam \(v^1, \dots, v^m\) os vértices de \(P_i\) ordenados em sentido anti-horário. Calculamos os raios associados a \(v^1\) em \(S_i\) e verificamos se \(p\) pertence à região de vértice de \(v^1\). Em caso afirmativo, retornamos essa região.

\vspace{1em}

\noindent \textbf{Passo 2.} Seja \(v' = v^{\lfloor m / 2 \rfloor}\). Calculamos os raios associados a \(v'\) em \(S_i\) e verificamos se \(p\) pertence à sua região de vértice. Se isso ocorrer, retornamos essa região.

Caso contrário, criamos as arestas fictícias entre \(v^1\) e \(v'\) e entre \(v'\) e \(v^m\), gerando as regiões \(R_1\) e \(R_2\). Verificamos se \(p\) pertence a \(R_1\) utilizando o mesmo procedimento descrito no Algoritmo~\algref{alg:locate_point_second_approach}. Se sim, repetimos esse passo considerando apenas os vértices entre \(v^1\) e \(v'\); caso contrário, repetimos o procedimento considerando apenas os vértices entre \(v'\) e \(v^m\).

Esse passo é repetido até que encontremos um vértice \(v^k\) tal que \(p\) pertença à sua região de vértice ou restem apenas dois vértices \(v^l\) e \(v^r\). Nesse último caso, sabemos que \(p\) deve estar na região de aresta entre esses vértices.

\vspace{1em}

\noindent \textbf{Passo 3.} Caso \(p\) não tenha sido localizado em uma região de vértice, concluímos que ele está na região de aresta entre os dois últimos vértices \(v^l\) e \(v^r\). Para finalizar, utilizamos as ideias discutidas anteriormente para determinar, com uma única consulta, se essa aresta pertence a \(T_i\). Se pertencer, retornamos a região de aresta correspondente; caso contrário, retornamos a região de travessia de \(P_i\).

\end{blockQuote}

Dessa forma, concluímos a descrição da terceira abordagem para a implementação do algoritmo \texttt{LocalizaPonto} utilizando memoização. Optamos por não apresentar o pseudocódigo completo dessa abordagem, pois ele seria muito semelhante ao Algoritmo~\algref{alg:locate_point_second_approach}, diferindo apenas pelas modificações discutidas acima.
\subsection{Análise de Complexidade}

Começamos analisando a complexidade da primeira abordagem. Seja \(\abs{P_i}\) o número de vértices do polígono \(P_i\) e \(\abs{T_i}\) o número de arestas em \(T_i\). Seja ainda \(k\) o número total de polígonos na sequência \(P_1, \dots, P_k\) e \(n\) o número total de vértices em todos os polígonos, isto é,
\[
n = \sum_{i = 1}^{k} \abs{P_i}.
\]

\begin{itemize}

	\item \textbf{\texttt{LocalizaPonto}} (\algref{alg:locate_point_first_approach}): A complexidade desse algoritmo é \(O(\abs{T_i})\), pois, no pior caso, é necessário verificar todas as regiões de vértice e de aresta associadas a \(T_i\) para localizar o ponto \(p\).

	\item \textbf{ConsultaÚltimoPasso} e \textbf{ConsultaCaminho} (\algref{alg:consulta-ultimo-passo} e \algref{alg:consulta-caminho}): Ambos os algoritmos iniciam com uma chamada ao algoritmo \texttt{LocalizaPonto}. O pior caso ocorre quando o ponto \(p\) pertence à região de travessia de \(P_i\) ou a uma região de aresta, o que exige uma nova consulta ao mapa de último passo \(S_{i-1}\). Assim, no pior caso, são feitas \(i\) chamadas ao algoritmo \texttt{LocalizaPonto}, resultando em uma complexidade total de
	\[
	O\!\left(\sum_{j = 1}^{i} \abs{T_j}\right).
	\]

	\item \textbf{RegiãoDePrimeiroContato} e \textbf{MapaDeÚltimoPasso} (\algref{alg:first_contact_region} e \algref{alg:last_step_map}): Ambos os algoritmos realizam uma única passagem pelos vértices de \(P_i\), fazendo uma consulta para cada vértice. Dessa forma, a complexidade desses algoritmos é
	\[
	O\!\left(\abs{P_i} \sum_{j = 1}^{i} \abs{T_j}\right).
	\]

	\item \textbf{TPP completo} (\algref{alg:tpp_complete-1-2}): O algoritmo executa uma chamada para calcular \(T_i\) e \(S_i\) para cada \(i = 1, \dots, k\), e ao final realiza uma chamada para consultar o caminho até o ponto \(t\). Assim, a complexidade total do algoritmo TPP é dada por
	\begin{align*}
		O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{T_j} + \sum_{j = 1}^{k} \abs{T_j}\right)
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{P_j} + \sum_{j = 1}^{k} \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \cdot n\right) \\
		&= O(n^2).
	\end{align*}

\end{itemize}

Assim, concluímos que a complexidade total do algoritmo TPP utilizando a primeira abordagem é \(O(n^2)\). A seguir, analisamos a complexidade da segunda abordagem.

\begin{itemize}

	\item \textbf{\texttt{LocalizaPonto}} (\algref{alg:locate_point_second_approach}): A complexidade desse algoritmo é \(O(\log \abs{T_i})\), correspondente ao pior caso da busca binária utilizada para localizar o ponto \(p\) em \(S_i\).

	\item \textbf{ConsultaÚltimoPasso} e \textbf{ConsultaCaminho}: De forma análoga ao caso anterior, o pior caso envolve \(i\) chamadas ao algoritmo \texttt{LocalizaPonto}, resultando em uma complexidade
	\[
	O\!\left(\sum_{j = 1}^{i} \log \abs{T_j}\right).
	\]

	\item \textbf{RegiãoDePrimeiroContato} e \textbf{MapaDeÚltimoPasso}: Cada um desses algoritmos percorre os vértices de \(P_i\) e realiza uma consulta para cada vértice. Portanto, a complexidade é
	\[
	O\!\left(\abs{P_i} \sum_{j = 1}^{i} \log \abs{T_j}\right).
	\]

	\item \textbf{TPP completo}: O custo total do algoritmo é
	\begin{align*}
		O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{T_j} + \sum_{j = 1}^{k} \log \abs{T_j}\right)
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log \abs{P_j}\right) \\
		&= O\!\left(n \sum_{j = 1}^{k} \log \abs{P_j}\right).
	\end{align*}

	Observando que a soma \(\sum_{j = 1}^{k} \log \abs{P_j}\) é maximizada quando todos os polígonos possuem o mesmo número de vértices, isto é, quando \(\abs{P_j} = n/k\) para todo \(j\), obtemos que a complexidade final do algoritmo TPP usando a segunda abordagem é
	\[
	O\!\left(nk \log (n/k)\right).
	\]

\end{itemize}

Portanto, a complexidade final do algoritmo TPP utilizando a segunda abordagem é \(O(nk \log (n/k))\). Essa complexidade coincide exatamente com a apresentada por Dror et al.~(2003)~\cite{tpp-dror2003}, o que indica que nossa implementação atinge a mesma eficiência assintótica da proposta original.

Por fim, resta analisar a complexidade da terceira abordagem. Essa análise é mais delicada, pois a complexidade do algoritmo \texttt{LocalizaPonto} passa a depender fortemente da instância específica, em particular da distribuição dos vértices nos polígonos e das consultas efetivamente realizadas ao mapa de último passo. Ainda assim, é imediato observar que a terceira abordagem nunca será pior do que a segunda, uma vez que, no pior caso, todas as regiões de vértice em \(T_i\) serão calculadas, recuperando exatamente o comportamento da segunda abordagem. Assim, concluímos que a complexidade da terceira abordagem é \(O(nk \log (n/k))\) no pior caso, podendo ser significativamente melhor em instâncias favoráveis, dependendo do padrão das consultas realizadas.

\
\newpage

\printbibliography

\newpage

\end{document}
