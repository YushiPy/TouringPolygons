
\documentclass[11pt]{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

% make conditions/keyword arguments use text mode
\renewcommand{\algorithmcfname}{Algoritmo}

\SetKwInOut{Input}{Entrada}
\SetKwInOut{Output}{Saída}
\SetKwIF{If}{ElseIf}{Else}{se}{:}{senão se}{senão}{end}
\SetKwFor{For}{para cada}{:}{end}
\SetKwRepeat{Do}{do}{enquanto}

\SetKwProg{Function}{define}{:}{}
\SetKw{Return}{retorna}
\SetProgSty{upshape} % tell it not to italicize
\renewcommand{\ProgSty}[1]{\textnormal{#1}\unskip} % enforce upright text


\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{#1}%
}

\newcommand{\algref}[1]{\ref{#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
% \usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
%\usepackage[backend=biber,style=ieee]{biblatex}
%\addbibresource{referencias.bib}
\usepackage{csquotes}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{cleveref}
\usepackage{desclist}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blank}{}{} % Blank enviroment for folding sections in editors

\newenvironment{blockQuote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}
\DeclarePairedDelimiter{\anglebrackets}{\langle}{\rangle}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
% \pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

% Footnote spacing
\setlength{\skip\footins}{0.5cm}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}


\title{\textbf{O Problema de Visita de Polígonos}\thanks{Esse trabalho foi parcialmente apoiado pela agência FAPESP (processo 2025/13861-1).}}

\author{
	Gabriel F. Ushijima\thanks{Instituto de Matemática e Estatística, Universidade de São Paulo, Rua do Matão, 1010, Cidade Universitária,
05508-090, São Paulo, SP, Brazil (e-mail: gabriel\_ushijima@ime.usp.br, egbirgin@ime.usp.br).\vspace{0.5cm}}
	\and
	\(\text{Ernesto G. Birgin}^\dagger\)
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}

Este trabalho apresenta diferentes implementações de algoritmos para o Problema de Visita de Polígonos (Touring Polygons Problem - TPP), que consiste em encontrar um caminho de comprimento mínimo na norma Euclidiana que parte de um ponto inicial, visita uma sequência de polígonos e chega em um ponto final no plano. Em sua forma geral, o problema é NP-difícil. Por esse motivo, inicialmente consideramos uma versão simplificada em que os polígonos são convexos e não se sobrepõem, para a qual apresentamos um algoritmo exato baseado em mapas de último passo. Em seguida, para o caso não convexo, particionamos cada polígono não convexo em um conjunto de polígonos convexos e utilizamos nossa solução anterior para resolver cada combinação possível de polígonos convexos. Como essa solução é um tanto ineficiente, discutimos estratégias de otimização inteira mista para melhorar a performance dessa estratégia. Por fim, realizamos experimentos computacionais para avaliar o desempenho dos algoritmos propostos em instâncias de diferentes tamanhos e características, comparando-os com solvers comerciais. Os resultados indicam que as abordagens desenvolvidas são eficazes em uma ampla variedade de cenários.

\vspace{10pt}

\noindent \textbf{Palavras-chave:} problema de visita de polígonos, otimização geométrica, complexidade, experimentos numéricos.
\end{abstract}

\section{Introdução}

O Problema de Visita de Polígonos (Touring Polygons Problem - TPP), introduzido em~\cite{tpp-dror2003}, é um problema de otimização geométrica que consiste em encontrar um caminho de comprimento mínimo na norma Euclidiana que parte de um ponto inicial, visita uma sequência de polígonos e chega em um ponto final no plano. Esse tipo de problema surge naturalmente em aplicações de roteirização e planejamento de trajetórias, especialmente no contexto de veículos autônomos, nos quais é necessário garantir a visita eficiente a regiões específicas do espaço, como em tarefas de inspeção automatizada de armazéns~\cite{jianxian2023, karl2009}. Podemos interpretar esse problema como um caso específico do Problema do Caixeiro Viajante com Regiões (\textit{Traveling Salesman Problem with Neighborhoods} - TSPN)~\cite{tspn-arkin2005}, no qual o objetivo é encontrar um caminho de comprimento mínimo que visite um conjunto de regiões arbitrárias no plano, sendo que, no TPP, essas regiões são representadas por polígonos e a ordem de visita é pré-definida.

Dentre as diversas variações do problema, consideramos inicialmente uma versão simplificada em que os polígonos são convexos e não se sobrepõem. Consideramos ainda que a distância é medida na norma Euclidiana. Para esse caso, apresentamos três abordagens distintas para resolver o problema de forma exata. As duas primeiras são baseadas em ideias descritas em~\cite{tpp-dror2003}, enquanto a terceira é uma extensão que utiliza técnicas de memoização para melhorar o desempenho em diversos casos que exploraremos adiante. Considerando que \(k\) é o número de polígonos e \(n\) é a soma do número de vértices dos \(k\) polígonos, as abordagens propostas são as seguintes:

\begin{enumerate}

	\item Implementação intuitiva das ideias descritas em~\cite{tpp-dror2003}, baseadas em mapas de último passo, resolvendo o problema em tempo \(O(n^2)\). Buscamos familiarizar o leitor com os conceitos e técnicas fundamentais para a resolução do TPP, como as regiões de primeiro contato e os mapas de último passo, que serão utilizados em todas as implementações subsequentes.

	\item Implementação que melhora a eficiência da primeira ao empregar uma estratégia de busca binária para a localização de pontos nos mapas de último passo, resolvendo o problema em tempo \(O(n k \log (n / k))\), como descrito em~\cite{tpp-dror2003}.

	\item Implementação que utiliza uma técnica de memoização, com o objetivo de evitar cálculos redundantes e reduzir o custo computacional. Mantemos a mesma complexidade de pior caso da abordagem anterior, \(O(n k \log (n / k))\), mas, a depender do tamanho dos polígonos, pode apresentar um desempenho significativamente melhor na prática.

\end{enumerate}

Em seguida, buscamos resolver o caso geral do TPP, no qual os polígonos podem ser não convexos. Para isso, particionaremos cada polígono não convexo em um conjunto de polígonos convexos e aplicaremos as soluções desenvolvidas para o caso convexo sobre cada combinação possível de polígonos convexos resultantes. Essa abordagem é, a priori, ineficiente, assim buscamos otimizar o processo por meio de técnicas de otimização combinatória.

Além disso, outra forma de resolver o caso geral do TPP é modelá-lo como um problema de programação inteira mista (Mixed Integer Linear Programming - MILP) e utilizar solvers comerciais, como o~\href{https://www.gurobi.com}{Gurobi}, para obter uma solução. Essa abordagem também resolve o problema de forma exata. Assim, buscamos mostrar que nossa implementação é competitiva mesmo quando comparada a solvers comerciais de alto desempenho.

\section{O Problema de Visita de Polígonos Convexos}

Inicialmente, consideramos o TPP em sua versão mais simples, na qual os polígonos são convexos e não se sobrepõem, denominada TPP Irrestrito. Utilizamos tanto a formulação quanto a solução apresentadas em~\cite{tpp-dror2003} como base para nossas implementações. Para nossos propósitos, definimos o problema da seguinte forma:

\begin{blockQuote}

	{\large \textbf{TPP Convexo:}} Dados pontos~\(s, t \in \mathbb{R}^2\) e polígonos convexos disjuntos~\(P_1, \dots, P_k\), encontre pontos~\(p_i \in P_i\) para \(i = 1, 2, \dots, k\) de forma tal que o caminho que sai de~\(s\), passa por~\(p_1, \dots, p_k\) e termina em~\(t\) tenha comprimento mínimo.
	
	%Dado um ponto inicial~\(s \in \mathbb{R}^2\), um ponto final~\(t \in \mathbb{R}^2\) e uma sequência de polígonos convexos e disjuntos~\(P_1, \dots, P_k\), dados por sequências de vértices ordenados em sentido anti-horário, encontre um caminho~\(\pi\) de comprimento mínimo que se inicia em~\(s\), termina em~\(t\), e para o qual existem pontos~\(p_1, \dots, p_k\) tais que~\(p_i \in P_i\) para todo~\(i = 1, 2, \dots, k\), e o caminho~\(\pi\) passa por esses pontos nessa mesma ordem.

\end{blockQuote}

Todas as implementações a seguir têm como base as definições e propriedades apresentadas em~\cite{tpp-dror2003}. A seguir, incluímos as principais definições que serão utilizadas. Daqui em diante supomos que um polígono é dado como uma sequência de vértices em sentido anti-horário. Supomos ainda que~\(P_0 = \{s\}\) e~\(P_{k+1}=\{t\}\).

\begin{description}

	\item[Caminho Parcial Ótimo] (\(i\)-path): Um~\(i\)-path (\(0 \le i \le k\)) até um ponto~\(p \in \mathbb{R}^2\) é um caminho de comprimento mínimo que se inicia em~\(s\), termina em~\(p\) e visita os polígonos~\(P_1, P_2, \dots, P_i\) nessa ordem. Por estarmos considerando a distância Euclidiana, todo~\(i\)-path é formado pela união de segmentos de reta; assim, tratamos caminhos como sequências ordenadas de pontos em~\(\mathbb{R}^2\). Além disso, como estamos lidando com polígonos convexos, todo \(i\)-path é único, isso ficará claro a partir da definição de mapa de último passo e suas propriedades, que apresentamos adiante. Por esse motivo, vamos nos referir a um \(i\)-path como \textbf{o} \(i\)-path até um ponto~\(p\).
	
	Vale notar que o~0-path até~\(p\) é simplesmente o segmento de reta~\(\overline{sp}\) e o~\(k\)-path até~\(t\) é exatamente a solução do problema.
	
	Veja a Figura~\ref{fig:i_path} para um exemplo de um 2-path até \(t\). Note que a ordem deve ser respeitada, pois visitar~\(P_2\) antes de~\(P_1\) seria mais eficiente nesse caso.
	
	\item[Região de Primeiro Contato] (\(T_i\)): Denotamos por~\(T_i\) (\(1 \leq i \leq k\)) à região de primeiro contato de um polígono~\(P_i\). Seja~\(p \in P_i\) e seja~\(q \in P_{i-1}\) o ponto anterior a~\(p\) no~\(i\)-path até~\(p\). Temos que~\(p \in T_i\) se e somente se~\(\overline{pq} \cap P_i = p\). Em outras palavras,~\(T_i\) consiste dos pontos~\(p\) no perímetro de~\(P_i\) tais que o último segmento do~\((i - 1)\)-path até \(p\) não atravessa o interior de~\(P_i\). É fácil ver que apenas pontos na fronteira de~\(P_i\) fazem parte de~\(T_i\). Note ainda que~\(T_i\) é sempre composta por uma região contínua de arestas de~\(P_i\).
	
	Veja a Figura~\ref{fig:first_contact} para um exemplo das regiões de primeiro contato~\(T_1\) e~\(T_2\) dos polígonos~\(P_1\) e~\(P_2\), respectivamente.

	\begin{figure}[!ht]
	\centering
	\begin{minipage}{0.44\textwidth}
		\centering
		\includegraphics[width=\linewidth]{i_path.png}
		\caption{Caminho mínimo de~\(s\) até~\(t\) visitando~\(P_1\) e~\(P_2\).}
		\label{fig:i_path}
	\end{minipage}
	\hspace{10pt}
	\begin{minipage}{0.44\textwidth}
		\centering
		\includegraphics[width=\linewidth]{first_contact.png}
		\caption{Região de primeiro contato~\(T_1\) de~\(P_1\) e~\(T_2\) de~\(P_2\).}
		\label{fig:first_contact}
	\end{minipage}

	\end{figure}

	\item[Mapa de Último Passo] (\(S_i\)): Denotamos por~\(S_i\) \((1 \le i \le k)\) o mapa de último passo de um polígono~\(P_i\), que consiste em uma partição do plano em um número finito de regiões. Na partição podem existir duas ou mais regiões do tipo ``região de vértice'', uma ou mais regiões do tipo ``região de aresta'' e exatamente uma região do tipo ``região de atravessar''. Cada região de vértice em~\(S_i\) está associada a um vértice~\(v\) de~\(P_i\) assim como cada região de aresta está associada a uma aresta~\(e\) de~\(P_i\). Apenas vértices e arestas em~\(T_i\) têm uma região associada em~\(S_i\).
	
	Um ponto~\(p \in \mathbb{R}^2\) pertence a uma região de vértice associada ao vértice~\(v\) de~\(P_i\) se e somente se o \(i\)-path até~\(p\) tem~\(\overline{vp}\) como último segmento. Analogamente,  um ponto~\(p \in \mathbb{R}^2\) pertence a uma região de aresta associada à aresta~\(e\) de~\(P_i\) se e somente se o último segmento do~\(i\)-path até~\(p\) inicia-se no interior de~\(e\). Por último, um ponto~\(p \in \mathbb{R}^2\) pertence à região de atravessar de~\(P_i\) se e somente se não pertence a nenhuma região de vértice ou aresta.
	
	Veja a Figura~\ref{fig:last_step_map} para um exemplo de mapa de último passo de um polígono~\(P_1\). As regiões de vértice são pintadas em vermelho, as regiões de aresta em verde e a região de atravessar em azul. Para cada região, incluimos um exemplo de ponto pertencente a ela, bem como o~\(1\)-path até esse ponto, ilustrando a definição de cada tipo de região. Note que o mapa de último passo é uma partição do plano, ou seja, cada ponto do plano pertence a exatamente uma região do mapa, notando que o polígono em si faz parte da região de atravessar.

	\begin{figure}[!htb]
		\vspace{1em}
		\centering
		\begin{minipage}[t]{0.55\textwidth}
			\includegraphics[width=\textwidth]{last_step_map.png}
		\end{minipage}
		\caption{Exemplo do mapa de último passo~\(S_1\) de~\(P_1\). Os pontos em vermelho pertencem a regiões de vértice, os pontos em verde pertencem a regiões de aresta e os pontos em azul pertencem à região de atravessar, incluimos o \(1\)-path até cada um deles na figura.}
		\label{fig:last_step_map}
	\end{figure}

\end{description} 

Sejam~\(p \in \mathbb{R}^2\) e~\(1 \le i \le k\), se dispomos de \(S_1, \dots, S_i\), podemos determinar o~\(i\)-path até~\(p\) de forma eficiente, dependendo do tipo de região à qual~\(p\) pertence no mapa de último passo~\(S_i\), da seguinte forma:

\begin{description}

	\item[Região de Vértice:] Se~\(p\) pertence a uma região associada a um vértice~\(v\) de~\(P_i\), então o último segmento do~\(i\)-path até~\(p\) é o segmento~\(\overline{vp}\). Assim, o~\(i\)-path até~\(p\) é simplesmente o~\((i - 1)\)-path até~\(v\), seguido do segmento~\(\overline{vp}\). 
	
	A Figura~\ref{fig:vertex_region} ilustra essa situação. Temos o ponto~\(p^1\) antecedido por~\(q^1\) e~\(p^2\) antecidido por~\(q^2\), tanto~\(q^1\) quanto~\(q^2\) são vértices de~\(P_2\). Fizemos questão de incluir tanto~\(p^1\) quanto~\(p^2\) para ilustrar que o mapa de último passo~\(S_2\) apenas nos informa sobre o \textbf{último segmento} do 2-path, não sobre o caminho completo, ou seja, não podemos afirmar nada sobre o último segmento do caminho até~\(q^1\) ou~\(q^2\). De fato, no exemplo escolhido, obeservamos que o último segmento até~\(q^1\) parte de um vértice de \(P^1\) enquanto o último segmento até~\(q^2\) parte do interior de uma aresta de~\(P^1\). Para saber o caminho completo até~\(p^1\) ou~\(p^2\), precisamos consultar \(S_1\) além de \(S_2\).

	\item[Região de Atravessar:] Se~\(p\) pertence à região de atravessar de~\(P_i\), então o último segmento do~\(i\)-path até~\(p\) atravessa o interior de~\(P_i\). Nesse caso, o~\(i\)-path até~\(p\) é dado pelo \((i - 1)\)-path até~\(p\). A Figura~\ref{fig:pass_through} ilustra essa situação, em que o 2-path até \(p\) é o mesmo que o 1-path até \(p\) e atravessa \(P_2\). 
	
	\begin{figure}[!ht]
	\centering
	\begin{minipage}{0.44\textwidth}
		\centering
		\includegraphics[width=\linewidth]{paths-vertices.png}
		\caption{2-path até~\(p^1\) e~\(p^2\), que estão em regiões de vértice.}
		\label{fig:vertex_region}
	\end{minipage}
	\hspace{10pt}
	\begin{minipage}{0.44\textwidth}
		\centering
		\includegraphics[width=\linewidth]{paths-pass.png}
		\caption{2-path até~\(p\), que está em uma região de atravessar.}
		\label{fig:pass_through}
	\end{minipage}

	\end{figure}

	\item[Região de Aresta:] Se~\(p\) pertence a uma região associada a uma aresta~\(e = \overline{u v}\) de~\(P_i\), então refletimos o ponto~\(p\) em relação à reta que contém~\(e\), obtendo um ponto refletido~\(p'\). Calculamos o~\((i - 1)\)-path até~\(p'\) cujo último segmento parte de um ponto~\(q'\) e chamamos de~\(q\) à interseção do segmento~\(\overline{q'p'}\) com a aresta~\(e\). O~\(i\)-path até~\(p\) é então formado pela parte do~\((i - 1)\)-path até~\(p'\) que vai desde o inicio (ponto~\(s\)) até o ponto~\(q\), seguida do segmento~\(\overline{qp}\). A Figura~\ref{fig:edge_region} ilustra essa situação, mostrando como o ponto deve ser refletido e então como usamos o~\((i - 1)\)-path até~\(p'\) para determinar o~\(i\)-path até~\(p\) % \textcolor{blue}{Aqui deve dizer: A Figura 1b ilustra esta situação.}
	
	A seguir, apresentamos a fórmula para calcular o ponto refletido~\(p'\) e o ponto de interseção~\(q\). Usamos o operador~\(\cdot\) para denotar o produto escalar, o operador~\(\|\cdot\|\) para denotar a norma euclidiana e o operador~\(\times\) para denotar o produto vetorial\footnote{Para dois vetores \(a = (a_x, a_y)\) e \(b = (b_x, b_y)\), temos \(a \times b = a_x b_y - a_y b_x\).}, todos em \(\mathbb{R}^2\):
	\begin{align}
		&p' = p + 2 \frac{(u - p) \cdot (v - u)}{\|v - u\|^2} (v - u), \label{eq:reflection_on_edge} \\
		&q = q' + \frac{(u - q') \times (v - u)}{(p' - q') \times (v - u)} (p' - q'). \label{eq:intersection_on_edge}
	\end{align}

	\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.5\linewidth]{paths-edge.png}
	\caption{2-path até~\(p\), que pertence a uma região de aresta associada à aresta~\(\overline{uv}\) de~\(P_2\). Ilustramos o ponto refletido \(p'\), o ponto que antecede \(p'\), \(q'\) e o ponto de interseção \(q\).}
	\label{fig:edge_region}
	\end{figure}
	
\end{description}

Com base nessas ideias, implementamos o Algoritmo~\algref{alg:consulta-caminho}, que, dado um ponto~\(p \in \mathbb{R}^2\) e um índice~\(1 \le i \le k\), retorna o~\(i\)-path até~\(p\) como uma sequência de pontos em~\(\mathbb{R}^2\), desconsiderando o último ponto do caminho,~\(p\), que é conhecido. Assumimos também a existência de uma função \texttt{LocalizaPonto}, que, dado~\(p \in \mathbb{R}^2\) e~\(1 \leq i \leq k\), localiza o ponto~\(p\) no mapa de último passo~\(S_i\) de~\(P_i\) e retorna a região~\(R\) à qual~\(p\) pertence. Essa região carrega tanto o tipo de região à qual o ponto pertence assim como o vértice~\(v\) da região se for uma região de vértice ou a aresta~\(e\) se for uma região de aresta.

\begin{algorithm}[!ht]
\alglabel{alg:consulta-caminho}
\caption{Consulta Caminho}
\Input{\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\)}
\Output{\(i\)-path até \(p\) como uma sequência de pontos em \(\mathbb{R}^2\), desconsiderando \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}
 
\Function {ConsultaCaminho(\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\))} {

	\If {\(i = 0\)} {
		\Return {} \([s]\)
	}
	
	\(R \leftarrow \text{LocalizaPonto}(p, P_i, T_i, S_i)\) \\
	
	\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
		\(\mathbb{P} \leftarrow \text{ConsultaCaminho}(v, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\Return {} \(\mathbb{P} \oplus [v]\) \tcp{Adiciona \(v\) ao final do caminho \(\mathbb{P}\)}
	}
	
	\ElseIf {\(R\) corresponde a uma aresta \(e = \overline{u v}\) de \(P_i\)} {
		\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) (Veja \ref{eq:reflection_on_edge}) \\
		\(\mathbb{P} \leftarrow \text{ConsultaCaminho}(p', i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(q' \leftarrow\) último ponto de \(\mathbb{P}\) \\
		\(q \leftarrow\) ponto de interseção entre as retas que passam por \(\overline{q' p'}\) e \(e\) (Veja \ref{eq:intersection_on_edge}) \\
		\Return {} \(\mathbb{P} \oplus [q]\) \tcp{Adiciona \(q\) ao final do caminho \(\mathbb{P}\)}
	}
	
	\ElseIf {\(R\) corresponde a atravessar \(P_i\)} {
		\Return {} \(\text{ConsultaCaminho}(p, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
	}
}

\end{algorithm}

O Algoritmo~\algref{alg:consulta-caminho} permite calcular o~\(i\)-path até qualquer ponto~\(p \in \mathbb{R}^2\) de forma eficiente, podendo ser utilizado para obter o~\(k\)-path até~\(t\), que corresponde exatamente à solução do problema. O algoritmo recebe como entrada o ponto~\(p\), o ponto inicial~\(s\), o índice~\(i\), os polígonos~\(P_{\ell}\) para~\(\ell=1,\dots,i\) e suas respectivas regiões de primeiro contato~\(T_i\) e mapas de último passo~\(S_i\) e devolve o caminho. O algoritmo é recursivo e faz apenas uso da função \texttt{LocalizaPonto} que definiremos em breve.

Frequentemente nos interessamos apenas pelo último segmento do~\(i\)-path até~\(p\). Ainda, no caso em que um ponto pertence a uma região associada a um vértice de~\(P_i\), é possível determinar o último segmento diretamente, sem a necessidade de calcular o restante do caminho. Dessa forma, implementamos o Algoritmo~\algref{alg:consulta-ultimo-passo}, que, dado um ponto~\(p \in \mathbb{R}^2\) e um índice~\(1 \leq i \leq k\), retorna o ponto inicial do último segmento do~\(i\)-path até \(p\). O algoritmo recebe como dados de entrada os mesmos dados de entrada do Algoritmo~\algref{alg:consulta-caminho}.

\begin{algorithm}[!ht]
\alglabel{alg:consulta-ultimo-passo}
\caption{Consulta Último Passo}
\Input{\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\)}
\Output{Ponto que precede \(p\) no \(i\)-path até \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {ConsultaÚltimoPasso(\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\))} {

	\If {\(i = 0\)} {
		\Return {} \(s\)
	}

	\(R \leftarrow \text{LocalizaPonto}(p, P_i, T_i, S_i)\) \\

	\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
		\Return {} \(v\)
	}
	\ElseIf {\(R\) corresponde a uma aresta \(e = \overline{uv}\) de \(P_i\)} {
		\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) (Veja \ref{eq:reflection_on_edge}) \\
		\(q' \leftarrow \text{ConsultaÚltimoPasso}(p', i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(q \leftarrow\) ponto de interseção entre \(\overline{q' p'}\) e \(e\) (Veja \ref{eq:intersection_on_edge}) \\
		\Return {} \(q\)
	}
	\ElseIf {\(R\) corresponde a atravessar \(P_i\)} {
		\Return {} \(\text{ConsultaÚltimoPasso}(p, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
	}
}

\end{algorithm}

Esses dois algoritmos serão utilizados em todas as implementações discutidas a seguir. A diferença entre elas estará na implementação do algoritmo \texttt{LocalizaPonto} e na forma como calculamos as regiões de primeiro contato~\(T_i\) e os mapas de último passo~\(S_i\) para cada polígono~\(P_i\).

\subsection{Primeira Abordagem}

A alto nível, o algoritmo para resolver o TPP Convexo é o seguinte: para cada \(1 \le i \le k\), calculamos a região de primeiro contato~\(T_i\) de~\(P_i\) utilizando \(T_1, \dots, T_{i - 1}\) e \(S_1, \dots, S_{i - 1}\) através do Algoritmo~\algref{alg:first_contact_region}, depois calculamos o mapa de último passo~\(S_i\) de~\(P_i\) utilizando \(T_1, \dots, T_i\) e \(S_1, \dots, S_{i - 1}\) através do Algoritmo~\algref{alg:last_step_map}. Por fim, calculamos o~\(k\)-path até~\(t\) utilizando o Algoritmo~\algref{alg:consulta-caminho}. A seguir, vamos detalhar as implementações de cada um desses passos.

Primeiramente, para calcular a região de primeiro contato~\(T_i\) de um polígono~\(P_i\), precisamos determinar quais arestas de~\(P_i\) pertencem a~\(T_i\). Seja~\(e = \overline{u v}\) uma aresta de~\(P_i\), \(p\) um ponto qualquer dessa aresta e~\(q\) o ponto que precede~\(p\) no~\((i - 1)\)-path até~\(p\). Note que~\(e \in T_i\) se, e somente se, \(q\) está do lado externo de~\(e\). Esse teste vale para qualquer ponto na aresta \(e\), assim, escolhemos utilizar um vértice para potencialmente reutilizar esse resultado adiante. A Figura~\ref{fig:first_contact_region} ilustra como podemos usar essa ideia para determinar a região de primeiro contato de um polígono, realizando o teste para ambos os vértices de cada aresta do polígono, note que as arestas em verde tem o ponto que precede os vértices em seu lado externo enquanto as arestas em vermelho tem o ponto que precede os vértices no lado interno. Implementamos essa ideia no Algoritmo~\algref{alg:first_contact_region}, utilizando o vértice~\(u\) como o ponto~\(p\) para determinar se a aresta~\(e\) pertence a~\(T_i\).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.6\textwidth]{utpp-first_contact.png}
	\caption{Usamos o Algoritmo~\ref{alg:first_contact_region} para determinar a região de primeiro contato do polígono. Pintamos em verde as arestas que pertencem a \(T_i\) e em vermelho as que não pertencem.}
	\label{fig:first_contact_region}
\end{figure}

\begin{algorithm}[!ht]
\alglabel{alg:first_contact_region}
\caption{Região de Primeiro Contato}
\Input{\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1})\)}
\Output{Região de primeiro contato \(T_i\) de \(P_i\) como um conjunto de arestas de \(P_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {RegiãoDePrimeiroContato(\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1})\))} {

	\(T_i \leftarrow \emptyset\)
	
	\For {cada aresta \(e\) de \(P_i\)} {
	
		\(u \leftarrow\) vértice anterior de \(e\) \\
		\(v \leftarrow\) vértice posterior de \(e\) \\
	
		\(q \leftarrow \text{ConsultaÚltimoPasso}(u, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	
		\If {\((q - u) \times (v - u) < 0\)} {
			\(T_i \leftarrow T_i \cup e\)
		}
	}
	
	\Return {} \(T_i\)
}

\end{algorithm}

Uma vez que temos \(T_i\), podemos calcular o mapa de último passo~\(S_i\) de~\(P_i\), para tal, vamos primeiro retomar as condições de otimalidade local discutidas em~\cite[\textbf{Local Optimality Conditions.}]{tpp-dror2003}, que nos permitem determinar o mapa de último passo~\(S_i\) de um polígono~\(P_i\) a partir da região de primeiro contato~\(T_i\). Seja~\(v\) um vértice de um polígono qualquer~\(P\) com arestas incidentes~\(e^1\) e~\(e^2\) e suponha que desejamos visitar~\(P\) partindo de~\(q\) e terminando em~\(p\). Para que o caminho mínimo de~\(q\) até~\(p\) passe por~\(v\), é necessário que~\(p\) esteja dentro do cone definido por~\(v\) e por um par ordenado de raios que partem de~\(v\) determinados a partir de~\(e^1\) e~\(e^2\) nessa ordem. 

O raio associado a uma aresta~\(e\) incidente a~\(v\) será \(v - q\) se \(q\) está do lado interno de~\(e\) ou~\(q' - v\) onde~\(q'\) é a reflexão de~\(q\) em relação à reta perpendicular a~\(e\) que passa por~\(v\) caso contrário. Assim, concluimos a condição de otimalidade local para um vértice~\(v\) de~\(P\), no entanto, como todo \(i\)-path é único, temos que otimalidade local implica otimalidade global. Assim, para determinar o mapa de último passo~\(S_i\) de~\(P_i\), basta calcular os pares ordenados de raios associados a cada vértice de~\(P_i\) que tem uma aresta incidente pertencente a~\(T_i\). Implementamos essa ideia no Algoritmo~\algref{alg:last_step_map}, onde, para cada vértice~\(v\) de~\(P_i\) que tem uma aresta incidente pertencente a~\(T_i\), calculamos os raios associados a~\(v\) e associamos o par ordenado desses raios a~\(v\) em~\(S_i\).


\begin{algorithm}[!ht]
\alglabel{alg:last_step_map}
\caption{Mapa de Último Passo}

\Input{\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1})\)}
\Output{Mapa de último passo \(S_i\) de \(P_i\) como uma associação de pares ordenados de raios aos vértices das arestas de \(T_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\tcp{Função auxiliar para calcular o raio refletido na aresta \(e = \overline{uv}\) incidente a \(v\) onde \(q\) é o ponto que precede \(v\) no \((i - 1)\)-path até \(v\).}

\Function {Reflexão(\(q, v, e\))} {
	\If {\((u - v) \times (q - v) \ge 0\)} {
		\Return {} \(v - q\)
	}
	\Else {
		\(e_\perp \leftarrow\) vetor perpendicular a \(e\) que passa por \(v\) \\
		\(q' \leftarrow\) reflexão de \(q\) em relação à reta que contém \(e_\perp\) (Veja \ref{eq:reflection_on_edge})\\
		\Return {} \(q' - v\)
	}
}

\Function {MapaDeÚltimoPasso(\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1})\))} {

	\(S_i \leftarrow \emptyset\)

	\For{vértice \(v\) de \(P_i\) tal que existe uma aresta \(e\) em \(T_i\) incidente a \(v\)} {
		
		\(e^1 \leftarrow\) aresta anterior de \(v\) em \(P_i\) \\
		\(e^2 \leftarrow\) aresta posterior de \(v\) em \(P_i\) \\

		\(q \leftarrow \text{ConsultaÚltimoPasso}(v, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		
		\(r^1 \leftarrow \text{Reflexão}(q, v, e^1)\) \\
		\(r^2 \leftarrow \text{Reflexão}(q, v, e^2)\) \\

		Associa \((r^1, r^2)\) a \(v\) e adiciona à \(S_i\)
	}

	\Return {} \(S_i\)
}

\end{algorithm}

Uma vez que sabemos calcular~\(T_i\) e~\(S_i\), desejamos implementar o algoritmo \texttt{LocalizaPonto}, que localiza um ponto~\(p\) no mapa de último passo~\(S_i\). Na primeira abordagem, implementamos esse procedimento de forma direta, verificando inicialmente todas as regiões associadas a vértices, depois todas as regiões associadas a arestas e, caso o ponto não pertença a nenhuma dessas regiões, retornando a região de atravessar~\(P_i\). Para verificar se um ponto~\(p\) pertence a uma região associada a um vértice~\(v\) de~\(P_i\) com raios~\(r^1\) e~\(r^2\), primeiro determinamos se o ângulo de abertura entre~\(r^1\) e~\(r^2\) é menor ou maior que~\(180^\circ\). Se o ângulo for menor que~\(180^\circ\), então~\(p\) pertence à região associada a~\(v\) se o produto vetorial entre~\(r^1\) e~\(\overrightarrow{vp}\) for positivo \textbf{e} o produto vetorial entre~\(\overrightarrow{vp}\) e~\(r^2\) for negativo. Caso contrário,~\(p\) pertence à região associada a~\(v\) se o produto vetorial entre~\(r^1\) e~\(\overrightarrow{vp}\) for positivo \textbf{ou} o produto vetorial entre~\(\overrightarrow{vp}\) e~\(r^2\) for negativo. Essas situações são ilustradas na Figura~\ref{fig:point_in_cone}.

\begin{figure}[!ht]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.99\textwidth]{cone_check_small.png}
		\caption{Ângulo de abertura menor que \(180^\circ\).}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.99\textwidth]{cone_check_large.png}
		\caption{Ângulo de abertura maior que \(180^\circ\).}
	\end{subfigure}
	\caption{Verificação de pertinência de um ponto a uma região associada a um vértice em um mapa de último passo.}
	\label{fig:point_in_cone}
\end{figure}

Além disso, desejamos verificar se um ponto~\(p\) pertence a uma região associada a uma aresta~\(e\) de~\(P_i\). Para isso, consideramos que~\(u\) e~\(v\) são os vértices que definem a aresta~\(e\), em sentido anti-horário, e tomamos~\(r^1\) como o segundo raio associado ao vértice~\(u\) e~\(r^2\) como o primeiro raio associado ao vértice~\(v\) em~\(S_i\). Então,~\(p\) pertence à região associada a~\(e\) se estiver do lado externo da aresta~\(e\) e entre os raios~\(r^1\) e~\(r^2\), como ilustrado na Figura~\ref{fig:point_in_edge_region}.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{edge_region_check.png}
	\caption{Verificando se um ponto pertence a uma região associada a uma aresta.}
	\label{fig:point_in_edge_region}
\end{figure}

Uma vez que conseguimos verificar se um ponto pertence a uma região associada a um vértice ou a uma aresta de~\(P_i\), podemos implementar o algoritmo \texttt{LocalizaPonto} de forma direta, como mostrado no Algoritmo~\algref{alg:locate_point_first_approach}. Realizamos dois laços: o primeiro verifica todas as regiões associadas a vértices de~\(P_i\) pertencentes a~\(T_i\) e o segundo verifica todas as regiões associadas a arestas de~\(P_i\) pertencentes a~\(T_i\). Caso o ponto~\(p\) não pertença a nenhuma dessas regiões, retornamos a região de atravessar~\(P_i\).

\begin{algorithm}[!ht]
\alglabel{alg:locate_point_first_approach}
\caption{Localiza Ponto — Primeira Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {LocalizaPonto(\(p, P_i, T_i, S_i\))} {

	\For {vértice \(v\) de \(P_i\) tal que existe uma aresta \(e\) em \(T_i\) incidente a \(v\)} {

		\((r^1, r^2) \leftarrow\) raios associados a \(v\) em \(S_i\) \\

		\If {\(r^1 \times r^2 \geq 0\)} {
			\If {\((r^1 \times (p - v) > 0) \land (r^2 \times (p - v) < 0)\)} {
				\Return {} região associada a \(v\)
			}
		}
		\Else {
			\If {\((r^1 \times (p - v) > 0) \lor (r^2 \times (p - v) < 0)\)} {
				\Return {} região associada a \(v\)
			}
		}
	}

	\For {aresta \(e = \overrightarrow{u v}\) de \(P_i\) pertencente a \(T_i\)} {
		\(r^1 \leftarrow\) segundo raio associado a \(u\) em \(S_i\) \\
		\(r^2 \leftarrow\) primeiro raio associado a \(v\) em \(S_i\) \\

		\If {\((r^1 \times (p - u) > 0) \land (r^2 \times (p - v) < 0) \land ((p - u) \times (v - u) < 0)\)} {
			\Return {} região associada a \(e\)
		}
	}

	\Return {} região de atravessar \(P_i\)
}

\end{algorithm}

Finalmente, uma vez que sabemos calcular~\(T_i\),~\(S_i\) e localizar um ponto~\(p\) em~\(S_i\), podemos implementar o algoritmo completo para resolver o TPP, conforme mostrado no Algoritmo~\algref{alg:tpp_complete-1-2}. Esse algoritmo itera sobre todos os polígonos~\(P_1, \dots, P_k\), calculando~\(T_i\) e~\(S_i\) para cada polígono por meio dos algoritmos discutidos anteriormente. Após calcular todas as regiões de primeiro contato e mapas de último passo, o algoritmo retorna o~\(k\)-path até o ponto~\(t\) utilizando o Algoritmo~\algref{alg:consulta-caminho}. Esse algoritmo também será utilizado na segunda abordagem, na qual apenas o algoritmo~\texttt{LocalizaPonto} será modificado.

\begin{algorithm}[!ht]
\alglabel{alg:tpp_complete-1-2}
\caption{TPP Irrestrito — Implementação Completa}
\Input{Pontos \(s\) e \(t\), sequência de polígonos convexos disjuntos (\(P_1, \dots, P_k\))}

\Output{\(k\)-path até \(t\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {TPP\_Irrestrito(\(s, t, (P_1, \dots, P_k)\))} {

	\((T_1, \dots, T_k) \leftarrow \emptyset\) \\
	\((S_1, \dots, S_k) \leftarrow \emptyset\) \\

	\For {\(i \leftarrow 1\) até \(k\)} {
		
		\(T_i \leftarrow \text{RegiãoDePrimeiroContato}(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(S_i \leftarrow \text{MapaDeÚltimoPasso}(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1}))\)
	}

	\Return {} \(\text{ConsultaCaminho}(t, k, s, (P_1, \dots, P_k), (T_1, \dots, T_k), (S_1, \dots, S_k))\)

}

\end{algorithm}

\subsection{Segunda Abordagem}

Na segunda abordagem, alteramos apenas a implementação do algoritmo \texttt{LocalizaPonto}, utilizando uma estratégia de busca binária para localizar o ponto~\(p\) no mapa de último passo~\(S_i\). Definimos~\(u^1, \dots, u^m\) como os vértices de~\(P_i\) que pertencem a~\(T_i\), ordenados em sentido anti-horário. A ideia central do algoritmo é utilizar \emph{arestas fictícias} que conectam dois vértices~\(u^i\) e~\(u^j\), formando uma nova região~\(R\). Essa região possui a propriedade de que é possível verificar se~\(p\) pertence a~\(R\) em tempo~\(O(1)\), e~\(p\) está em~\(R\) se e somente se está em alguma região de vértice ou de aresta entre~\(u^i\) e~\(u^j\). Dessa forma, podemos empregar uma estratégia de busca binária para localizar~\(p\) em~\(S_i\).

Assumimos que o ponto~\(p\) não está no interior do polígono~\(P_i\). Esse fato é garantido pela hipótese de que os polígonos são disjuntos, incluindo os pontos~\(s\) e~\(t\). Caso seja necessário lidar com situações em que~\(p\) possa estar no interior de~\(P_i\), o algoritmo pode ser iniciado com uma verificação de pertinência em tempo~\(O(\log\abs{P_i})\). Essa verificação, no entanto, não será discutida aqui, pois não é o foco deste trabalho.

\begin{figure}[!ht]
	\centering

	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_idea-1.png}
		\caption{Visão geral do polígono.}
	\end{subfigure}
	\hspace{0.5cm} %\hfill
	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_idea-2.png}
		\caption{Verificando região de travessia.}
	\end{subfigure}

	\medskip

	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_idea-3.png}
		\caption{Verificando regiões de vértice adjacentes à região de travessia.}
	\end{subfigure}
	\hspace{0.5cm} %\hfill
	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_idea-4.png}
		\caption{Particionando o restante do plano em duas regiões de aresta e uma de vértice.}
	\end{subfigure}

	\caption{Ilustração dos três passos do algoritmo de busca binária para localizar um ponto em um mapa de último passo.}
	\label{fig:binary_search_idea}

\end{figure}

A Figura~\ref{fig:binary_search_idea} será utilizada para descrever cada etapa do algoritmo. O primeiro quadro apresenta um polígono~\(P_i\) com 8 vértices, dos quais 5 pertencem a~\(T_i\), denotados por~\(u^1, \dots, u^5\). As regiões de vértice estão destacadas em vermelho, as regiões de aresta em verde e a região de travessia em azul. O objetivo é localizar um ponto nesse mapa de último passo. O algoritmo possui dois passos iniciais e, em seguida, inicia a busca binária, conforme descrito a seguir:

\begin{blockQuote}

\textbf{\large Algoritmo para localizar um ponto \(p\) em \(S_i\):}

\begin{description}

	\item[Passo 1.] Verificar se~\(p\) está na região de travessia de~\(P_i\) (Quadro 2): criamos uma aresta fictícia entre~\(u^5\) e~\(u^1\), gerando uma região~\(R\) que contém exatamente a região de travessia e parte de~\(P_i\). A verificação se~\(p\) pertence a~\(R\) é feita utilizando a mesma estratégia do Algoritmo~\algref{alg:locate_point_first_approach}, considerando~\(u^5\) e~\(u^1\) como os vértices que definem a aresta fictícia e o segundo raio de~\(u^5\) e o primeiro raio de~\(u^1\) como os raios que delimitam~\(R\). Caso~\(p\) pertença a~\(R\), retornamos a região de travessia.
	
	\item[Passo 2.] Verificar se~\(p\) está em alguma região de vértice de~\(u^1\) ou~\(u^5\) (Quadro 3): utilizamos a mesma verificação do Algoritmo~\algref{alg:locate_point_first_approach}. Se~\(p\) pertencer a alguma dessas regiões, retornamos a região correspondente.
	
	\item[Passo 3.] Busca binária (Quadro 4): sabendo que~\(p\) não está nem na região de travessia nem nas regiões de vértice de~\(u^1\) ou~\(u^5\), iniciamos a busca binária entre os vértices~\(u^1\) e~\(u^5\). Selecionamos~\(u^3\) como vértice intermediário e verificamos se~\(p\) pertence à região de vértice de~\(u^3\). Em caso afirmativo, retornamos essa região.

	Caso contrário, criamos duas arestas fictícias, uma entre~\(u^1\) e~\(u^3\) e outra entre~\(u^3\) e~\(u^5\), gerando as regiões~\(R_1\) (em roxo) e~\(R_2\) (em laranja). Verificamos se~\(p\) pertence a~\(R_1\); se sim, repetimos esse passo recursivamente considerando apenas os vértices entre~\(u^1\) e~\(u^3\). Caso contrário, sabemos que~\(p\) pertence a~\(R_2\) e repetimos esse passo considerando apenas os vértices entre~\(u^3\) e~\(u^5\). Esse passo é repetido até que~\(p\) pertença a uma região de vértice ou restem apenas dois vértices em que concluímos que~\(p\) está na região de aresta entre esses dois vértices.

\end{description}

\end{blockQuote}

A maior parte desse algoritmo é direta de implementar, exceto pela verificação se~\(p\) pertence à região~\(R_1\). Isso ocorre porque essa região pode assumir formas que não são cobertas pela verificação original do Algoritmo~\algref{alg:locate_point_first_approach}. Em particular, ao criar uma aresta fictícia entre dois vértices~\(u\) e~\(v\) com raios~\(r^1\) e~\(r^2\), pode ocorrer que esses raios formem um ângulo maior que~\(180^\circ\) ou estejam em lados distintos da aresta fictícia, como ilustrado na Figura~\ref{fig:binary_search_cases}.

\begin{figure}[!ht]
	\centering

	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_cases-1.png}
		\caption{Ambos raios no lado negativo.}
	\end{subfigure}
	\hspace{0.5cm} %\hfill
	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_cases-2.png}
		\caption{Ambos raios no lado positivo.}
	\end{subfigure}

	\medskip

	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_cases-3.png}
		\caption{Raios em lados diferentes.}
	\end{subfigure}
	\hspace{0.5cm} %\hfill
	\begin{subfigure}[b]{0.40\textwidth}
		\centering
		\includegraphics[width=\textwidth]{binary_search_cases-4.png}
		\caption{Raios em lados diferentes.}
	\end{subfigure}

	\caption{Ilustração dos 4 casos possíveis ao verificar se um ponto pertence à região de uma aresta fictícia entre dois vértices.}
	\label{fig:binary_search_cases}

\end{figure}

Desejamos determinar se um ponto~\(p\) pertence à região de aresta fictícia entre os vértices~\(u\) e~\(v\), delimitada pelos raios~\(r^1\) partindo de~\(u\) e~\(r^2\) partindo de~\(v\). Os casos são definidos pelo lado em que~\(r^1\) e~\(r^2\) se encontram em relação à direção~\(d = v - u\), e tratamos cada situação separadamente:

\begin{enumerate}[label=(\alph*)]

	\item \(d \times r^1 < 0 \land d \times r^2 < 0\): Verificamos se~\(p\) está entre os raios~\(r^1\) e~\(r^2\) e do lado externo da aresta~\(\overline{u v}\).

	\item \(d \times r^1 > 0 \land d \times r^2 > 0\): Esse caso é o complemento do anterior. Verificamos se~\(p\) não está entre os raios~\(r^1\) e~\(r^2\) e se está do lado interno da aresta~\(\overline{u v}\).

	\item \(d \times r^1 < 0 \land d \times r^2 > 0\): Inicialmente verificamos de que lado da reta que contém~\(\overline{u v}\) o ponto~\(p\) se encontra. Se~\(p\) estiver do lado externo, verificamos se está do lado negativo de~\(r^2\); caso contrário, verificamos se está do lado positivo de~\(r^1\).

	\item \(d \times r^1 > 0 \land d \times r^2 < 0\): Procedemos de forma análoga ao caso anterior, invertendo os testes correspondentes aos raios.

\end{enumerate}

Com essas verificações, podemos implementar o algoritmo \texttt{LocalizaPonto} utilizando a estratégia de busca binária, conforme apresentado no Algoritmo~\algref{alg:locate_point_second_approach}. Nesse algoritmo, implementamos a função auxiliar \texttt{VerificaAresta}, responsável por verificar se~\(p\) pertence à região de uma aresta fictícia entre dois vértices~\(u\) e~\(v\), de acordo com os casos discutidos anteriormente. A verificação se~\(p\) pertence à região de vértice de um dado vértice~\(u^{mid}\) é abstraída, pois é idêntica àquela utilizada no Algoritmo~\algref{alg:locate_point_first_approach}.

A principal vantagem dessa abordagem é que a busca binária reduz o número de verificações para localizar~\(p\) em~\(S_i\) de~\(O\abs{T_i}\) para~\(O(\log\abs{T_i})\), o que pode representar uma melhoria significativa quando~\(P_i\) possui muitos vértices em~\(T_i\). Analisaremos o impacto dessa modificação com mais detalhes na análise de complexidade.

\begin{algorithm}[!ht]
\alglabel{alg:locate_point_second_approach}
\caption{Localiza Ponto — Segunda Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {LocalizaPonto(\(p, P_i, T_i, S_i\))} {

	\Function {VerificaAresta(\(u, v\))} {
		\(r^1 \leftarrow\) segundo raio associado a \(u\) em \(S_i\) \\
		\(r^2 \leftarrow\) primeiro raio associado a \(v\) em \(S_i\) \\

		\(d \leftarrow v - u\) \\

		\If {\(d \times r^1 < 0 \land d \times r^2 < 0\)} {
			\Return {} \(r^1 \times (p - u) > 0 \land r^2 \times (p - v) < 0 \land (p - u) \times (v - u) < 0\)
		}
		\ElseIf {\(d \times r^1 > 0 \land d \times r^2 > 0\)} {
			\Return {} \(r^1 \times (p - u) \leq 0 \land r^2 \times (p - v) \geq 0 \land (p - u) \times (v - u) \geq 0\)
		}
		\ElseIf {\(d \times r^1 < 0 \land d \times r^2 > 0\)} {
			\If {\((p - u) \times (v - u) < 0\)} {
				\Return {} \(r^2 \times (p - v) < 0\)
			}
			\Else {
				\Return {} \(r^1 \times (p - u) > 0\)
			}
		}
		\Else {
			\If {\((p - u) \times (v - u) < 0\)} {
				\Return {} \(r^1 \times (p - u) > 0\)
			}
			\Else {
				\Return {} \(r^2 \times (p - v) < 0\)
			}
		}
	}

	\(u^1, \dots, u^m \leftarrow\) vértices de \(P_i\) em \(T_i\), ordenados em sentido anti-horário \\

	\If {VerificaAresta(\(u^m, u^1\))} {
		\Return {} região de atravessar \(P_i\)
	}
	\If {\(p\) está na região de vértice de \(u^1\)} {
		\Return {} região associada a \(u^1\)
	}

	\If {\(p\) está na região de vértice de \(u^m\)} {
		\Return {} região associada a \(u^m\)
	}

	\(l \leftarrow 1\) \\
	\(r \leftarrow m\)

	\While {\(l + 1 \ne r\)} {

		\(mid \leftarrow \floor{(l + r) / 2}\)

		\If {\(p\) está na região de vértice de \(u^{mid}\)} {
			\Return {} região associada a \(u^{mid}\)
		}

		\If {VerificaAresta(\(u^{l}, u^{mid}\))} {
			\(r \leftarrow mid\)
		}
		\Else {
			\(l \leftarrow mid\)
		}
	}

	\Return {} região associada a aresta \(\overline{u^{l} u^{r}}\)
}

\end{algorithm}
\subsection{Terceira Abordagem}

Antes de discutirmos a terceira abordagem, apresentamos a motivação para essa nova implementação do algoritmo \texttt{LocalizaPonto}. Considere o caso de um único polígono~\(P_1\) com um grande número de vértices, por exemplo, um milhão. Pela segunda abordagem, calculamos~\(T_1\), em seguida~\(S_1\) e, finalmente, realizamos uma única consulta ao mapa de último passo~\(S_1\) para localizar o ponto~\(t\). No entanto, essa consulta utiliza no máximo cerca de 20 regiões de vértice de~\(P_1\) para localizar~\(t\) em~\(S_1\). Assim, acabamos calculando aproximadamente 999\,980 regiões de vértice que nunca são utilizadas. Diante disso, na terceira abordagem buscamos empregar uma estratégia de memoização, de modo a calcular apenas as regiões de vértice de~\(P_i\) que são efetivamente necessárias para localizar os pontos consultados no mapa de último passo~\(S_i\).

O primeiro problema a ser resolvido é determinar se uma dada aresta~\(e = \overline{u v}\) de~\(P_i\) pertence a~\(T_i\) realizando apenas uma única chamada ao algoritmo \texttt{ConsultaÚltimoPasso}. Para isso, reutilizamos a ideia do Algoritmo~\algref{alg:first_contact_region}, que originalmente calculava~\(T_i\) por completo. Agora, ao invés de verificar todas as arestas de~\(P_i\), testamos apenas a aresta~\(e\), calculando o último passo~\(q\) do \((i - 1)\)-path até o vértice~\(u\) da aresta~\(e\) e afirmamos que~\(e\) está em~\(T_i\) se e somente se~\(q\) está do lado externo de~\(e\). 

Em seguida, precisamos calcular os raios associados a um vértice~\(v\) de~\(P_i\) em~\(S_i\), novamente realizando apenas uma única chamada ao algoritmo \texttt{ConsultaÚltimoPasso}. Para isso, adaptamos a ideia do Algoritmo~\algref{alg:last_step_map}, que originalmente calculava~\(S_i\) por completo. Agora, em vez de calcular os raios para todos os vértices de~\(P_i\), calculamos apenas os raios associados ao vértice~\(v\). Contudo, esse algoritmo pressupõe que sabemos quais arestas de~\(P_i\) pertencem a~\(T_i\), de modo que precisamos determinar se as arestas incidentes em~\(v\) pertencem a~\(T_i\) sem realizar chamadas adicionais ao algoritmo \texttt{ConsultaÚltimoPasso}.

Para resolver isso, retomamos a caracterização de que, dada uma aresta~\(e\) de~\(P_i\), um ponto~\(p\) em~\(e\) e o último passo~\(q\) do~\((i-1)\)-path até~\(p\), temos que~\(e \in T_i\) se e somente se~\(q\) está do lado externo de~\(e\). Assim, seja~\(v\) um vértice de~\(P_i\) e sejam~\(e^1\) e~\(e^2\) as arestas incidentes em~\(v\). Calculamos o último passo~\(q\) do~\((i-1)\)-path até~\(v\) e verificamos se o ponto~\(q\) está do lado externo de~\(e^1\) e de~\(e^2\), determinando, assim, se essas arestas pertencem a~\(T_i\) respectivamente. Com essa informação, podemos adaptar diretamente o Algoritmo~\algref{alg:last_step_map} para calcular apenas os raios associados a~\(v\) em~\(S_i\).

Uma observação importante é que, como não conhecemos previamente~\(T_i\), pode ocorrer de tentarmos calcular os raios associados a um vértice~\(v\) de~\(P_i\) em~\(S_i\) sem que nenhuma das arestas incidentes em~\(v\) pertença a~\(T_i\). Nesse caso, o algoritmo não precisa de qualquer modificação, pois seu comportamento natural é retornar dois raios com a mesma direção do último segmento do~\((i-1)\)-path que chega a~\(v\). Isso corresponde a uma região vazia em~\(S_i\), o que é consistente com o fato de que~\(v\) não pertence a~\(T_i\).

Com essas ideias, podemos finalmente descrever a implementação do algoritmo \texttt{LocalizaPonto} utilizando a estratégia de memoização. Reutilizamos a busca binária da segunda abordagem, mas agora os passos iniciais são simplificados, pois a verificação da região de travessia é postergada para o final do algoritmo. O procedimento segue da seguinte forma:

\begin{blockQuote}

\textbf{\large Algoritmo para localizar um ponto \(p\) em \(S_i\):}

\begin{description}

	\item[Passo 1.] Sejam~\(v^1, \dots, v^m\) os vértices de~\(P_i\) ordenados em sentido anti-horário. Calculamos os raios associados a~\(v^1\) em~\(S_i\) e verificamos se~\(p\) pertence à região de vértice de~\(v^1\). Em caso afirmativo, retornamos essa região.
	
	\item[Passo 2.] Seja~\(v' = v^{\lfloor m / 2 \rfloor}\). Calculamos os raios associados a~\(v'\) em~\(S_i\) e verificamos se~\(p\) pertence à sua região de vértice. Se isso ocorrer, retornamos essa região.

	Caso contrário, criamos as arestas fictícias entre~\(u\) e~\(v'\) e entre~\(v'\) e~\(v^m\), gerando as regiões~\(R_1\) e~\(R_2\). Verificamos se~\(p\) pertence a~\(R_1\) utilizando o mesmo procedimento descrito no Algoritmo~\algref{alg:locate_point_second_approach}. Se sim, repetimos esse passo considerando apenas os vértices entre~\(u\) e~\(v'\); caso contrário, repetimos esse passo considerando apenas os vértices entre~\(v'\) e~\(v^m\).

	Assim seguimos até que encontremos um vértice~\(v^k\) tal que~\(p\) pertença à sua região de vértice ou restem apenas dois vértices~\(v^l\) e~\(v^r\). Nesse último caso, sabemos que~\(p\) deve estar na região de aresta entre esses vértices.

	\item[Passo 3.] Caso~\(p\) não tenha sido localizado em uma região de vértice, concluímos que ele está na região de aresta entre os dois últimos vértices~\(v^l\) e~\(v^r\). Para finalizar, com uma única consulta, determinamos se essa aresta pertence a~\(T_i\). Se pertencer, retornamos a região de aresta correspondente; caso contrário, retornamos a região de travessia de~\(P_i\).

\end{description}


\end{blockQuote}

Dessa forma, concluímos a descrição da terceira abordagem para a implementação do algoritmo \texttt{LocalizaPonto} utilizando memoização. Optamos por não apresentar o pseudocódigo completo dessa abordagem, pois ele seria muito semelhante ao Algoritmo~\algref{alg:locate_point_second_approach}, diferindo apenas pelas modificações discutidas acima.
\subsection{Análise de Complexidade}

Começamos analisando a complexidade da primeira abordagem. Seja~\(\abs{P_i}\) o número de vértices do polígono~\(P_i\) e~\(\abs{T_i}\) o número de arestas em~\(T_i\). Seja ainda~\(k\) o número total de polígonos na sequência~\(P_1, \dots, P_k\) e~\(n\) o número total de vértices em todos os polígonos, isto é,

\[
	n = \sum_{i = 1}^{k} \abs{P_i}.
\]

\begin{description}

	\item[LocalizaPonto \algref{alg:locate_point_first_approach}:] A complexidade desse algoritmo é~\(O(\abs{T_i})\), pois, no pior caso, é necessário verificar todas as regiões de vértice e de aresta associadas a~\(T_i\) para localizar o ponto~\(p\).

	\item[ConsultaÚltimoPasso \algref{alg:consulta-ultimo-passo} e ConsultaCaminho \algref{alg:consulta-caminho}:] Ambos os algoritmos iniciam com uma chamada ao algoritmo \texttt{LocalizaPonto}. O pior caso ocorre quando o ponto~\(p\) pertence à região de travessia de~\(P_i\) ou a uma região de aresta, o que exige uma nova consulta ao mapa de último passo~\(S_{i-1}\). Assim, no pior caso, são feitas~\(i\) chamadas ao algoritmo \texttt{LocalizaPonto}, resultando em uma complexidade total de:
	
	\[
		O\!\left(\sum_{j = 1}^{i} \abs{T_j}\right).
	\]

	\item[RegiãoDePrimeiroContato \algref{alg:first_contact_region} e MapaDeÚltimoPasso \algref{alg:last_step_map}:] Ambos os algoritmos realizam uma única passagem pelos vértices de~\(P_i\), fazendo uma consulta para cada vértice. Dessa forma, a complexidade desses algoritmos é:

	\[
		O\!\left(\abs{P_i} \sum_{j = 1}^{i} \abs{T_j}\right).
	\]

	\item[TPP completo \algref{alg:tpp_complete-1-2}:] O algoritmo executa uma chamada para calcular~\(T_i\) e~\(S_i\) para cada~\(i = 1, \dots, k\), e ao final realiza uma chamada para consultar o caminho até o ponto~\(t\). Assim, a complexidade total do algoritmo TPP é dada por:

	\begin{align*}
		O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{T_j} + \sum_{j = 1}^{k} \abs{T_j}\right)
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{P_j} + \sum_{j = 1}^{k} \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \cdot n\right) \\
		&= O(n^2).
	\end{align*}


\end{description}


Assim, concluímos que a complexidade total do algoritmo TPP utilizando a primeira abordagem é~\(O(n^2)\). A seguir, analisamos a complexidade da segunda abordagem.

\begin{description}

	\item[LocalizaPonto \algref{alg:locate_point_second_approach}:] A complexidade desse algoritmo é~\(O(\log \abs{T_i})\), correspondente ao pior caso da busca binária utilizada para localizar o ponto~\(p\) em~\(S_i\).
	
	\item[ConsultaÚltimoPasso \algref{alg:consulta-ultimo-passo} e ConsultaCaminho \algref{alg:consulta-caminho}:] De forma análoga ao caso anterior, o pior caso envolve~\(i\) chamadas ao algoritmo \texttt{LocalizaPonto}, resultando na complexidade:
	
	\[
		O\!\left(\sum_{j = 1}^{i} \log \abs{T_j}\right).
	\]

	\item[RegiãoDePrimeiroContato \algref{alg:first_contact_region} e MapaDeÚltimoPasso \algref{alg:last_step_map}:] Cada um desses algoritmos itera sobre os vértices de~\(P_i\) e realiza uma consulta para cada vértice. Portanto, a complexidade é:
	
	\[
		O\!\left(\abs{P_i} \sum_{j = 1}^{i} \log \abs{T_j}\right).
	\]

	\item[TPP completo \algref{alg:tpp_complete-1-2}:] O custo total do algoritmo é:
	
	\begin{align*}
		O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{T_j} + \sum_{j = 1}^{k} \log \abs{T_j}\right)
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}\right) \\
		&= O\!\left(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log \abs{P_j}\right) \\
		&= O\!\left(n \sum_{j = 1}^{k} \log \abs{P_j}\right).
	\end{align*}

	Observando que a soma~\(\sum_{j = 1}^{k} \log \abs{P_j}\) é maximizada quando todos os polígonos possuem o mesmo número de vértices, isto é, quando~\(\abs{P_j} = n/k\) para todo~\(j\), obtemos que a complexidade final do algoritmo TPP usando a segunda abordagem é:

	\[
		O\!\left(nk \log (n/k)\right).
	\]

\end{description}

Dessa forma, concluimos que a complexidade final do algoritmo TPP utilizando a segunda abordagem é~\(O(nk \log (n/k))\). Essa complexidade coincide exatamente com a apresentada por Dror et al. (2003)~\cite{tpp-dror2003}, o que indica que nossa implementação atinge a mesma eficiência assintótica da proposta original.

Por fim, resta analisar a complexidade da terceira abordagem. Essa análise é mais delicada, pois a complexidade do algoritmo \texttt{LocalizaPonto} passa a depender fortemente da instância específica, em particular da distribuição dos vértices nos polígonos e das consultas efetivamente realizadas ao mapa de último passo. Ainda assim, é imediato observar que a terceira abordagem nunca será pior do que a segunda, uma vez que, no pior caso, todas as regiões de vértice em~\(T_i\) serão calculadas, recuperando exatamente o comportamento da segunda abordagem. Assim, concluímos que a complexidade da terceira abordagem é~\(O(nk \log (n/k))\) no pior caso, podendo ser significativamente melhor em instâncias favoráveis, dependendo do padrão das consultas realizadas.

%\
%\newpage

%\printbibliography

%\newpage

\bibliographystyle{plain}
\bibliography{referencias}

\end{document}
