
\documentclass[11pt]{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

% make conditions/keyword arguments use text mode
\renewcommand{\algorithmcfname}{Algoritmo}

\SetKwInOut{Input}{Entrada}
\SetKwInOut{Output}{Saída}
\SetKwIF{If}{ElseIf}{Else}{se}{:}{senão se}{senão}{end}
\SetKwFor{For}{para cada}{:}{end}
\SetKwRepeat{Do}{do}{enquanto}

\SetKwProg{Function}{define}{:}{}
\SetKw{Return}{retorna}
\SetProgSty{upshape} % tell it not to italicize
\renewcommand{\ProgSty}[1]{\textnormal{#1}\unskip} % enforce upright text


\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{#1}%
}

\newcommand{\algref}[1]{\ref{#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
% \usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}
\usepackage{csquotes}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{cleveref}
\usepackage{desclist}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blank}{}{} % Blank enviroment for folding sections in editors

\newenvironment{blockQuote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}
\DeclarePairedDelimiter{\anglebrackets}{\langle}{\rangle}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

% Footnote spacing
\setlength{\skip\footins}{0.5cm}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}


\title{\textbf{O Problema de Visita de Polígonos}\thanks{Esse trabalho foi parcialmente apoiado pela agência FAPESP (processo 2025/13861-1).}}

\author{
	Gabriel F. Ushijima\thanks{Instituto de Matemática e Estatística, Universidade de São Paulo, Rua do Matão, 1010, Cidade Universitária,
05508-090, São Paulo, SP, Brazil (e-mail: gabriel\_ushijima@ime.usp.br, egbirgin@ime.usp.br).\vspace{0.5cm}}
	\and
	\(\text{Ernesto G. Birgin}^\dagger\)
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}

Este artigo apresenta diferentes implementações de algoritmos para o Problema de Visita de Polígonos (Touring Polygons Problem – TPP), que consiste em encontrar um caminho de comprimento mínimo que visita uma sequência de polígonos no plano. Em sua forma geral, o problema é NP-difícil. Por esse motivo, inicialmente consideramos uma versão simplificada em que os polígonos são convexos e não se sobrepõem, para a qual apresentamos um algoritmo exato baseado em mapas de último passo. Em seguida, discutimos heurísticas para o caso geral, utilizando técnicas de programação inteira mista. Por fim, realizamos experimentos computacionais para avaliar o desempenho dos algoritmos propostos em instâncias de diferentes tamanhos e características, comparando-os com solvers comerciais. Os resultados indicam que as abordagens desenvolvidas são eficazes em uma ampla variedade de cenários práticos.

\vspace{10pt}

\noindent \textbf{Palavras-chave:} Problema de visita de polígonos, otimização geométrica, complexidade, experimentos numéricos.
\end{abstract}

\section{Introdução}

O Problema de Visita de Polígonos (Touring Polygons Problem - TPP), introduzido por Dror et al. (2003) \cite{tpp-dror2003}, é um problema de otimização geométrica que consiste em determinar um caminho de comprimento mínimo que visita uma sequência de polígonos no plano. Esse tipo de problema surge naturalmente em aplicações de roteirização e planejamento de trajetórias, especialmente no contexto de veículos autônomos, nos quais é necessário garantir a visita eficiente a regiões específicas do espaço, como em tarefas de inspeção automatizada de armazéns \cite{jianxian2023, karl2009}. Podemos pensar nesse problema como um caso específico do Problema do Caixeiro Viajante com Regiões (Traveling Salesman Problem with Neighborhoods - TSPN) \cite{tspn-arkin2005}, no qual o objetivo é encontrar um caminho de comprimento mínimo que visita um conjunto de regiões arbitrárias no plano, na medida que essas regiões são representadas por polígonos e a ordem de visita é pré-definida.

Dentre as diversas variações do problema, consideramos inicialmente uma versão simplificada em que os polígonos são convexos e não se sobrepõem. Para esse caso, apresentamos três abordagens distintas. A primeira é uma implementação direta das ideias descritas por Dror et al. (2003) \cite{tpp-dror2003}, baseada em mapas de último passo. A segunda abordagem melhora a eficiência da primeira ao empregar uma estratégia de busca binária para a localização de pontos nesses mapas. A terceira abordagem utiliza uma técnica de memoização, com o objetivo de evitar cálculos redundantes e reduzir o custo computacional. Finalmente, mostramos que a primeira abordagem tem complexidade \(O(n ^ 2)\) e as outras duas \(O(n k \log (n / k))\), onde \(n\) é o total de vértices de todos os polígonos e \(k\) é o número de polígonos.

Em seguida, discutimos heurísticas para o caso geral do TPP, no qual os polígonos podem ser côncavos. Baseamo-nos principalmente na ideia de particionar polígonos côncavos em subconjuntos convexos e aplicar, sobre eles, as soluções desenvolvidas para o caso convexo. Além disso, exploramos técnicas de programação inteira mista para modelar o problema e empregar solvers comerciais na obtenção de soluções aproximadas, como o \href{https://www.gurobi.com}{Gurobi}. Por fim, comparamos os resultados obtidos por essas abordagens com aqueles produzidos pelas implementações propostas neste trabalho.

\section{O Problema de Visita de Polígonos Convexos}

Inicialmente, consideramos o TPP na sua versão mais simples, no qual os polígonos são convexos e não se sobrepõem, chamado de TPP Irrestrito. Usamos tanto a formulação, quanto solução apresentadas por Dror et al. (2003) \cite{tpp-dror2003} como base para nossas implementações. Para nossos propósitos, definimos o problema da seguinte forma:

\begin{blockQuote}

	{\large \textbf{Problema 1: TPP Irrestrito}}

	\noindent Dado um ponto inicial \(s \in \mathbb{R} ^ 2\), um ponto final \(t \in \mathbb{R} ^ 2\) e uma sequência de polígonos convexos e disjuntos \(P_1, \dots, P_k\) dados por sequências de vértices ordenados em sentido anti-horário. Encontre um caminho \(\pi\) de comprimento mínimo que se inicia em \(s\), termina em \(t\) existem pontos \(p_1, \dots, p_k\) tais que \(p_i \in P_i\) para todo \(i = 1, 2, \dots, k\), e o caminho \(\pi\) passa por esses pontos nessa mesma ordem.

\end{blockQuote}

Todas as implementações a seguir tem como base as definições e propriedades apresentadas por Dror et al. (2003) \cite{tpp-dror2003}, assumimos que o leitor tem familiaridade com o conteúdo desse artigo. A seguir, retomamos as definições principais que serão utilizadas.

\begin{itemize}

	\item \textbf{Caminho Ótimo} (\(i\)-path): Um \(i\)-path até um ponto \(p\) é um caminho de comprimento mínimo que se inicia em \(s\), termina em \(p\) e visita os polígonos \(P_1, P_2, \dots, P_i\) em ordem. É fácil notar que qualquer \(i\)-path deve ser a união de segmentos de reta, assim, tratamos caminhos como sequências ordenadas de pontos em \(\mathbb{R}^2\).
	
	\item \textbf{Região de Primeiro Contato} (\(T_i\)): Denotamos por \(T_i\) a região de primeiro contato de um polígono \(P_i\), que é o conjunto de pontos \(p\) em seu perímetro tais que o último segmento do \((i - 1)\)-path até \(p\) intersecta \(P_i\) exclusivamente nesse ponto. Intuitivamente, \(T_i\) representa os pontos no perímetro de \(P_i\) onde o último segmento do \((i - 1)\)-path não atravessa o interior de \(P_i\).
	
	\item \textbf{Mapa de Último Passo} (\(S_i\)): Denotamos por \(S_i\) o mapa de último passo de um polígono \(P_i\), que é uma partição do plano em um número finito de regiões tais que, dois pontos em \(\mathbb{R} ^ 2\) pertence à mesma região se e somente se o último segmento do \(i\)-path até esses pontos possui a mesma origem: um vértice de \(P_i\), uma aresta de \(P_i\), ou atravessa o interior de \(P_i\).

\end{itemize}


Como demonstrado em \cite[\textbf{Lemma 3}]{tpp-dror2003}, se temos \(S_1, \dots, S_i\), então é possível determinar o \(i\)-path até qualquer ponto \(p\) de maneira eficiente. Para tal, consideramos os três casos possíveis para o último segmento do \(i\)-path até \(p\), que dependem da região de \(S_i\) à qual \(p\) pertence:

\begin{itemize}

	\item \textbf{Região de Vértice}: Se \(p\) pertence a uma região associada a um vértice \(v\) de \(P_i\), então o último segmento do \(i\)-path até \(p\) é o segmento \(\overline{vp}\). Assim, o \(i\)-path até \(p\) é simplesmente o \((i - 1)\)-path até \(v\) seguido do segmento \(\overline{vp}\).
	
	\item \textbf{Região de Aresta}: Se \(p\) pertence a uma região associada a uma aresta \(e = \overline{v^1 v^2}\) de \(P_i\), então refletimos o ponto \(p\) em relação à reta que contém \(e\), obtendo um ponto refletido \(p'\). Assim, o \(i\)-path até \(p\) será exatamente o \((i - 1)\)-path até \(p'\), com excessão de que devemos refletir seu último segmento a partir do ponto que ele passa pela aresta \(e\).
	
	\item \textbf{Região de Atravessar}: Se \(p\) pertence à região de atravessar \(P_i\), então o último segmento do \(i\)-path até \(p\) atravessa o interior de \(P_i\). Nesse caso, o \(i\)-path até \(p\) é simplesmente o \((i - 1)\)-path até \(p\).

\end{itemize}

A Figura~\ref{fig:path_query} ilustra esses três casos. O primeiro quadro mostra o caso em que o ponto está em uma região de vértice, o segundo quadro ilustra o caso em que o ponto está em uma região de aresta, assim como o processo de reflexão e construção do caminho, e o terceiro quadro apresenta o caso em que o ponto está na região de atravessar o polígono. 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.99\textwidth]{Images/solutions.png}
	\caption{Três casos possíveis para o último segmento de um \(1\)-path até um ponto \(p\).}
	\label{fig:path_query}
\end{figure}

Com base nessas ideias, implementamos o Algoritmo~\algref{alg:consulta-caminho}, que dado um ponto \(p\) e um índice \(i\), retorna o \(i\)-path até \(p\) como uma sequência de pontos em \(\mathbb{R}^2\) excluindo o último ponto do caminho \(p\), que é conhecido. Também assumimos que temos uma função \texttt{LocalizaPonto} que localiza o ponto \(p\) no mapa de último passo \(S_i\) de \(P_i\) e retorna a região \(R\) à qual \(p\) pertence, essa região carrega informações suficientes para determinar o tipo de região (vértice, aresta ou atravessar) e os dados necessários para reconstruir o caminho conforme descrito anteriormente.

\begin{algorithm}[!ht]
\alglabel{alg:consulta-caminho}
\caption{Consulta Caminho}
\Input{\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\)}
\Output{\(i\)-path até \(p\) como uma sequência de pontos em \(\mathbb{R} ^ 2\) desconsiderando \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}
 
\Function {ConsultaCaminho(\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\))} {

	\If {\(i = 0\)} {
		\Return {} \([s]\)
	}
	
	\(R \leftarrow \text{LocalizaPonto}(p, P_i, T_i, S_i)\) // Localiza o ponto \(p\) no mapa de último passo \(S_i\) \\
	
	\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
		\(\mathbb{P} \leftarrow \text{ConsultaCaminho}(v, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\Return {} \(\mathbb{P} \oplus [v]\) // Adiciona \(v\) ao final do caminho \(\mathbb{P}\)
	}
	
	\ElseIf {\(R\) corresponde a uma aresta \(e = \overline{v^1 v^2}\) de \(P_i\)} {
		\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) \\
		\(\mathbb{P} \leftarrow \text{ConsultaCaminho}(p', i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(q' \leftarrow\) último ponto de \(\mathbb{P}\) \\
		\(q \leftarrow\) ponto de interseção entre as retas que passam por \(\overline{q' p'}\) e \(e\) \\
		\Return {} \(\mathbb{P} \oplus [q]\) // Adiciona \(q\) ao final do caminho \(\mathbb{P}\)
	}
	
	\ElseIf {\(R\) corresponde a atravessar \(P_i\)} {
		\Return {} \(\text{ConsultaCaminho}(p, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
	}
}

\end{algorithm}

O Algoritmo~\algref{alg:consulta-caminho} permite que calculemos o \(i\)-path até qualquer ponto \(p\) de forma eficiente, podendo ser utilizado para calcular o \(k\)-path até \(t\), que é exatamente a solução do problema. No entanto, frequentemente, nos interessamos apenas no último segmento do \(i\)-path até \(p\). Ademais, o caso em que um ponto está em uma região associada a um vértice de \(P_i\) permite que determinemos o último segmento diretamente, sem precisar calcular o restante do caminho. Assim, implementamos o Algoritmo~\algref{alg:consulta-ultimo-passo}, que dado um ponto \(p\) e um índice \(i\), retorna o ponto inicial do último segmento do \(i\)-path até \(p\).

\begin{algorithm}[!ht]
\alglabel{alg:consulta-ultimo-passo}
\caption{Consulta Último Passo}
\Input{\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\)}
\Output{Ponto que precede \(p\) no \(i\)-path até \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {ConsultaÚltimoPasso(\(p, i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i)\))} {

\If {\(i = 0\)} {
		\Return {} \(s\)
	}

	\(R \leftarrow \text{LocalizaPonto}(p, P_i, T_i, S_i)\) \\

	\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
		\Return {} \(v\)
	}
	\ElseIf {\(R\) corresponde a uma aresta \(e\) de \(P_i\)} {
		\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) \\
		\(q' \leftarrow \text{ConsultaÚltimoPasso}(p', i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(q \leftarrow\) ponto de interseção entre \(\overline{q' p'}\) e \(e\) \\
		\Return {} \(q\)
	}
	\ElseIf {\(R\) corresponde a atravessar \(P_i\)} {
		\Return {} \(\text{ConsultaÚltimoPasso}(p, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
	}
}

\end{algorithm}

Esses dois algoritmos serão utilizados em todas as implementações que discutiremos a seguir, a diferença entre elas estará na implementação do algoritmo \texttt{LocalizaPonto} e na forma como calculamos as regiões de primeiro contato \(T_i\) e os mapas de último passo \(S_i\) para cada polígono \(P_i\).

\subsection{Primeira Abordagem}

Primeiramente, vamos calcular a região de primeiro contato \(T_i\) de um polígono \(P_i\), sabemos que essa região é a união de arestas de \(P_i\), sendo delimitada por vértices de \(P_i\) \cite[\textbf{Lemma 2.}]{tpp-dror2003}, assim, apenas precisamos determinar quais arestas de \(P_i\) pertencem a \(T_i\). Seja \(e = \overline{v^1 v^2}\) uma aresta de \(P_i\), \(p\) um ponto qualquer nessa aresta e \(q\) o ponto que precede \(p\) no \((i - 1)\)-path até \(p\). Note que, \(e \in T_i\) se e somente se a direção \((q - p)\) está do lado externo de \(P_i\). Como isso vale para qualquer ponto \(p\) em \(e\).

A Figura~\ref{fig:first_contact_region} ilustra como podemos usar essa ideia para determinar a região de primeiro contato de um polígono, realizando o teste para ambos vértices de cada aresta do polígono. Implementamos essa ideia no Algoritmo~\algref{alg:first_contact_region}, usando o vértice \(v^1\) como o ponto \(p\) para determinar se a aresta \(e\) pertence a \(T_i\).

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.6\textwidth]{Images/utpp-first_contact.png}
	\caption{Determinando região de primeiro contato de um polígono.}
	\label{fig:first_contact_region}
\end{figure}

\begin{algorithm}[!ht]
\alglabel{alg:first_contact_region}
\caption{Região de Primeiro Contato}
\Input{\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1})\)}
\Output{Região de primeiro contato \(T_i\) de \(P_i\) como um conjunto de arestas de \(P_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {RegiãoDePrimeiroContato(\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1})\))} {

	\(T_i \leftarrow \emptyset\)
	
	\For {cada aresta \(e\) de \(P_i\)} {
	
		\(v^1 \leftarrow\) vértice anterior de \(e\) \\
		\(v^2 \leftarrow\) vértice posterior de \(e\) \\
	
		\(q \leftarrow \text{ConsultaÚltimoPasso}(v^1, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	
		\If {\((q - v^1) \times (v^2 - v^1) < 0\)} {
			\(T_i \leftarrow T_i \cup e\)
		}
	}
	
	\Return {} \(T_i\)
}


\end{algorithm}

Ademais, uma vez que temos \(T_0, \dots, T_i\), podemos calcular o mapa de último passo \(S_i\) de \(P_i\). Para tal, notamos que \(S_i\) tem exatamente três tipos de regiões: regiões associadas a vértices de \(P_i\) em \(T_i\), regiões associadas a arestas de \(P_i\) em \(T_i\) e uma única região de atravessar \(P_i\), que coincide com as arestas que não estão em \(T_i\). Ademais, uma região associada à aresta \(e\) é delimitada pelas regiões associadas às pontas de \(e\) e pela aresta \(e\) em si. Além disso, a região de atravessar \(P_i\) é definida como o complemento das regiões associadas a vértices e arestas de \(P_i\). Assim, para construir \(S_i\), precisamos apenas determinar as regiões associadas a vértices de \(P_i\) em \(T_i\).

Pelas condições de otimalidade discutidas em \cite[\textbf{Local Optimality Conditions.}]{tpp-dror2003}, sabemos que para cada vértice \(v\) de \(P_i\) que está em \(T_i\), a região associada a \(v\) em \(S_i\) é simplesmente um cone definido pelo ponto \(v\) e um par ordenado de raios que partem de \(v\). Podemos calcular esses raios a partir do último segmento do \((i - 1)\)-path até \(v\) e sua reflexão em relação às arestas de \(P_i\) que contêm \(v\). Entrando em mais detalhe, se \(e^1\) e \(e^2\) são as arestas de \(P_i\) em sentido anti-horário que contêm \(v\) e \(q\) é o ponto que precede \(v\) no \((i - 1)\)-path até \(v\), então o primeiro raio é a reflexão do vetor \(\overrightarrow{qv}\) em relação à reta que contém \(e^1\) caso \(e^1\) faça parte de \(T_i\), ou simplesmente o vetor \(\overrightarrow{qv}\) caso contrário. De forma análoga, o segundo raio é a reflexão do vetor \(\overrightarrow{qv}\) em relação à reta que contém \(e^2\) caso \(e^2\) faça parte de \(T_i\), ou simplesmente o vetor \(\overrightarrow{qv}\) caso contrário. Repetimos esse processo para todos os vértices de \(P_i\) e assim obtemos todas as regiões associadas a vértices de \(P_i\) em \(S_i\). Implementamos essa ideia no Algoritmo~\algref{alg:last_step_map}.

\begin{algorithm}[!ht]
\alglabel{alg:last_step_map}
\caption{Mapa de Último Passo}

\Input{\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1})\)}
\Output{Mapa de último passo \(S_i\) de \(P_i\) como uma associação de pares ordenados de raios aos vértices das arestas de \(T_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {MapaDeÚltimoPasso(\(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1})\))} {

	\(S_i \leftarrow \emptyset\)

	\For{vértice \(v\) de \(P_i\) tal que existe \(e\) em \(T_i\) incidente a \(v\)} {
		
		\(e^1 \leftarrow\) aresta anterior de \(v\) em \(P_i\) \\
		\(e^2 \leftarrow\) aresta posterior de \(v\) em \(P_i\) \\

		\(q \leftarrow \text{ConsultaÚltimoPasso}(v, i - 1, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(d \leftarrow v - q\)

		\If {\(e^1\) pertence a \(T_i\)} {
			\(r^1 \leftarrow\) reflexão de \(d\) em relação à reta que contém \(e^1\)
		}
		\Else {
			\(r^1 \leftarrow d\)
		}

		\If {\(e^2\) pertence a \(T_i\)} {
			\(r^2 \leftarrow\) reflexão de \(d\) em relação à reta que contém \(e^2\)
		}
		\Else {
			\(r^2 \leftarrow d\)
		}

		Associa \((r^1, r^2)\) a \(v\) e adiciona à \(S_i\)
	}

	\Return {} \(S_i\)
}

\end{algorithm}

Uma vez que temos \(T_i\) e \(S_i\), desejamos implementar o algoritmo \texttt{LocalizaPonto} que localiza um ponto \(p\) no mapa de último passo \(S_i\). Na primeira abordagem, implementamos esse procedimento de forma direta, verificando cada região de vértice, então cada região de aresta e caso o ponto não pertença à nenhuma dessas retornamos a região de atravessar \(P_i\). Para verificar se um ponto \(p\) pertence a uma região associada a um vértice \(v\) de \(P_i\) com raios \(r^1\) e \(r^2\), primeiro precisamos determinar se o ângulo de abertura entre \(r^1\) e \(r^2\) é menor ou maior que \(180^\circ\). Se o ângulo for menor que \(180^\circ\), então \(p\) pertence à região associada a \(v\) se o produto vetorial entre \(r^1\) e \(\overrightarrow{vp}\) for positivo \textbf{e} o produto vetorial entre \(\overrightarrow{vp}\) e \(r^2\) for negativo. Caso contrário, \(p\) pertence à região associada a \(v\) se o produto vetorial entre \(r^1\) e \(\overrightarrow{vp}\) for positivo \textbf{ou} o produto vetorial entre \(\overrightarrow{vp}\) e \(r^2\) for negativo, essas ideias são ilustradas na Figura~\ref{fig:point_in_cone}.

\begin{figure}[!ht]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{Images/cone_check_small.png}
		\caption{Ângulo de abertura menor que \(180^\circ\).}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{Images/cone_check_large.png}
		\caption{Ângulo de abertura maior que \(180^\circ\).}
	\end{subfigure}
	\caption{Verificando se um ponto pertence a uma região associada a um vértice em um mapa de último passo.}
	\label{fig:point_in_cone}
\end{figure}

Ademais, desejamos verificar se um ponto \(p\) pertence a uma região associada a uma aresta \(e\) de \(P_i\). Para isso, consideramos que \(v^1\) e \(v^2\) são os vértices que definem a aresta \(e\) em sentido anti-horário e consideramos os raios \(r^1\) como o segundo raio do vértice \(v^1\) e \(r^2\) como o primeiro raio do vértice \(v^2\) em \(S_i\). Então, \(p\) pertence à região associada a \(e\) ele estiver do lado externo da aresta \(e\) e entre os raios \(r^1\) e \(r^2\), como ilustrado na Figura~\ref{fig:point_in_edge_region}. 

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.8\textwidth]{Images/edge_region_check.png}
	\caption{Verificando se um ponto pertence a uma região de aresta.}
	\label{fig:point_in_edge_region}
\end{figure}

Uma vez que conseguimos verificar se um ponto pertence a uma região associada a um vértice ou a uma aresta de \(P_i\), podemos implementar o algoritmo \texttt{LocalizaPonto} de forma direta, como mostrado no Algoritmo~\algref{alg:locate_point_first_approach}. Fazemos dois loops: o primeiro verifica todas as regiões associadas a vértices de \(P_i\) em \(T_i\) e o segundo verifica todas as regiões associadas a arestas de \(P_i\) em \(T_i\). Caso o ponto \(p\) não pertença a nenhuma dessas regiões, retornamos a região de atravessar \(P_i\).

\begin{algorithm}[!ht]
\alglabel{alg:locate_point_first_approach}
\caption{Localiza Ponto - Primeira Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {LocalizaPonto(\(p, P_i, T_i, S_i\))} {

	\For {vértice \(v\) de \(P_i\) tal que existe \(e\) em \(T_i\) incidente a \(v\)} {

		\((r^1, r^2) \leftarrow\) raios associados a \(v\) em \(S_i\) \\

		\If {\(r^1 \times r^2 \geq 0\)} {
			\Return {} \((r^1 \times (p - v) > 0) \land (r^2 \times (p - v) < 0)\)
		}
		\Else {
			\Return {} \((r^1 \times (p - v) > 0) \lor (r^2 \times (p - v) < 0)\)
		}
	}

	\For {aresta \(e = \overline{v^1 v^2}\) de \(P_i\) em \(T_i\)} {
		\(r^1 \leftarrow\) segundo raio associado a \(v^1\) em \(S_i\) \\
		\(r^2 \leftarrow\) primeiro raio associado a \(v^2\) em \(S_i\) \\

		\If {\((r^1 \times (p - v^1) > 0) \land (r^2 \times (p - v^2) < 0) \land ((p - v^1) \times (v^2 - v^1) < 0)\)} {
			\Return {} região associada a \(e\)
		}
	}

	\Return {} região de atravessar \(P_i\)
}

\end{algorithm}

Finalmente, uma vez que sabemos como calcular \(T_i\), \(S_i\) e localizar um ponto \(p\) em \(S_i\), podemos implementar o algoritmo completo para resolver o problema TPP, conforme mostrado no Algoritmo~\algref{alg:tpp_complete-1-2}. Esse algoritmo itera sobre todos os polígonos \(P_1, \dots, P_k\), calculando \(T_i\) e \(S_i\) para cada polígono usando os algoritmos discutidos anteriormente. Após calcular todas as regiões de primeiro contato e mapas de último passo, o algoritmo retorna o \(k\)-path até o ponto \(t\) utilizando o Algoritmo~\algref{alg:consulta-caminho}. Esse algoritmo também será utilizado na segunda abordagem, onde apenas o algoritmo \texttt{LocalizaPonto} será modificado.

\begin{algorithm}[!ht]
\alglabel{alg:tpp_complete-1-2}
\caption{TPP Irrestrito - Implementação Completa (Primeira e Segunda Abordagens)}
\Input{Pontos \(s\) e \(t\), sequência de polígonos convexos disjuntos (\(P_1, \dots, P_k\))}

\Output{\(k\)-path até \(t\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {TPP\_Irrestrito(\(s, t, (P_1, \dots, P_k)\))} {

	\((T_1, \dots, T_k) \leftarrow \emptyset\) \\
	\((S_1, \dots, S_k) \leftarrow \emptyset\) \\

	\For {\(i \leftarrow 1\) até \(k\)} {
		
		\(T_i \leftarrow \text{RegiãoDePrimeiroContato}(i, s, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
		\(S_i \leftarrow \text{MapaDeÚltimoPasso}(i, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1}))\)
	}

	\Return {} \(\text{ConsultaCaminho}(t, k, (P_1, \dots, P_k), (T_1, \dots, T_k), (S_1, \dots, S_k))\)

}

\end{algorithm}

\subsection{Segunda Abordagem}

Na segunda abordagem, vamos alterar apenas a implementação do algoritmo \texttt{LocalizaPonto}, utilizando uma estratégia de busca binária para localizar o ponto \(p\) no mapa de último passo \(S_i\). Definimos \(u^1, \dots, u^m\) como os vértices de \(P_i\) que pertencem a \(T_i\), ordenados em sentido anti-horário. A ideia central desse algoritmo é usar "arestas fictícias" que conectam dois vértices \(u^i\) e \(u^j\) formando uma nova região \(R\). Essa região tem a propriedade que podemos verificar se \(p\) está em \(R\) em tempo \(O(1)\) e \(p\) está em \(R\) se e somente se \(p\) está em alguma região de vértice ou de aresta entre \(u^i\) e \(u^j\). Assim, podemos usar uma estratégia de busca binária para localizar \(p\) em \(S_i\).

Devemos mencionar que estamos assumindo que o ponto \(p\) não está no interior do polígono \(P_i\). Esse fato é garantido pela suposição de que os polígonos são disjuntos, incluindo \(s\) e \(t\). No entanto, caso desejemos lidar com o caso em que \(p\) pode estar no interior de \(P_i\), podemos iniciar o algoritmo verificando se \(p\) está no interior de \(P_i\) em tempo \(O(\log(\abs{P_i}))\), embora não discutiremos essa verificação aqui, pois não é o foco deste trabalho.

\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.65\textwidth]{Images/binary_search-1.png}
	\caption{Estratégia de busca binária para localizar um ponto em um mapa de último passo.}
	\label{fig:binary_search-1}
\end{figure}

A Figura~\ref{fig:binary_search-1} será usada para descrever cada etapa do algoritmo a seguir. O primeiro quadro mostra um polígono \(P_i\) de 8 vértices, dos quais 5 pertencem a \(T_i\), marcados como \(u^1, \dots, u^5\), também desenhamos as regiões de vértices em vermelho, regiões de aresta em verde a região de travessia em azul, vamos localizar um ponto nesse mapa de último passo. O algoritmo em si tem 2 passos iniciais e então inicia a busca binária, da maneira que descrevemos a seguir:

\begin{blockQuote}
	
	\textbf{Algoritmo para localizar um ponto \(p\) em \(S_i\):}

	\vspace{1em}

	\noindent \textbf{Passo 1.} Verificar se \(p\) está na região de travessia de \(P_i\) (Quadro 2): Criamos uma aresta fictícia entre \(u^5\) e \(u^1\), gerando uma região \(R\) que contém exatamente a região de travessia e parte de \(P_i\). Podemos verificar se \(p\) está em \(R\) usando a mesma estratégia que usamos no Algoritmo~\algref{alg:locate_point_first_approach}, considerando \(u^5\) e \(u^1\) como os vértices que definem a aresta fictícia e o segundo raio de \(u^5\) e o primeiro raio de \(u^1\) como os raios que delimitam \(R\). Se \(p\) estiver em \(R\), retornamos a região de travessia.
	
	\vspace{1em}

	\noindent \textbf{Passo 2.} Verificar se \(p\) está em alguma região de vértice de \(u^1\) ou \(u^5\) (Quadro 3): Usamos a mesma estratégia do Algoritmo~\algref{alg:locate_point_first_approach} para verificar se \(p\) está em alguma das regiões de vértice de \(u^1\) ou \(u^5\), caso esteja, retornamos a região correspondente.
	
	\vspace{1em}

	\noindent \textbf{Passo 3.} Busca Binária (Quadro 4): Agora sabemos que \(p\) não está na região de travessia nem nas regiões de vértice de \(u^1\) ou \(u^5\), assim, podemos iniciar a busca binária entre os vértices \(u^1\) e \(u^5\). Para tal, selecionamos \(u^3\) como um vértice intermediário e então verificamos se \(p\) está na região de vértice de \(u^3\), se sim, retornamos essa região. 
	
	Caso contrário, criamos duas arestas fictícias, uma entre \(u^1\) e \(u^3\) e outra entre \(u^3\) e \(u^5\), gerando as regiões \(R_1\) (em roxo) e \(R_2\) (em laranja). Verificamos se \(p\) está em \(R_1\), se sim, repetimos o processo recursivamente considerando apenas os vértices entre \(u^1\) e \(u^3\). Caso contrário, sabemos que \(p\) está em \(R_2\) e repetimos o processo recursivamente considerando apenas os vértices entre \(u^3\) e \(u^5\). Repetimos esse passo até que \(p\) esteja em uma região de vértice ou reste apenas dois vértices, a esse ponto, sabemos que \(p\) deve estar na região de aresta entre esses vértices.

\end{blockQuote}

A maioria desse algoritmo é direta e fácil de ser implementada, exceto pela parte de verificar se \(p\) está na região \(R_1\), uma vez que ela pode ter uma forma que não é coberta pela nossa verificação original do Algoritmo~\algref{alg:locate_point_first_approach}, pois quando criamos uma aresta fictícia entre dois vértices \(v^1\) e \(v^2\) com raios \(r^1\) e \(r^2\), criamos a possibilidade de que \(r^1\) e \(r^2\) formem um ângulo maior que \(180^\circ\), ou estejam em lados diferentes da aresta fictícia, como ilustrado na Figura~\ref{fig:binary_search-2}.


\begin{figure}[!ht]
	\centering
	\includegraphics[width=0.7\textwidth]{Images/binary_search-2.png}
	\caption{Quatro casos possíveis ao criar uma região de aresta fictícia.}
	\label{fig:binary_search-2}
\end{figure}

Vamos dizer que queremos determinar se um ponto \(p\) pertence à região de aresta fictícia entre os vértices \(v^1\) e \(v^2\) delimitados pelos raios \(r^1\) partindo de \(v^1\) e \(r^2\) partindo de \(v^2\). Os casos são determinados pelo "lado" que \(r^1\) e \(r^2\) se encontram em relação à direção \(d = v^2 - v^1\), tratamos cada caso separadamente:

\begin{itemize}

	\item \(d \times r^1 < 0 \land d \times r^2 < 0\): Esse caso é o ilustrado no primeiro quadro da Figura~\ref{fig:binary_search-2} e é o caso que estamos acostumados a lidar. Nesse caso, simplesmente verificamos se \(p\) está entre os raios \(r^1\) e \(r^2\) e do lado externo da aresta \(\overline{v^1 v^2}\).

	\item \(d \times r^1 > 0 \land d \times r^2 > 0\): Esse caso é o ilustrado no segundo quadro da Figura~\ref{fig:binary_search-2} e é o complemento do caso anterior. Nesse caso, verificamos se \(p\) não está entre os raios \(r^1\) e \(r^2\) \textbf{e} está do lado interno da aresta \(\overline{v^1 v^2}\).
	
	\item \(d \times r^1 < 0 \land d \times r^2 > 0\): Esse caso é o ilustrado no terceiro quadro da Figura~\ref{fig:binary_search-2}. Para esse caso, precisamos primeiro verificar de qual lado da reta que contém \(\overline{v^1 v^2}\) o ponto \(p\) está. Se \(p\) estiver do lado externo, então verificamos se \(p\) está do lado negativo de \(r^2\), caso contrário, verificamos se \(p\) está do lado positivo de \(r^1\).
	
	\item \(d \times r^1 > 0 \land d \times r^2 < 0\): Esse caso é o ilustrado no quarto quadro da Figura~\ref{fig:binary_search-2}. Para esse caso, precisamos primeiro verificar de qual lado da reta que contém \(\overline{v^1 v^2}\) o ponto \(p\) está. Se \(p\) estiver do lado externo, então verificamos se \(p\) está do lado positivo de \(r^1\), caso contrário, verificamos se \(p\) está do lado negativo de \(r^2\).

\end{itemize}

Com essas verificações em mente, podemos implementar o algoritmo \texttt{LocalizaPonto} usando a estratégia de busca binária, conforme mostrado no Algoritmo~\algref{alg:locate_point_second_approach}. Nele, implementamos a função auxiliar \texttt{VerificaAresta} que verifica se \(p\) está na região de aresta fictícia entre dois vértices \(v^1\) e \(v^2\) usando as verificações discutidas anteriormente. Também abstraimos a verificação se \(p\) está na região de vértice de um dado vértice \(u^{mid}\) em uma verificação direta, uma vez que essa verificação é idêntica àquela usada no Algoritmo~\algref{alg:locate_point_first_approach}.

A vantagem dessa abordagem é que a busca binária reduz o número de regiões de vértice que precisamos verificar para localizar \(p\) em \(S_i\) de \(O(\abs{T_i})\) para \(O(\log(\abs{T_i}))\), o que pode ser uma melhoria significativa quando \(P_i\) tem muitos vértices em \(T_i\). Vamos analizar o efeito dessa mudança adiante na análise de complexidade.

\begin{algorithm}[!ht]
\alglabel{alg:locate_point_second_approach}
\caption{Localiza Ponto - Segunda Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {LocalizaPonto(\(p, P_i, T_i, S_i\))} {

	\Function {VerificaAresta(\(v^1, v^2\))} {
		\(r^1 \leftarrow\) segundo raio associado a \(v^1\) em \(S_i\) \\
		\(r^2 \leftarrow\) primeiro raio associado a \(v^2\) em \(S_i\) \\

		\(d \leftarrow v^2 - v^1\) \\

		\If {\(d \times r^1 < 0 \land d \times r^2 < 0\)} {
			\Return {} \(r^1 \times (p - v^1) > 0 \land r^2 \times (p - v^2) < 0 \land (p - v^1) \times (v^2 - v^1) < 0\)
		}
		\ElseIf {\(d \times r^1 > 0 \land d \times r^2 > 0\)} {
			\Return {} \(r^1 \times (p - v^1) \leq 0 \land r^2 \times (p - v^2) \geq 0 \land (p - v^1) \times (v^2 - v^1) \geq 0\)
		}
		\ElseIf {\(d \times r^1 < 0 \land d \times r^2 > 0\)} {
			\If {\((p - v^1) \times (v^2 - v^1) < 0\)} {
				\Return {} \(r^2 \times (p - v^2) < 0\)
			}
			\Else {
				\Return {} \(r^1 \times (p - v^1) > 0\)
			}
		}
		\Else {
			\If {\((p - v^1) \times (v^2 - v^1) < 0\)} {
				\Return {} \(r^1 \times (p - v^1) > 0\)
			}
			\Else {
				\Return {} \(r^2 \times (p - v^2) < 0\)
			}
		}
	}

	\(u_1, \dots, u_m \leftarrow\) vértices de \(P_i\) em \(T_i\), ordenados em sentido anti-horário \\

	\If {VerificaAresta(\(u^m, u^1\))} {
		\Return {} região de atravessar \(P_i\)
	}
	\If {\(p\) está na região de vértice de \(u^1\)} {
		\Return {} região associada a \(u^1\)
	}

	\If {\(p\) está na região de vértice de \(u^m\)} {
		\Return {} região associada a \(u^m\)
	}

	\(l \leftarrow 1\) \\
	\(r \leftarrow m\)

	\While {\(l + 1 \ne r\)} {

		\(mid \leftarrow \floor{(l + r) / 2}\)

		\If {\(p\) está na região de vértice de \(u^{mid}\)} {
			\Return {} região associada a \(u^{mid}\)
		}

		\If {VerificaAresta(\(u^{l}, u^{mid}\))} {
			\(r \leftarrow mid\)
		}
		\Else {
			\(l \leftarrow mid\)
		}
	}

	\Return {} região associada a aresta \(\overline{u^{l} u^{r}}\)
}

\end{algorithm}

\subsection{Terceira Abordagem}

Antes de discutirmos a terceira abordagem, buscamos trazer uma motivação para essa nova implementação do algoritmo \texttt{LocalizaPonto}. Considere o caso de um único polígono \(P_1\) com muitos vértices, um milhão, por exemplo, nossa segunda abordagem calcula \(T_1\), então \(S_1\) e finalmente faz uma única consulta ao mapa de último passo \(S_1\) para localizar o ponto \(t\). No entanto, essa consulta usa no máximo 20 regiões de vértice de \(P_1\) para localizar \(t\) em \(S_1\), assim, calculamos 999980 regiões de vértice de \(P_1\) que nunca são utilizadas. Portanto, na terceira abordagem, buscamos utilizar uma estratégia de memoização para calcular apenas as regiões de vértice de \(P_i\) que são necessárias para localizar os pontos consultados no mapa de último passo \(S_i\).

O primeiro problema que precisamos resolver é como determinar se uma dada aresta \(e = \overline{v^1 v^2}\) de \(P_i\) está \(T_i\) fazendo apenas uma única chamada ao algoritmo ConsultaÚltimoPasso. Para isso, podemos simplesmente reutilizar a ideia do Algoritmo~\algref{alg:first_contact_region} que calculava \(T_i\) por completo, mas agora, ao invés de verificar todas as arestas de \(P_i\), verificamos apenas a aresta \(e\). Assim, calculamos o último passo \(q\) do \(i\)-path até o ponto médio \(v^1\) da aresta \(e\) e verificamos se \((q - v^1) \times (v^2 - v^1)\) é negativo, se for, então \(e\) pertence a \(T_i\), caso contrário, não pertence.

A seguir, precisamos calcular os raios associados a um vértice \(v\) de \(P_i\) em \(S_i\), novamente fazendo apenas uma única chamada ao algoritmo ConsultaÚltimoPasso. Para isso, reutilizamos a ideia do Algoritmo~\algref{alg:last_step_map} que calculava \(S_i\) por completo, mas agora, ao invés de calcular os raios para todos os vértices de \(P_i\), calculamos apenas os raios para o vértice \(v\). No entanto, esse algoritmo assumia que sabemos quais arestas de \(P_i\) pertencem a \(T_i\), então precisamos saber se as arestas incidentes em \(v\) pertencem a \(T_i\) ou não sem fazer chamadas adicionais ao algoritmo ConsultaÚltimoPasso. 

Para isso, retomamos a ideia de se \(e\) é uma aresta de \(P_i\), \(p\) um ponto qualquer em \(e\) e \(q\) o último passo do \((i - 1)\)-path até \(p\), então \(e \in T_i\) se e somente se \((q - p)\) está do lado externo de \(e\). Assim, seja \(v\) um vértice de \(P_i\) e \(e^1\) e \(e^2\) as arestas incidentes em \(v\), podemos calcular o último passo \(q\) do \((i - 1)\)-path até \(v\) e então verificar se \((q - v)\) está do lado externo de \(e^1\) e \(e^2\) para determinar se essas arestas pertencem a \(T_i\). Com essa informação, podemos facilmente adaptar o Algoritmo~\algref{alg:last_step_map} para calcular apenas os raios associados a \(v\) em \(S_i\).

Uma última observação importante é que como não sabemos \(T_i\), pode ser que tentemos calcular os raios associados a um vértice \(v\) de \(P_i\) em \(S_i\), mas nenhuma das arestas incidentes em \(v\) pertença a \(T_i\). Nesse caso, não precisamos alterar o algoritmo, uma vez que seu comportamente natural será retornar dois raios cuja direção é igual ao raio que chega em \(v\) no \((i - 1)\)-path, o que representa uma região vazia em \(S_i\), o que é condizente com um vértice que não pertence a \(T_i\).

Finalmente, podemos descrever como implementamos o algoritmo \texttt{LocalizaPonto} usando essa estratégia de memoização. Vamos reutilizar a ideia de busca binária da segunda abordagem, mas agora nosso passos iniciais serão simplificados, uma vez que delegamos a parte de verificar a região de travessia para depois da busca binária. O algoritmo segue da seguinte forma:

\begin{blockQuote}
	
	\textbf{Algoritmo para localizar um ponto \(p\) em \(S_i\):}

	\vspace{1em}

	\noindent \textbf{Passo 1.} Sejam \(v^1, \dots, v^m\) os vértices de \(P_i\) ordenados em sentido anti-horário. Calcule os raios associados a \(v^1\) em \(S_i\) e verifique se \(p\) está na região de vértice de \(v^1\), se sim, retorne essa região.

	\vspace{1em}

	\noindent \textbf{Passo 2.} Seja \(v' = v^{\floor{m / 2}}\), calcule os raios associados a \(v'\) em \(S_i\) e verifique se \(p\) está na região de vértice de \(v'\), se sim, retorne essa região. 
	
	Caso contrário, crie as arestas fictícias entre \(v^1\) e \(v'\) e entre \(v'\) e \(v^m\), gerando as regiões \(R_1\) e \(R_2\). Verifique se \(p\) está em \(R_1\) usando o mesmo procedimento do Algoritmo~\algref{alg:locate_point_second_approach}, se sim, repita esse passo considerando apenas os vértices entre \(v^1\) e \(v'\), caso contrário, repita esse passo considerando apenas os vértices entre \(v'\) e \(v^m\). 
	
	Esse passo é repetido até que encontremos um vértice \(v^k\) tal que \(p\) está na região de vértice de \(v^k\) ou restem apenas dois vértices \(v^l\) e \(v^r\), nesse ponto, sabemos que \(p\) deve estar na região de aresta entre esses vértices.

	\vspace{1em}

	\noindent \textbf{Passo 3.} Caso \(p\) não tenha sido localizado em uma região de vértice, concluimos que ele deve estar na região de aresta entre os dois últimos vértices \(v^l\) e \(v^r\) considerados. Para finalizar, usamos as ideia discutidas acima para determinar se essa aresta está em \(T_i\) fazendo apenas uma consulta e então retornamos a região de aresta correspondente, caso contrário, retornamos a região de travessia de \(P_i\).

\end{blockQuote}

Dessa forma, concluimos a descrição da terceira abordagem para implementar o algoritmo \texttt{LocalizaPonto} usando memoização. Decidimos não incluir o pseudocódigo completo dessa abordagem, uma vez que ele seria bastante semelhante ao Algoritmo~\algref{alg:locate_point_second_approach}, com as modificações discutidas acima.

\subsection{Análise de Complexidade}

Primeiramente, vamos analizar a complexidade das duas primeiras abordagens. Note que ambos os algoritmos seguem a mesma estrutura geral, como mostrado no Algoritmo~\algref{alg:tpp_complete-1-2}, portanto, a análise de complexidade será similar para ambos, a única diferença será a complexidade do algoritmo \texttt{LocalizaPonto}.

\begin{itemize}

	\item Algoritmos de verificação de regiões (Algoritmos~\algref{alg:point_in_cone}, \algref{alg:point_in_edge_region} e \algref{alg:point_in_edge_region_modified}): Todos esses algoritmos têm complexidade \(O(1)\), pois envolvem apenas algumas operações aritméticas e comparações.
	
	\item Algoritmo \texttt{LocalizaPonto} (Algoritmos~\algref{alg:locate_point_first_approach} e \algref{alg:locate_point_second_approach}): A primeira abordagem tem complexidade \(O(\abs{T_i})\), enquanto a segunda abordagem tem complexidade \(O(\log(\abs{T_i}))\).
	
	\item Algoritmos de consulta de último segmento e consulta de caminho (Algoritmos~\algref{alg:consulta-ultimo-passo} e \algref{alg:consulta-caminho}): Ambos os algoritmos começam fazendo uma chamada ao algoritmo \texttt{LocalizaPonto}, o pior caso ocorre quando o ponto \(p\) está na região de atravessar \(P_i\) ou em uma região de aresta, o que exige outra consulta ao mapa de último passo \(S_{i - 1}\). Portanto, a complexidade desses algoritmos é:
	
	\[
		\begin{cases}
			O(\sum_{j = 1}^{i} \abs{P_j}) & \text{para a primeira abordagem} \\
			O(\sum_{j = 1}^{i} \log(\abs{T_j})) & \text{para a segunda abordagem}
		\end{cases}
	\]

	\item Algoritmo para calcular \(T_i\) e \(S_i\) (Algoritmos~\algref{alg:first_contact_region} e \algref{alg:last_step_map}): Ambos os algoritmos fazem uma única passagem pelos vértices de \(P_i\), fazendo uma consulta para cada vértice. Portanto, a complexidade desses algoritmos é:

	\[
		\begin{cases}
			O(\abs{P_i} \sum_{j = 1}^{i} \abs{T_j}) & \text{para a primeira abordagem} \\
			O(\abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j})) & \text{para a segunda abordagem}
		\end{cases}
	\]

	\item Algoritmo TPP completo (Algoritmo~\algref{alg:tpp_complete-1-2}): O algoritmo faz uma chamada para calcular \(T_i\) e \(S_i\) para cada \(i\) de 1 a \(k\), e finalmente faz uma chamada para consultar o caminho até \(t\). Portanto, a complexidade total do algoritmo TPP é:
	
	\[
		\begin{cases}
			O(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{P_j} + \sum_{j = 1}^{k} \abs{P_j}) & \text{para a primeira abordagem} \\
			O(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j}) + \sum_{j = 1}^{k} \log(\abs{T_j})) & \text{para a segunda abordagem}
		\end{cases}
	\]

\end{itemize}

Podemos simplificar as expressões acima, considerando que \(n = \sum_{i = 1}^{k} \abs{P_i}\) é o número total de vértices em todos os polígonos, vamos fazer a simplificação para a segunda abordagem, que é mais eficiente, e deixamos a primeira abordagem como exercício para o leitor.

\begin{align*}
	O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j}) + \sum_{j = 1}^{k} \log(\abs{T_j})} &= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j})} \\
	&= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{P_j})} \\
	&= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log(\abs{P_j})} \\
	&= O\parens[\bigg]{\sum_{j=1}^{k}\log(\abs{P_j})\sum_{i=1}^{k}\abs{P_i}} \\
	&= O\parens[\bigg]{n \sum_{j=1}^{k}\log(\abs{P_j})} \\
\end{align*}

Finalmente, não é difícil mostrar que fixando \(n\), temos que \(\sum_{j=1}^{k}\log(\abs{P_j})\) é maximizado quando todos os polígonos têm o mesmo número de vértices, ou seja, \(\abs{P_j} = n/k\) para todo \(j\). Portanto, temos que a complexidade final do algoritmo TPP usando a segunda abordagem é \(O(nk\log(n/k))\). Essa complexidade é exatamente a indicada por Dror et al. (2003) \cite{tpp-dror2003}, assim, concluímos que nossa implementação é tão eficiente quanto a proposta original.

\
\newpage

\printbibliography

\newpage

\end{document}
