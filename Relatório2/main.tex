
\documentclass[11pt]{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

% make conditions/keyword arguments use text mode
\renewcommand{\algorithmcfname}{Algoritmo}
\SetArgSty{textnormal}
\SetFuncSty{textnormal}

\SetKwInOut{Input}{Entrada}
\SetKwInOut{Output}{Saída}
\SetKwIF{If}{ElseIf}{Else}{se}{:}{senão se}{senão}{end}
\SetKwFor{For}{para cada}{:}{end}
\SetKwRepeat{Do}{do}{enquanto}
\SetKwProg{Function}{define}{:}{}
\SetKw{Return}{retorna}

\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{#1}%
}

\newcommand{\algref}[1]{\ref{#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
% \usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}
\usepackage{csquotes}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{cleveref}
\usepackage{desclist}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blank}{}{} % Blank enviroment for folding sections in editors

\newenvironment{blockQuote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}
\DeclarePairedDelimiter{\anglebrackets}{\langle}{\rangle}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

% Footnote spacing
\setlength{\skip\footins}{0.5cm}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}


\title{\textbf{O Problema de Visita de Polígonos}\thanks{Esse trabalho foi parcialmente apoiado pela agência FAPESP (processo 2025/13861-1).}}

\author{
	Gabriel F. Ushijima\thanks{Instituto de Matemática e Estatística, Universidade de São Paulo, Rua do Matão, 1010, Cidade Universitária,
05508-090, São Paulo, SP, Brazil (e-mail: gabriel\_ushijima@ime.usp.br, egbirgin@ime.usp.br).\vspace{0.5cm}}
	\and
	\(\text{Ernesto G. Birgin}^\dagger\)
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Esse artigo apresenta diversas implementações de algoritmos para o problema de visita de polígonos (Touring Polygons Problem - TPP), que consiste em encontrar o caminho mais curto que visita um conjunto de polígonos no plano. O problema em sua forma geral é NP-difícil, assim, primeiro consideramos uma versão simplificada onde os polígonos são convexos e não se sobrepõem, e apresentamos um algoritmo exato baseado em mapas de último passo. Em seguida, discutimos heurísticas para o caso geral, utilizando técnicas de programação inteira mista. Finalmente, realizamos experimentos computacionais para avaliar o desempenho dos algoritmos propostos em instâncias de diferentes tamanhos e características, comparando com solvers comerciais. Os resultados indicam que as abordagens desenvolvidas são eficazes para resolver o TPP em diversas situações práticas.

\vspace{10pt}

\noindent \textbf{Palavras-chave:} Problema de visita de polígonos, otimização geométrica, complexidade, experimentos numéricos.
\end{abstract}

\section{Introdução}

O Problema de Visita de Polígonos (Touring Polygons Problem - TPP) é um problema de otimização geométrica que consiste em encontrar o caminho mais curto que visita um conjunto de polígonos no plano. Esse tipo de problema tem aplicações em diversas áreas, principalmente no contexto de roteirização e planejamento de trajetórias para veículos autônomos, onde é necessário garantir que certas regiões sejam visitadas de forma eficiente, como a inspeção automatizada de armazéns \cite{jianxian2023, karl2009}. Dentre as diversas variações do problema, vamos considerar inicialmente uma versão simplificada onde os polígonos são convexos e não se sobrepões, apresentando três abordagens distintas para sua resolução. A primeira abordagem é uma implementação intuitiva das ideias descritas por Dror et al. (2003) \cite{tpp-dror2003} baseada em mapas de último passo. A segunda abordagem melhora a eficiência da primeira ao uma estratégia de busca binária para localizar os pontos nos mapas de último passo. A terceira abordagem utiliza uma estratégia de memoização para evitar cálculos desnecessários.

Em seguida, discutimos heurísticas para o caso geral do TPP, onde os polígonos podem ser côncavos. Nos baseamos principalmente na ideia de particionar os polígonos côncavos em subconjuntos convexos e aplicar as soluções desenvolvidas para o caso convexo. Além disso, exploramos técnicas de programação inteira mista para modelar o problema e utilizar solvers comerciais para encontrar soluções aproximadas, como o \href{https://www.gurobi.com}{Gurobi}, então comparamos os resultados obtidos com nossas implementações.

\section{O Problema de Visita de Polígonos Convexos}

Primeiramente, consideramos o TPP no caso de polígonos convexos e não sobrepostos. Seja \(s, t \in \mathbb{R} ^ 2\) pontos no plano e \(P_1, \dots, P_k\) uma sequência de polígonos convexos disjuntos, dados por uma sequência de vértices ordenados em sentido anti-horário. O objetivo é encontrar um caminho de comprimento mínimo que começa em \(s\), termina em \(t\) e visita cada polígono \(P_i\) em ordem pelo menos uma vez. Dizemos que o caminho visita os polígnos na ordem \(P_1, P_2, \dots, P_k\) se existem pontos \(p_1, p_2, \dots, p_k\) tais que \(p_i \in P_i\) para \(i = 1, 2, \dots, k\) e o caminho passa por esses pontos nessa ordem. Vamos implementar as ideias apresentadas por Dror et al. (2003) \cite{tpp-dror2003} para resolver esse problema de forma exata, assumindo que o leitor já leu o artigo mencionado, uma vez que fazemos uso direto de suas definições e resultados. O código completo está disponível no \href{https://github.com/YushiPy/TouringPolygons}{repositório GitHub}.

Retomando as definições do artigo, dizemos que um \(i\)-path até \(p\) é um caminho de comprimento mínimo que começa em \(s\), termina em \(p\) e visita os polígonos \(P_1, P_2, \dots, P_i\) em ordem. Consideramos que já sabemos que todo \(i\)-path é a união de segmentos de reta e é único. A região de primeiro contato \(T_i\) de um polígono \(P_i\) é o conjunto de pontos \(p\) no perímetro de \(P_i\) tais que o segmento entre \(P_{i - 1}\) e \(P_i\) do \(i\)-path até \(p\) intersecta \(P_i\) apenas em \(p\). O mapa de último passo \(S_i\) de um polígono \(P_i\) é uma partição de \(\mathbb{R} ^ 2\) em regiões \(R\) tais que o último segmento do \(i\)-path até qualquer ponto \(p \in R\) parte de um mesmo vértice de \(P_i\) ou de uma mesma aresta de \(P_i\) ou atravessa \(P_i\). 

Como discutido em \cite[\textbf{Lemma 3.}]{tpp-dror2003}, se tivermos \(T_0, \dots, T_i\), \(S_0, \dots, S_i\) e soubermos localizar um ponto \(p\) em \(S_i\), então podemos calcular o \(i\)-path até \(p\) de forma eficiente. Se \(p\) pertence à região \(R\) de \(S_i\) e essa região está associada a um vértice \(v\), então o último segmento do \(i\)-path até \(p\) é o segmento \(\overline{vp}\) e o restante do caminho é o \((i - 1)\)-path até \(v\). Se \(R\) está associada a uma aresta \(e\), então refletimos \(p\) em relação à reta que contém \(e\), chamando esse ponto de \(p'\), então calculamos o \((i - 1)\)-path até \(p'\), considerando-o apenas até o ponto que seu último segmento intersecta a aresta \(e\) e conectamos o final desse caminho com o ponto \(p\), sendo esse o \(i\)-path. Por fim, se \(R\) corresponde a atravessar \(P_i\), então o \(i\)-path até \(p\) é igual ao \((i - 1)\)-path até \(p\). Implementamos essa ideia no Algoritmo~\algref{alg:consulta-caminho}, assumindo que temos um algoritmo auxiliar chamado \texttt{LocalizaPonto} que localiza o ponto \(p\) no mapa de último passo \(S_i\), vamos discutir diferentes implementações para esse procedimento posteriormente.

\begin{algorithm}[H]
\alglabel{alg:consulta-caminho}
\caption{Consulta Caminho}
\Input{\(p\), \(i\), \((P_1, \dots, P_i)\), \((T_1, \dots, T_i)\), \((S_1, \dots, S_i)\)}
\Output{\(i\)-path até \(p\) como uma sequência de pontos em \(\mathbb{R} ^ 2\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\If {\(i = 0\)} {
	\Return {} \([s, p]\)
}

\(R \leftarrow \text{LocalizaPonto}(p, S_i)\) // Localiza o ponto \(p\) no mapa de último passo \(S_i\) \\

\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
	// Adiciona \(p\) ao final do \((i - 1)\)-path até \(v\) \\
	\Return {} \(\text{ConsultaCaminho}(v, i - 1, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1})) \oplus [p]\) 
}

\ElseIf {\(R\) corresponde a uma aresta \(e\) de \(P_i\)} {
	\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) \\
	\(\text{path} \leftarrow \text{ConsultaCaminho}(p', i - 1, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	\(\text{path}' \leftarrow \) pontos de \(\text{path}\) que antecedem \(p'\) \\
	\(q' \leftarrow\) último ponto de \(\text{path}'\) \\
	\(q \leftarrow\) ponto de interseção entre \(\overline{q' p'}\) e \(e\) \\
	// Adiciona \(q\) e \(p\) ao final do \(\text{path}'\) \\
	\Return {} \(\text{path}' \oplus [q, p]\)
}

\Else {
	// \(R\) corresponde a atravessar \(P_i\) \\
	\Return {} \(\text{ConsultaCaminho}(p, i - 1, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
}

\end{algorithm}

O Algoritmo~\algref{alg:consulta-caminho} permite que calculemos o \(i\)-path até qualquer ponto \(p\) de forma eficiente, podendo ser utilizado para calcular o \(k\)-path até \(t\), que é exatamente a solução do problema. No entanto, frequentemente, nos interessamos apenas no último segmento do \(i\)-path até \(p\). Ademais, o caso em que um ponto está em uma região associada a um vértice de \(P_i\) permite que determinemos o último segmento diretamente, sem precisar calcular o restante do caminho. Assim, implementamos o Algoritmo~\algref{alg:consulta-ultimo-passo}, que dado um ponto \(p\) e um índice \(i\), retorna o ponto inicial do último segmento do \(i\)-path até \(p\).

\begin{algorithm}[H]
\alglabel{alg:consulta-ultimo-passo}
\caption{Consulta Último Passo}
\Input{\(p\), \(i\), \((P_1, \dots, P_i)\), \((T_1, \dots, T_i)\), \((S_1, \dots, S_i)\)}
\Output{Ponto que precede \(p\) no \(i\)-path até \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\If {\(i = 0\)} {
	\Return {} \(s\)
}

\(R \leftarrow \text{LocalizaPonto}(p, S_i)\) \\

\If {\(R\) corresponde a um vértice \(v\) de \(P_i\)} {
	\Return {} \(v\)
}
\ElseIf {\(R\) corresponde a uma aresta \(e\) de \(P_i\)} {
	\(p' \leftarrow\) reflexão de \(p\) em relação à reta que contém \(e\) \\
	\(q' \leftarrow \text{ConsultaÚltimoPasso}(p', i - 1, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	\(q \leftarrow\) ponto de interseção entre \(\overline{q' p'}\) e \(e\) \\
	\Return {} \(q\)
}
\Else {
	\Return {} \(\text{ConsultaÚltimoPasso}(p, i - 1, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\)
}

\end{algorithm}

Esses dois algoritmos serão utilizados em todas as implementações que discutiremos a seguir, a diferença entre elas estará na implementação do algoritmo \texttt{LocalizaPonto} e na forma como calculamos as regiões de primeiro contato \(T_i\) e os mapas de último passo \(S_i\) para cada polígono \(P_i\).

\subsection{Primeira Abordagem}

Primeiramente, vamos calcular a região de primeiro contato \(T_i\) de um polígono \(P_i\), sabemos que essa região é a união de arestas de \(P_i\), sendo delimitada por vértices de \(P_i\) \cite[\textbf{Lemma 2.}]{tpp-dror2003}, assim, apenas precisamos determinar quais arestas de \(P_i\) pertencem a \(T_i\). Para isso, para cada aresta de \(P_i\), definimos \(m\) como o ponto médio dessa aresta e então calculamos o \(i\)-path até \(m\), definindo \(q\) como o ponto que antecede \(m\) nesse caminho. Se o segmento entre \(q\) e \(m\) intersecta \(P_i\) apenas em \(m\), então, por definição, \(m\) pertence a \(T_i\) e como \(T_i\) é a união de arestas de \(P_i\), toda a aresta que contém \(m\) pertence a \(T_i\). Repetimos esse processo para todas as arestas de \(P_i\) e assim obtemos \(T_i\).

Agora, para determinar se o segmento entre \(q\) e \(m\) intersecta \(P_i\) apenas em \(m\), simplesmente verificamos se o vetor \(\overrightarrow{qm}\) está do lado externo da aresta de \(P_i\) que contém \(m\), ou seja, se o produto escalar entre \(\overrightarrow{qm}\) e o vetor normal à aresta de \(P_i\) que contém \(m\) é positivo, isso é equivalente a dizer que o produto vetorial entre \(\overrightarrow{qm}\) e o vetor que conecta os dois vértices da aresta de \(P_i\) que contém \(m\) é negativo. Ilustramos essa ideia na Figura~\ref{fig:first_contact_region}. Também implementamos isso no Algoritmo~\algref{alg:first_contact_region}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Images/utpp-first_contact.png}
	\caption{Verificando se uma aresta pertence à região de primero contato de um polígono.}
	\label{fig:first_contact_region}
\end{figure}

\begin{algorithm}[H]
\alglabel{alg:first_contact_region}
\caption{Região de Primeiro Contato}
\Input{\(s\), \(i\), \((P_1, \dots, P_i)\), \((T_1, \dots, T_{i - 1})\), \((S_1, \dots, S_{i - 1})\)}
\Output{Região de primeiro contato \(T_i\) de \(P_i\) como um conjunto de arestas de \(P_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\(T_i \leftarrow \emptyset\)

\For {cada aresta \(e\) de \(P_i\)} {

	\(v^1 \leftarrow\) vértice anterior de \(e\) \\
	\(v^2 \leftarrow\) vértice posterior de \(e\) \\
	\(m \leftarrow (v^1 + v^2) / 2\) \\

	\(q \leftarrow \text{ConsultaÚltimoPasso}(m, i - 1, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\

	\If {\((q - m) \times (v^2 - v^1) < 0\)} {
        \(T_i \leftarrow T_i \cup e\)
	}
}

\Return {} \(T_i\)

\end{algorithm}

Ademais, uma vez que temos \(T_0, \dots, T_i\), podemos calcular o mapa de último passo \(S_i\) de \(P_i\). Para tal, notamos que \(S_i\) tem exatamente três tipos de regiões: regiões associadas a vértices de \(P_i\) em \(T_i\), regiões associadas a arestas de \(P_i\) em \(T_i\) e uma única região de atravessar \(P_i\), que coincide com as arestas que não estão em \(T_i\). Ademais, uma região associada à aresta \(e\) é delimitada pelas regiões associadas às pontas de \(e\) e pela aresta \(e\) em si. Além disso, a região de atravessar \(P_i\) é definida como o complemento das regiões associadas a vértices e arestas de \(P_i\). Assim, para construir \(S_i\), precisamos apenas determinar as regiões associadas a vértices de \(P_i\) em \(T_i\).

Pelas condições de otimalidade discutidas em \cite[\textbf{Local Optimality Conditions.}]{tpp-dror2003}, sabemos que para cada vértice \(v\) de \(P_i\) que está em \(T_i\), a região associada a \(v\) em \(S_i\) é simplesmente um cone definido pelo ponto \(v\) e um par ordenado de raios que partem de \(v\). Podemos calcular esses raios a partir do último segmento do \((i - 1)\)-path até \(v\) e sua reflexão em relação às arestas de \(P_i\) que contêm \(v\). Entrando em mais detalhe, se \(e^1\) e \(e^2\) são as arestas de \(P_i\) em sentido anti-horário que contêm \(v\) e \(q\) é o ponto que precede \(v\) no \((i - 1)\)-path até \(v\), então o primeiro raio é a reflexão do vetor \(\overrightarrow{qv}\) em relação à reta que contém \(e^1\) caso \(e^1\) faça parte de \(T_i\), ou simplesmente o vetor \(\overrightarrow{qv}\) caso contrário. De forma análoga, o segundo raio é a reflexão do vetor \(\overrightarrow{qv}\) em relação à reta que contém \(e^2\) caso \(e^2\) faça parte de \(T_i\), ou simplesmente o vetor \(\overrightarrow{qv}\) caso contrário. Repetimos esse processo para todos os vértices de \(P_i\) e assim obtemos todas as regiões associadas a vértices de \(P_i\) em \(S_i\). Implementamos essa ideia no Algoritmo~\algref{alg:last_step_map}.

\begin{algorithm}[H]
\alglabel{alg:last_step_map}
\caption{Mapa de Último Passo}

\Input{\(s\), \(i\), \((P_1, \dots, P_i)\), \((T_1, \dots, T_i)\), \((S_1, \dots, S_{i - 1})\)}
\Output{Mapa de último passo \(S_i\) de \(P_i\) como uma associação de pares ordenados de raios aos vértices das arestas de \(T_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\(S_i \leftarrow \emptyset\)

\For{vértice \(v\) de \(P_i\) tal que existe \(e\) em \(T_i\) incidente a \(v\)} {
	
	\(e^1 \leftarrow\) aresta anterior de \(v\) em \(P_i\) \\
	\(e^2 \leftarrow\) aresta posterior de \(v\) em \(P_i\) \\

	\(q \leftarrow \text{ConsultaÚltimoPasso}(v, i - 1, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	\(d \leftarrow v - q\)

	\If {\(e^1\) pertence a \(T_i\)} {
		\(r^1 \leftarrow\) reflexão de \(d\) em relação à reta que contém \(e^1\)
	}
	\Else {
		\(r^1 \leftarrow d\)
	}

	\If {\(e^2\) pertence a \(T_i\)} {
		\(r^2 \leftarrow\) reflexão de \(d\) em relação à reta que contém \(e^2\)
	}
	\Else {
		\(r^2 \leftarrow d\)
	}

	Associa \((r^1, r^2)\) a \(v\) e adiciona à \(S_i\)
}

\Return {} \(S_i\)

\end{algorithm}

Uma vez que temos \(T_i\) e \(S_i\), desejamos implementar o algoritmo \texttt{LocalizaPonto} que localiza um ponto \(p\) no mapa de último passo \(S_i\). Na primeira abordagem, implementamos esse procedimento de forma direta, verificando cada região de vértice, então cada região de aresta e caso o ponto não pertença à nenhuma dessas retornamos a região de atravessar \(P_i\). Para verificar se um ponto \(p\) pertence a uma região associada a um vértice \(v\) de \(P_i\) com raios \(r^1\) e \(r^2\), primeiro precisamos determinar se o ângulo de abertura entre \(r^1\) e \(r^2\) é menor ou maior que \(180^\circ\). Se o ângulo for menor que \(180^\circ\), então \(p\) pertence à região associada a \(v\) se o produto vetorial entre \(r^1\) e \(\overrightarrow{vp}\) for positivo \textbf{e} o produto vetorial entre \(\overrightarrow{vp}\) e \(r^2\) for negativo. Caso contrário, \(p\) pertence à região associada a \(v\) se o produto vetorial entre \(r^1\) e \(\overrightarrow{vp}\) for positivo \textbf{ou} o produto vetorial entre \(\overrightarrow{vp}\) e \(r^2\) for negativo, essas ideias são ilustradas na Figura~\ref{fig:point_in_cone} e implementadas no Algoritmo~\algref{alg:point_in_cone}.

\begin{figure}[H]
	\centering
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{Images/cone_check_small.png}
		\caption{Ângulo de abertura menor que \(180^\circ\).}
	\end{subfigure}
	\begin{subfigure}{0.49\textwidth}
		\centering
		\includegraphics[width=0.8\textwidth]{Images/cone_check_large.png}
		\caption{Ângulo de abertura maior que \(180^\circ\).}
	\end{subfigure}
	\caption{Verificando se um ponto pertence a uma região associada a um vértice em um mapa de último passo.}
	\label{fig:point_in_cone}
\end{figure}

\begin{algorithm}[H]
\alglabel{alg:point_in_cone}
\caption{Ponto em Região de Vértice}
\Input{\(p\), \(v\), \(r^1\), \(r^2\)}
\Output{\texttt{true} se \(p\) pertence à região delimitada por \(v\), \(r^1\) e \(r^2\), \texttt{false} caso contrário.}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\If {\(r^1 \times r^2 \geq 0\)} {
	// Ângulo de abertura menor que \(180^\circ\) \\
	\Return {} \((r^1 \times (p - v) > 0) \land (r^2 \times (p - v) < 0)\)
}
\Else {
	// Ângulo de abertura maior que \(180^\circ\) \\
	\Return {} \((r^1 \times (p - v) > 0) \lor (r^2 \times (p - v) < 0)\)
}

\end{algorithm}

Ademais, desejamos verificar se um ponto \(p\) pertence a uma região associada a uma aresta \(e\) de \(P_i\). Para isso, consideramos que \(v^1\) e \(v^2\) são os vértices que definem a aresta \(e\) em sentido anti-horário e consideramos os raios \(r^1\) como o segundo raio do vértice \(v^1\) e \(r^2\) como o primeiro raio do vértice \(v^2\) em \(S_i\). Então, \(p\) pertence à região associada a \(e\) ele estiver do lado externo da aresta \(e\) e entre os raios \(r^1\) e \(r^2\), como ilustrado na Figura~\ref{fig:point_in_edge_region}. Implementamos essa ideia no Algoritmo~\algref{alg:point_in_edge_region}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Images/edge_region_check.png}
	\caption{Verificando se um ponto pertence a uma região de aresta.}
	\label{fig:point_in_edge_region}
\end{figure}

\begin{algorithm}
\alglabel{alg:point_in_edge_region}
\caption{Ponto em Região de Aresta}
\Input{\(p, v^1, v^2, r^1, r^2\)}
\Output{\texttt{true} se \(p\) pertence à região delimitada por \(e = \overline{v^1 v^2}\), \(r^1\) e \(r^2\), \texttt{false} caso contrário.}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Return {} \(r^1 \times (p - v^1) > 0 \land r^2 \times (p - v^2) < 0 \land (p - v^1) \times (v^2 - v^1) < 0\)

\end{algorithm}

Uma vez que conseguimos verificar se um ponto pertence a uma região associada a um vértice ou a uma aresta de \(P_i\), podemos implementar o algoritmo \texttt{LocalizaPonto} de forma direta, como mostrado no Algoritmo~\algref{alg:locate_point_first_approach}.

\begin{algorithm}[H]
\alglabel{alg:locate_point_first_approach}
\caption{Localiza Ponto - Primeira Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\For {vértice \(v\) de \(P_i\) tal que existe \(e\) em \(T_i\) incidente a \(v\)} {
	\((r^1, r^2) \leftarrow\) raios associados a \(v\) em \(S_i\) \\
	\If {\(\text{PontoEmRegiãoDeVértice}(p, v, r^1, r^2)\)} {
		\Return {} região associada a \(v\)
	}
}

\For {cada aresta \(e = \overline{v^1 v^2}\) de \(P_i\) em \(T_i\)} {
	\(r^1 \leftarrow\) segundo raio associado a \(v^1\) em \(S_i\) \\
	\(r^2 \leftarrow\) primeiro raio associado a \(v^2\) em \(S_i\) \\
	\If {\(\text{PontoEmRegiãoDeAresta}(p, v^1, v^2, r^1, r^2)\)} {
		\Return {} região associada a \(e\)
	}
}

\Return {} região de atravessar \(P_i\)

\end{algorithm}

O Algoritmo~\algref{alg:locate_point_first_approach} verifica todas as regiões de vértices e arestas de \(P_i\) para localizar o ponto \(p\), assim, sua complexidade é \(O(\abs{P_i})\), onde \(\abs{P_i}\) é o número de vértices de \(P_i\). Como esse procedimento será chamado diversas vezes durante a execução dos Algoritmos~\algref{alg:consulta-caminho} e \algref{alg:consulta-ultimo-passo}, essa implementação pode ser ineficiente para polígonos com muitos vértices. Portanto, discutimos duas outras abordagens para implementar o algoritmo \texttt{LocalizaPonto} de forma mais eficiente, usando estratégias de busca binária e memoização.

\subsection{Segunda Abordagem}

Na segunda abordagem, vamos alterar apenas a implementação do algoritmo \texttt{LocalizaPonto}, utilizando uma estratégia de busca binária para localizar o ponto \(p\) no mapa de último passo \(S_i\). Definimos \(u^1, \dots, u^m\) como os vértices de \(P_i\) que pertencem a \(T_i\), ordenados em sentido anti-horário. A ideia central desse algoritmo é usar "arestas fictícias" que conectam dois vértices \(u^i\) e \(u^j\) formando uma nova região \(R\). Essa região tem a propriedade que podemos verificar se \(p\) está em \(R\) em tempo \(O(1)\) e \(p\) está em \(R\) se e somente se \(p\) está em alguma região de vértice ou de aresta entre \(u^i\) e \(u^j\). Assim, podemos usar uma estratégia de busca binária para localizar \(p\) em \(S_i\).

Devemos mencionar que estamos assumindo que o ponto \(p\) não está no interior do polígono \(P_i\). Esse fato é garantido pela suposição de que os polígonos são disjuntos, incluindo \(s\) e \(t\). No entanto, caso desejemos lidar com o caso em que \(p\) pode estar no interior de \(P_i\), podemos iniciar o algoritmo verificando se \(p\) está no interior de \(P_i\) em tempo \(O(\log(\abs{P_i}))\), embora não discutiremos essa verificação aqui, pois não é o foco deste trabalho.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.65\textwidth]{Images/binary_search-1.png}
	\caption{Estratégia de busca binária para localizar um ponto em um mapa de último passo.}
	\label{fig:binary_search-1}
\end{figure}

Ilustramos a ideia anterior na Figura~\ref{fig:binary_search-1}. O primeiro quadro mostra um polígono \(P_i\) de 8 vértices, dos quais 5 pertencem a \(T_i\), marcados como \(u^1, \dots, u^5\), também desenhamos as regiões de vértices em vermelho, regiões de aresta em verde a região de travessia em azul. No segunda quadro, criamos uma aresta fictícia entre \(u^5\) e \(u^1\), gerando uma região \(R\) que contém exatamente a região de travessia e parte de \(P_i\). Podemos verificar se \(p\) está em \(R\) usando o Algoritmo~\algref{alg:point_in_edge_region}, considerando \(u^5\) e \(u^1\) como os vértices que definem a aresta fictícia e o segundo raio de \(u^5\) e o primeiro raio de \(u^1\) como os raios que delimitam \(R\). No terceiro quadro, verificamos se \(p\) está em alguma das regiões de vértice de \(u^1\) ou \(u^5\), usando o Algoritmo~\algref{alg:point_in_cone}, caso esteja, retornamos a região correspondente.

No quarto quadro, selecionamos \(u^3\) como um vértice intermediário e criamos duas arestas fictícias, uma entre \(u^1\) e \(u^3\) e outra entre \(u^3\) e \(u^5\), gerando as regiões \(R_1\) (em roxo) e \(R_2\) (em laranja). Primeiramente verificamos se \(p\) está na região de vértice de \(u^3\), se sim, retornamos essa região. Caso contrário, verificamos se \(p\) está em \(R_1\), se sim, repetimos o processo recursivamente considerando apenas os vértices entre \(u^1\) e \(u^3\). Caso contrário, sabemos que \(p\) está em \(R_2\) e repetimos o processo recursivamente considerando apenas os vértices entre \(u^3\) e \(u^5\). Repetimos esse processo até que reste apenas dois vértices, a esse ponto, sabemos que \(p\) deve estar na região de aresta entre esses vértices. No entanto, repare que as regiões \(R^1\) e \(R^2\) não têm o formato tradicional de região de aresta que estamos acostumados como \(R\) tem, assim precisamos adaptar o Algoritmo~\algref{alg:point_in_edge_region} para lidar com esse caso.

Por hora, assumimos que conseguimos adaptar o Algoritmo~\algref{alg:point_in_edge_region} para lidar com esse caso, então implementamos o Algoritmo~\algref{alg:locate_point_second_approach} que utiliza a estratégia de busca binária para localizar o ponto \(p\) no mapa de último passo \(S_i\). Nele, definimos duas funções auxiliares, \texttt{VerificaVértice} e \texttt{VerificaAresta}, que servem apenas para evitar repetição de código. A função \texttt{VerificaVértice} verifica se o ponto \(p\) pertence à região associada a um vértice \(v\) de \(P_i\) em \(T_i\), enquanto a função \texttt{VerificaAresta} verifica se o ponto \(p\) pertence à região associada a uma aresta fictícia entre dois vértices \(v^1\) e \(v^2\) de \(P_i\) em \(T_i\). O restante do algoritmo segue a estratégia de busca binária discutida anteriormente.

\begin{algorithm}[H]
\alglabel{alg:locate_point_second_approach}
\caption{Localiza Ponto - Segunda Abordagem}
\Input{\(p\), \(P_i\), \(T_i\), \(S_i\)}
\Output{Região de \(S_i\) que contém \(p\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\Function {VerificaVértice(\(v\))} {
	\((r^1, r^2) \leftarrow\) raios associados a \(v\) em \(S_i\) \\
	\Return {} \(\text{PontoEmRegiãoDeVértice}(p, v, r^1, r^2)\)
}

\Function {VerificaAresta(\(v^1, v^2\))} {
	\(r^1 \leftarrow\) segundo raio associado a \(v^1\) em \(S_i\) \\
	\(r^2 \leftarrow\) primeiro raio associado a \(v^2\) em \(S_i\) \\
	\Return {} \(\text{PontoEmRegiãoDeAresta}(p, v^1, v^2, r^1, r^2)\)
}

\(u_1, \dots, u_m \leftarrow\) vértices de \(P_i\) em \(T_i\), ordenados em sentido anti-horário \\

\If {VerificaAresta(\(u^m, u^1\))} {
	\Return {} região de atravessar \(P_i\)
}
\If {VerificaVértice(\(u^1\))} {
	\Return {} região associada a \(u^1\)
}

\If {VerificaVértice(\(u^m\))} {
	\Return {} região associada a \(u^m\)
}

\(l \leftarrow 1\) \\
\(r \leftarrow m\)

\While {\(l + 1 \ne r\)} {

	\(mid \leftarrow \floor{(l + r) / 2}\)

	\If {VerificaVértice(\(u^{mid}\))} {
		\Return {} região associada a \(u^{mid}\)
	}

	\If {VerificaAresta(\(u^{l}, u^{mid}\))} {
		\(r \leftarrow mid\)
	}
	\Else {
		\(l \leftarrow mid\)
	}
}

\Return {} região associada a aresta \(\overline{u^{l} u^{r}}\)

\end{algorithm}

Agora que temos uma motivação, vamos resolver o problema que deixamos em aberto anteriormente, que é adaptar o Algoritmo~\algref{alg:point_in_edge_region} para lidar com o caso em que a região de aresta é definida por uma aresta fictícia entre dois vértices \(v^1\) e \(v^2\). Para isso, devemos considerar que quando criamos a região temos 4 casos possíveis, ilustrados na Figura~\ref{fig:binary_search-2}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.7\textwidth]{Images/binary_search-2.png}
	\caption{Quatro casos possíveis ao criar uma região de aresta fictícia.}
	\label{fig:binary_search-2}
\end{figure}

Vamos dizer que queremos determinar se um ponto \(p\) pertence à região de aresta fictícia entre os vértices \(v^1\) e \(v^2\) delimitados pelos raios \(r^1\) partindo de \(v^1\) e \(r^2\) partindo de \(v^2\). Os casos são determinados pelo "lado" que \(r^1\) e \(r^2\) se encontram em relação à direção \(d = v^2 - v^1\), tratamos cada caso separadamente:

\begin{itemize}

	\item \(d \times r^1 < 0 \land d \times r^2 < 0\): Esse caso é o ilustrado no primeiro quadro da Figura~\ref{fig:binary_search-2} e é o caso que estamos acostumados a lidar. Nesse caso, simplesmente verificamos se \(p\) está entre os raios \(r^1\) e \(r^2\) e do lado externo da aresta \(\overline{v^1 v^2}\).

	\item \(d \times r^1 > 0 \land d \times r^2 > 0\): Esse caso é o ilustrado no segundo quadro da Figura~\ref{fig:binary_search-2} e é o complemento do caso anterior. Nesse caso, verificamos se \(p\) não está entre os raios \(r^1\) e \(r^2\) \textbf{e} está do lado interno da aresta \(\overline{v^1 v^2}\).
	
	\item \(d \times r^1 < 0 \land d \times r^2 > 0\): Esse caso é o ilustrado no terceiro quadro da Figura~\ref{fig:binary_search-2}. Para esse caso, precisamos primeiro verificar de qual lado da reta que contém \(\overline{v^1 v^2}\) o ponto \(p\) está. Se \(p\) estiver do lado externo, então verificamos se \(p\) está do lado negativo de \(r^2\), caso contrário, verificamos se \(p\) está do lado positivo de \(r^1\).
	
	\item \(d \times r^1 > 0 \land d \times r^2 < 0\): Esse caso é o ilustrado no quarto quadro da Figura~\ref{fig:binary_search-2}. Para esse caso, precisamos primeiro verificar de qual lado da reta que contém \(\overline{v^1 v^2}\) o ponto \(p\) está. Se \(p\) estiver do lado externo, então verificamos se \(p\) está do lado positivo de \(r^1\), caso contrário, verificamos se \(p\) está do lado negativo de \(r^2\).

\end{itemize}

Implementamos essas ideias no Algoritmo~\algref{alg:point_in_edge_region_modified}.

\begin{algorithm}[H]
\alglabel{alg:point_in_edge_region_modified}
\caption{Ponto em Região de Aresta - Adaptado}
\Input{\(p, v^1, v^2, r^1, r^2\)}
\Output{\texttt{true} se \(p\) pertence à região delimitada por aresta fictícia \(\overline{v^1 v^2}\), \(r^1\) e \(r^2\), \texttt{false} caso contrário.}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\(d \leftarrow v^2 - v^1\) \\

\If {\(d \times r^1 < 0 \land d \times r^2 < 0\)} {
	// Caso 1 \\
	\Return {} \(r^1 \times (p - v^1) > 0 \land r^2 \times (p - v^2) < 0 \land (p - v^1) \times (v^2 - v^1) < 0\)
}
\ElseIf {\(d \times r^1 > 0 \land d \times r^2 > 0\)} {
	// Caso 2 \\
	\Return {} \(r^1 \times (p - v^1) \leq 0 \land r^2 \times (p - v^2) \geq 0 \land (p - v^1) \times (v^2 - v^1) \geq 0\)
}
\ElseIf {\(d \times r^1 < 0 \land d \times r^2 > 0\)} {
	// Caso 3 \\
	\If {\((p - v^1) \times (v^2 - v^1) < 0\)} {
		\Return {} \(r^2 \times (p - v^2) < 0\)
	}
	\Else {
		\Return {} \(r^1 \times (p - v^1) > 0\)
	}
}
\Else {
	// Caso 4 \\
	\If {\((p - v^1) \times (v^2 - v^1) < 0\)} {
		\Return {} \(r^1 \times (p - v^1) > 0\)
	}
	\Else {
		\Return {} \(r^2 \times (p - v^2) < 0\)
	}
}

\end{algorithm}

Dessa forma, conseguimos implementar o Algoritmo~\algref{alg:locate_point_second_approach} utilizando o Algoritmo~\algref{alg:point_in_edge_region_modified} para verificar se o ponto \(p\) pertence à região de aresta fictícia entre dois vértices \(v^1\) e \(v^2\). Essa implementação do algoritmo \texttt{LocalizaPonto} tem complexidade \(O(\log(\abs{T_i}))\), onde \(\abs{T_i}\) é o número de vértices de \(P_i\) que pertencem a \(T_i\). Como esse procedimento será chamado diversas vezes durante a execução dos Algoritmos~\algref{alg:consulta-caminho} e \algref{alg:consulta-ultimo-passo}, essa implementação é mais eficiente que a primeira abordagem para polígonos com muitos vértices em \(T_i\).

Agora que concluimos a implementação de \texttt{LocalizaPonto}, podemos concluir o algoritmo para ambas as abordagens discutidas até agora. A implementação completa do algoritmo TPP usando essas abordagens é mostrada no Algoritmo~\algref{alg:tpp_complete-1-2}.

\begin{algorithm}[H]
\alglabel{alg:tpp_complete-1-2}
\caption{TPP - Implementação Completa (Primeira e Segunda Abordagens)}
\Input{Pontos \(s\) e \(t\), sequência de polígonos convexos disjuntos (\(P_1, \dots, P_k\))}

\Output{\(k\)-path até \(t\).}
\vspace{0.3em}
\hrule
\vspace{0.3em}

\((T_1, \dots, T_k) \leftarrow \emptyset\) \\
\((S_1, \dots, S_k) \leftarrow \emptyset\) \\

\For {\(i \leftarrow 1\) até \(k\)} {
	
	\(T_i \leftarrow \text{RegiãoDePrimeiroContato}(s, i, (P_1, \dots, P_i), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	\(S_i \leftarrow \text{MapaDeÚltimoPasso}(s, i, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_{i - 1}))\)
}

\Return {} \(\text{ConsultaCaminho}(t, k, (P_1, \dots, P_k), (T_1, \dots, T_k), (S_1, \dots, S_k))\)

\end{algorithm}

\subsection{Terceira Abordagem}

Antes de discutirmos a terceira abordagem, buscamos trazer uma motivação para essa nova implementação do algoritmo \texttt{LocalizaPonto}. Considere o caso de um único polígono \(P_1\) com muitos vértices, um milhão, por exemplo, nossas abordagens anteriores calculam \(T_1\), então \(S_1\) e finalmente fazem uma única consulta ao mapa de último passo \(S_1\) para localizar o ponto \(t\). No entanto, essa consulta usa no máximo 20 regiões de vértice de \(P_1\) para localizar \(t\) em \(S_1\), assim, calculamos 999980 regiões de vértice de \(P_1\) que nunca são utilizadas. Portanto, na terceira abordagem, buscamos utilizar uma estratégia de memoização para calcular apenas as regiões de vértice de \(P_i\) que são necessárias para localizar os pontos consultados no mapa de último passo \(S_i\).

...

\subsection{Análise de Complexidade}

Primeiramente, vamos analizar a complexidade das duas primeiras abordagens. Note que ambos os algoritmos seguem a mesma estrutura geral, como mostrado no Algoritmo~\algref{alg:tpp_complete-1-2}, portanto, a análise de complexidade será similar para ambos, a única diferença será a complexidade do algoritmo \texttt{LocalizaPonto}.

\begin{itemize}

	\item Algoritmos de verificação de regiões (Algoritmos~\algref{alg:point_in_cone}, \algref{alg:point_in_edge_region} e \algref{alg:point_in_edge_region_modified}): Todos esses algoritmos têm complexidade \(O(1)\), pois envolvem apenas algumas operações aritméticas e comparações.
	
	\item Algoritmo \texttt{LocalizaPonto} (Algoritmos~\algref{alg:locate_point_first_approach} e \algref{alg:locate_point_second_approach}): A primeira abordagem tem complexidade \(O(\abs{T_i})\), enquanto a segunda abordagem tem complexidade \(O(\log(\abs{T_i}))\).
	
	\item Algoritmos de consulta de último segmento e consulta de caminho (Algoritmos~\algref{alg:consulta-ultimo-passo} e \algref{alg:consulta-caminho}): Ambos os algoritmos começam fazendo uma chamada ao algoritmo \texttt{LocalizaPonto}, o pior caso ocorre quando o ponto \(p\) está na região de atravessar \(P_i\) ou em uma região de aresta, o que exige outra consulta ao mapa de último passo \(S_{i - 1}\). Portanto, a complexidade desses algoritmos é:
	
	\[
		\begin{cases}
			O(\sum_{j = 1}^{i} \abs{P_j}) & \text{para a primeira abordagem} \\
			O(\sum_{j = 1}^{i} \log(\abs{T_j})) & \text{para a segunda abordagem}
		\end{cases}
	\]

	\item Algoritmo para calcular \(T_i\) e \(S_i\) (Algoritmos~\algref{alg:first_contact_region} e \algref{alg:last_step_map}): Ambos os algoritmos fazem uma única passagem pelos vértices de \(P_i\), fazendo uma consulta para cada vértice. Portanto, a complexidade desses algoritmos é:

	\[
		\begin{cases}
			O(\abs{P_i} \sum_{j = 1}^{i} \abs{T_j}) & \text{para a primeira abordagem} \\
			O(\abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j})) & \text{para a segunda abordagem}
		\end{cases}
	\]

	\item Algoritmo TPP completo (Algoritmo~\algref{alg:tpp_complete-1-2}): O algoritmo faz uma chamada para calcular \(T_i\) e \(S_i\) para cada \(i\) de 1 a \(k\), e finalmente faz uma chamada para consultar o caminho até \(t\). Portanto, a complexidade total do algoritmo TPP é:
	
	\[
		\begin{cases}
			O(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \abs{P_j} + \sum_{j = 1}^{k} \abs{P_j}) & \text{para a primeira abordagem} \\
			O(\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j}) + \sum_{j = 1}^{k} \log(\abs{T_j})) & \text{para a segunda abordagem}
		\end{cases}
	\]

\end{itemize}

Podemos simplificar as expressões acima, considerando que \(n = \sum_{i = 1}^{k} \abs{P_i}\) é o número total de vértices em todos os polígonos, vamos fazer a simplificação para a segunda abordagem, que é mais eficiente, e deixamos a primeira abordagem como exercício para o leitor.

\begin{align*}
	O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j}) + \sum_{j = 1}^{k} \log(\abs{T_j})} &= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{T_j})} \\
	&= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log(\abs{P_j})} \\
	&= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log(\abs{P_j})} \\
	&= O\parens[\bigg]{\sum_{j=1}^{k}\log(\abs{P_j})\sum_{i=1}^{k}\abs{P_i}} \\
	&= O\parens[\bigg]{n \sum_{j=1}^{k}\log(\abs{P_j})} \\
\end{align*}

Finalmente, não é difícil mostrar que fixando \(n\), temos que \(\sum_{j=1}^{k}\log(\abs{P_j})\) é maximizado quando todos os polígonos têm o mesmo número de vértices, ou seja, \(\abs{P_j} = n/k\) para todo \(j\). Portanto, temos que a complexidade final do algoritmo TPP usando a segunda abordagem é \(O(nk\log(n/k))\). Essa complexidade é exatamente a indicada por Dror et al. (2003) \cite{tpp-dror2003}, assim, concluímos que nossa implementação é tão eficiente quanto a proposta original.

\
\newpage

\printbibliography

\newpage

\end{document}
