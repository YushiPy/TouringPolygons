
\documentclass{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

% make conditions/keyword arguments use text mode
\renewcommand{\algorithmcfname}{Algoritmo}
\SetArgSty{textnormal}

\SetKwInOut{Input}{Entrada}
\SetKwInOut{Output}{Saída}
\SetKwIF{If}{ElseIf}{Else}{if}{:}{else if}{else}{end}
\SetKwFor{For}{for}{:}{end}
\SetKwRepeat{Do}{do}{while}
\SetKwProg{Function}{def}{:}{}

\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{alg:#1}%
}

\newcommand{\algref}[1]{\ref{alg:#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}
\usepackage{csquotes}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{cleveref}
\usepackage{desclist}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blank}{}{} % Blank enviroment for folding sections in editors

\newenvironment{blockQuote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Counter for proof lines
\newcounter{proofline}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}
\DeclarePairedDelimiter{\anglebrackets}{\langle}{\rangle}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\begin{document}

\pagenumbering{roman}

\begin{titlepage}

\begin{center}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.3\textwidth]{logo-small.png} % Ajuste o caminho da imagem conforme necessário
	\end{figure}

	\vspace{2cm}

	{\Large \sc UNIVERSIDADE DE SÃO PAULO} \\
	{\Large \sc INSTITUTO DE MATEMÁTICA E ESTATÍSTICA} \\ [0.7cm]
	{\sc DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO} \\

	\vspace{2cm}

	\rule{\linewidth}{2pt}
	
	\vspace{0.2em} % Ajuste ao seu gosto
	{\Large \bfseries 
		O Problema da Visita de Polígonos \\
	}
	\vspace{0.2em} % Ajuste ao seu gosto
	
	\rule{\linewidth}{2pt} \\

\end{center}

\vspace{2.8cm}

\begin{center}
	{\large \bfseries Gabriel Freire Ushijima} \\
\end{center}

\vfill

% Data
\begin{center}
	\makeatletter
	{\large São Paulo, SP \\
	\@date}
	\makeatother
\end{center}

\end{titlepage}

\newpage

\begin{center}
	\textbf{\LARGE Resumo}
\end{center}

Em diferentes contextos, como robótica, planejamento de rotas e gráficos computacionais, surge a necessidade de encontrar caminhos eficientes que visitem uma série de regiões ou objetos no espaço. O Problema da Visita de Polígonos (TPP) é um problema clássico de otimização geométrica que busca determinar o caminho mais curto que visita uma sequência de polígonos convexos disjuntos em um plano. No presente trabalho se apresentam algoritmos para resolver o TPP em dois cenários distintos: o TPP Irrestrito, onde o caminho pode atravessar os polígonos, e o TPP Restrito, onde o caminho deve contornar os polígonos sem atravessá-los. Baseando-se no trabalho seminal de Dror et al. (2003), este relatório detalha a implementação prática dos algoritmos propostos, destacando suas complexidades computacionais e estratégias de otimização. Além disso, são apresentados resultados experimentais que ilustram a eficácia dos algoritmos em diferentes configurações de entrada. O código-fonte desenvolvido está disponível em um repositório público, facilitando a reprodução dos resultados e a exploração adicional do problema.

\newpage

\tableofcontents

\newpage

\section*{Notações}

\vspace{0.5cm}

% Increase spacing between rows

\begin{blank}

\setlength{\extrarowheight}{10pt}

\begin{tabular}{>{$}l<{$} @{\hspace{1.5em}} p{0.7\linewidth} l}
	v = (v_1, v_2) & Representação de vetores em \(\mathbb{R} ^ 2\) como tupla de coordenadas reais. \\
	\|{v}\| = \sqrt{v_1 ^ 2 + v_2 ^ 2} & Norma Euclidiana de um vetor. \\
	\anglebrackets{u, v} = u_1 v_1 + u_2 v_2 & Produto interno definido como produto escalar de vetores. \\
	u \times v = u_1 v_2 - u_2 v_1 & Produto vetorial definido como determinante 2D, retornando um escalar. Essa definição tem a seguinte propriedade:

	\begin{blank}
	\setlength{\extrarowheight}{4pt}
	\vspace{-10pt}
	\begin{equation*}
		\text{sign}(u \times v) =
		\begin{cases}
			+1, & \text{se o ângulo no sentido \textbf{anti-horário} entre } u \text{ e } v \text{ é menor que } 180 ^ \circ \\
			-1, & \text{se o ângulo no sentido \textbf{horário} entre } u \text{ e } v \text{ é menor que } 180 ^ \circ \\
			0, & u \text{ e } v \text{ colineares} \\
		\end{cases}
	\end{equation*}
	\vspace{-10pt}
	\end{blank} \\
	
	\overline{uv} & Segmento de reta entre os pontos \(u\) e \(v\). \\
	\overrightarrow{uv} = v - u & Vetor direcionado do ponto \(u\) até o ponto \(v\). \\
	\abs{P} & Se \(P\) é um polígono, então \(\abs{P}\) é o número de vértices de \(P\). \\
	\partial P & Fronteira (perímetro) do polígono \(P\). \\
\end{tabular}

\end{blank}

\clearpage
\pagenumbering{arabic}

\section{Introdução}

O Problema de Visita de Polígonos (TPP - \textit{Touring Polygons Problem}) é um problema clássico de otimização geométrica que envolve encontrar o caminho mais curto que visita em ordem uma sequência de polígonos em um plano. O problema é ilustrado pela Figura~\ref{problem-intro}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{exemplo.png}
	\caption{Exemplo do Problema de Visita de Polígonos Irrestrito com 4 polígonos.}
	\label{problem-intro}
\end{figure}

Esse é um caso específico do problema do Caxeiro Viajante com Vizinhanças (TSPN - \textit{Traveling Salesman Problem with Neighborhoods}) \cite{tspn-iacopo-2011}, que é por sua vez uma generalização do famoso Problema do Caxeiro Viajante (TSP - \textit{Traveling Salesman Problem}) \cite{tsp-applegate2006}. Esse problema tem aplicações em diversas áreas, principalmente em robótica no contexto de planejamento de rotas, onde um robô precisa visitar uma série de regiões de interesse, representadas por polígonos, de maneira eficiente.

Enquanto os problemas de TSP e TSPN são conhecidos por serem NP-difíceis \cite{tsp-applegate2006, tspn-iacopo-2011}, o TPP exige que a ordem de visita dos polígonos seja pré-definida, o que permite o desenvolvimento de algoritmos polinomiais para resolver o problema em certos casos. Em particular, Dror et al. (2003) \cite{tpp-dror2003} propuseram algoritmos eficientes para resolver o TPP em dois cenários distintos: o TPP Irrestrito, onde o caminho pode atravessar os polígonos, e o TPP Restrito, onde o caminho deve se manter dentro de "cercas" que delimitam os polígonos, como se a visita dos polígonos fosse feita por um robô que não pode sair de uma área segura que engloba os polígonos.

Nesse relatório, buscamos discutir e implementar os algoritmos propostos por Dror et al. (2003) \cite{tpp-dror2003}, apresentando uma visão prática do problema e suas soluções. Enquanto o artigo original foca bastante na análise teórica dos algoritmos, nosso objetivo é fornecer uma abordagem mais acessível e detalhada, enfatizando a implementação e os resultados experimentais. Vamos introduzir os conceitos fundamentais lentamente, junto de diversas visualizações, com o objetivo de facilitar o entendimento do leitor. Para quem deseja uma compreensão mais profunda dos aspectos teóricos, recomendamos a leitura do artigo original.

Além dessas duas variações, também buscamos explorar o caso onde os polígonos não são necessariamente convexos, o que adiciona uma camada extra de complexidade ao problema. Podemos mostrar que nesse caso, mesmo quando não temos "cercas", o problema é NP-difícil \cite[\textbf{Theorem 6.}]{tpp-dror2003}, no entanto, exploramos diferentes estratégias para lidar com essa complexidade adicional, partindo de uma enumeração completa e então removendo diversas soluções inviáveis através de uma estratégia de Branch and Bound, usando os algoritmos para o TPP Irrestrito como cálculo de limites inferiores. Dessa forma, conseguimos resolver instâncias razoavelmente grandes do problema com polígonos não convexos em um tempo aceitável. Esse caso não foi abordado no artigo original, na verdade, essa variação não parece ter sido estudada na literatura no momento da escrita deste relatório, por esse motivo consideramos que essa é uma contribuição original deste trabalho.

Uma parte central desse trabalho é a implementação prática dos algoritmos propostos, uma vez que isso distingue esse relatório do artigo original, que não inclui detalhes de implementação. Por esse motivo, disponibilizamos todo o código-fonte desenvolvido em um \href{https://github.com/YushiPy/TouringPolygons}{repositório público no GitHub}, permitindo que outros pesquisadores e entusiastas possam reproduzir os resultados apresentados aqui, bem como explorar e expandir o trabalho realizado. As implementações dos algoritmos foram realizadas tanto em \textit{Python} quanto em \textit{C++}, enquanto as visualizações utilizaram a biblioteca \textit{matplotlib} para \textit{Python} e a biblioteca \textit{Pygame} para criar um editor gráfico interativo. Além do código em si, também incluímos instruções detalhadas sobre como executar os algoritmos e reproduzir os experimentos apresentados neste relatório.

\section{O Problema de Visita de Polígonos Irrestrito}

Primeiramente vamos considerar o caso do Problema de Visita de Polígonos Irrestrito (TPP Irrestrito), onde não vamos impor restrições sobre o caminho que visita os polígonos. Esse problema foi originalmente descrito por Dror et al. (2003) \cite{tpp-dror2003}, que propuseram um algoritmo com complexidade \(O(n k \log(n / k))\) para resolver o problema, onde \(n\) é o número total de vértices dos polígonos e \(k\) é o número de polígonos. Buscamos apresentar uma versão prática desse algoritmo, focando no entendimento e implementação. O problema em si pode ser enunciado da seguinte maneira:

\begin{blockQuote}
	Dados dois pontos \(s, t \in \mathbb{R}^2\) e uma sequência de polígonos convexos disjuntos \(P_1, P_2, \ldots, P_k\), encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\) e toca cada polígono \(P_i\) em ordem em pelo menos um ponto, podendo atravessá-los.
\end{blockQuote}

\begin{wrapfigure}{r}{0.40\textwidth}
	\centering
	\includegraphics[width=0.39\textwidth]{Problem1Images/solution.png}
	\caption{Caminho mínimo para um caso de 3 polígonos.}
	\label{problem1-solution}
\end{wrapfigure}

A Figura~\ref{problem1-solution} ilustra um exemplo de entrada e a solução ótima para o problema para um caso com 3 polígonos. Temos \(s\) como o \textcolor[RGB]{0,128,0}{ponto verde}, \(t\) como o \textcolor[RGB]{255, 0, 0}{ponto vermelho} e os polígonos \(P_1, P_2\) e \(P_3\) como o \textcolor[RGB]{76, 146, 195}{triângulo azul}, o \textcolor[RGB]{255, 152, 62}{trapézio laranja} e o \textcolor[RGB]{86, 179, 86}{pentágono verde}, respectivamente. O caminho mínimo é representado pela \textcolor[RGB]{145, 41, 145}{linha roxa}.
% como o ponto verde, \(t\) como o ponto vermelho e os polígonos \(P_1, P_2\) e \(P_3\) como o triângulo azul, o trapézio laranja e o pentágono verde, respectivamente. O caminho mínimo é representado pela linha roxa.

No contexto de otimização geométrica, muitos problemas similares podem ser resolvidos usando uma técnica geral de computar um \textit{mapa de caminho mínimo}, que particiona o plano em regiões onde o comportamento do caminho mínimo é o mesmo. Para o nosso problema, qualquer solução deve tocar cada polígono \(P_i\) pela primeira vez em algum vértice ou aresta, assim, poderíamos agrupar os pontos de acordo com a sequência de vértices e arestas onde o caminho mínimo toca os polígonos. De fato, se calculássemos esse mapa, poderíamos responder consultas em tempo \(O(k + \log(n))\) \cite[\textbf{Theorem 5.}]{tpp-dror2003}, no entanto, no pior caso, esse mapa tem complexidade \(\Theta((n - k) 2 ^ k)\), ou seja, exponencial no número de polígonos \(k\) \cite[\textbf{Theorem 4.}]{tpp-dror2003}, tornando essa abordagem inviável.

Por esse motivo, usamos uma nova técnica baseada em subdividir o plano de acordo com \textit{mapas de último passo mínimo}, que para cada polígono \(P_i\), agrupa pontos \(p\) tais que o ponto \(q\) que antecede \(p\) do caminho mínimo partindo de \(s\), tocando \(P_1, \dots, P_i\) e chegando em \(p\) é um mesmo vértice ou uma mesma aresta. O conjunto dessas partições pode ser contruído em tempo \(O(nk \log(n / k))\), permitindo responder consultas em tempo \(O(k \log(n / k))\) \cite[\textbf{Theorem 1.}]{tpp-dror2003}. Dessa forma, podemos encontrar o caminho mínimo que visita todos os polígonos em tempo Polinomial.

\subsection{Condições de Otimalidade Local}

Primeiramente, definimos um \(i\)-path até \(p\) como um caminho mínimo que se inicia em \(s\) e toca os polígonos \(P_1, \ldots, P_i\) em ordem, terminando em um ponto \(p\). Podemos mostrar que tal \(i\)-path é \textbf{único} e assim otimalidade \textbf{local} implica otimalidade \textbf{global} \cite[\textbf{Lemma 1.}]{tpp-dror2003}. Note que um \(k\)-path até \(t\) é exatamente o caminho mínimo que buscamos.

Claramente, apenas precisamos considerar caminhos formados pela união de segmentos de reta entre \(s\) e \(t\). Ademais, tal caminho é \textit{localmente mínimo} se dobras ocorrem apenas no perímetro de cada polígono e, para cada dobra \(b \in \partial P_i\), mover \(b\) ligeiramente ao longo de qualquer direção na fronteira de \(P_i\) enquanto mantemos os outros pontos do caminho fixos aumenta o comprimento total do caminho. Isso implica que para pontos de dobra \(b\) no interior de uma aresta de \(P_i\), o ângulo de incidência do segmento que chega em \(b\) é igual ao ângulo de reflexão do segmento que sai de \(b\) (Lei da Reflexão). 

\begin{wrapfigure}{l}{0.60\textwidth}
	\centering

	\begin{minipage}{0.45\linewidth}
		\centering
		\includegraphics[width=\linewidth]{Problem1Images/local-optimality-edge.png}
		\caption{Condições de otimalidade em arestas.}
		\label{fig:problem1-local-optimality-edge}
	\end{minipage}
	\hfill
	\begin{minipage}{0.45\linewidth}
		\centering
		\includegraphics[width=\linewidth]{Problem1Images/local-optimality-vertex.png}
		\caption{Condições de otimalidade em vértices.}
		\label{fig:problem1-local-optimality-vertex}
	\end{minipage}

\end{wrapfigure}

Já para pontos de dobra que são vértices \(v = e^1 \cap e ^ 2\) de \(P_i\), as condições de otimalidade dizem que, assumindo que \(u\) é o ponto imediatamente antes de \(v\) no caminho, um segmento saindo de \(v\) deve estar contido no cone \(\gamma\) delimitado pelas reflexões \(r^1\) e \(r^2\) da direção \(\overrightarrow{uv}\) em relação às duas arestas \(e^1\) e \(e^2\). Intuitivamente, isso ocorre porque qualquer segmento saindo de \(v\) fora desse cone poderia ser substituído por um segmento refletido em uma das arestas, reduzindo o comprimento total do caminho. 

A Figura~\ref{fig:problem1-local-optimality-edge} ilustra a condição de otimalidade para dobras em arestas, na qual temos um caminho com os pontos \(a\), \(b\) e \(c\), onde \(b\) é um ponto de dobra em um parte interior da aresta \(e\). Observamos que o segmento \(\overline{ab}\) faz o mesmo ângulo com a aresta \(e\) que o segmento \(\overline{bc}\), assim, as condições de otimalidade estão satisfeitas. Já a Figura~\ref{fig:problem1-local-optimality-vertex} ilustra a condição de otimalidade para dobras em vértices, na qual temos um caminho partindo de \(s\) que chega em um vértice \(v\) de um polígono. Observamos que segmentos que saem de \(v\) devem estar dentro do cone \(\gamma\) delimitado pela reflexão do segmento \(\overline{sv}\) em relação às duas arestas \(e^1\) e \(e^2\) que se encontram em \(v\).

Adicionalmente, vale mencionar que se um caminho chega em um ponto \(p\) atravessando o interior de um polígono \(P_i\), então o último segmento desse caminho é localmente mínimo, pois a menor distância entre dois pontos é uma linha reta.

\subsection{Região de Primeiro Contato}

Para cada \(i \in \{1, \dots, k\}\), definimos a região de primeiro contato \(T_i\) de \(P_i\) como o conjunto de pontos \(p \in \partial P_i\) tais que o \((i - 1)\)-path até \(p\) toca \(P_i\) pela primeira vez em \(p\) após visitar os polígonos \(P_1, \dots, P_{i - 1}\). Podemos mostrar que essa região é contínua e é delimitada por vértices de \(P_i\) \cite[\textbf{Lemma 2.}]{tpp-dror2003}.

Sabemos que \(i\)-paths localmente mínimos só podem sair de \(T_i\) de maneiras específicas, continuando em linha reta ou refletindo de maneira apropriada, adicionalmente, como otimalidade local implica otimalidade global, se existe um caminho localmente ótimo até \(p\), então esse é o caminho mínimo até \(p\). 

\begin{wrapfigure}{r}{0.60\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.60\textwidth]{Problem1Images/local-optimality-polygon.png}
	\caption{Caminhos mínimos visitando um polígono.}
	\label{problem1-local-optimality-polygon}

\end{wrapfigure}

Assim, seja \(p \in \mathbb{R} ^ 2\), \(v\) um vértice de \(P_i\) tal que \(v \in T_i\) e \(u\) o ponto que precede \(v\) no \((i - 1)\)-path até \(v\). Pelas condições de otimalidade local, sabemos que o segmento \(\overline{vp}\) só pode ser parte de um \(i\)-path até \(p\) se o o segmento \(\overline{vp}\) está contido dentro do cone \(\gamma\) formado pela reflexão do vetor \(\overrightarrow{uv}\) em relação às duas retas que contém cada uma das duas arestas que se encontram em \(v\). Como as condições de otimalidade são tanto necessárias quanto suficientes, podemos afirmar que se \(p\) pertence ao cone \(\gamma\), então o caminho formado pelo \((i - 1)\)-path até \(v\) seguido do segmento \(\overline{vp}\) é o \(i\)-path até \(p\).

Ademais, seja \(p \in \mathbb{R} ^ 2\) e vamos assumir que o \(i\)-path até \(p\) tem uma dobra \(b\) na parte interior de uma aresta \(e\) de \(P_i\) limitada pelos vértices \(v^1\) e \(v^2\) tais que \(v^1, v^2 \in T_i\). Seja \(u\) o ponto que precede \(b\) no \((i - 1)\)-path até \(b\). Pelas condições de otimalidade local, sabemos que o segmento \(\overline{bp}\) só pode ser parte de um \(i\)-path até \(p\) se o ângulo de incidência do segmento \(\overline{ub}\) com a aresta \(e\) for igual ao ângulo de reflexão do segmento \(\overline{bp}\) com a aresta \(e\). Isso é possível se e somente se \(p\) está entre as reflexões dos raios que chegam em \(v^1\) e \(v^2\) em relação à aresta \(e\) e se \(p\) está do lado "externo" da aresta \(e\) (ou seja, o segmento \(\overline{bp}\) não atravessa o interior de \(P_i\)). Como as condições de otimalidade são tanto necessárias quanto suficientes, podemos afirmar que se \(p\) satisfaz essas condições, então o caminho formado pelo \((i - 1)\)-path até \(b\) seguido do segmento \(\overline{bp}\) é o \(i\)-path até \(p\).

Finalmente, se \(p\) não satisfaz nenhuma das condições anteriores, então o \(i\)-path até \(p\) deve atravessar o interior de \(P_i\) para chegar em \(p\). Nesse caso, o \(i\)-path até \(p\) é exatamente o \((i - 1)\)-path \(p\), pois esse caminho automaticamente visita \(P_i\) ao atravessá-lo. A Figura~\ref{problem1-local-optimality-polygon}.

A Figura~\ref{problem1-local-optimality-polygon} ilustra essas três possibilidades um caso de um único polígono. Temos que o ponto \(p^1\) está no cone do vértice \(v^1\), portanto, o \(1\)-path até \(p^1\) parte de \(s\), chega em \(v^1\) e segue em linha reta até \(p^1\). Já o ponto \(p^2\) está entre as reflexões dos raios que chegam em \(v^2\) e \(v^3\) em relação à aresta \(e^2\), assim, o \(1\)-path até \(p^2\) parte de \(s\), chega em um ponto \(b\) na aresta \(e^2\) e reflete até \(p^2\). Finalmente, o ponto \(p^3\) não satisfaz nenhuma das condições anteriores, portanto, o \(1\)-path até \(p^3\) parte de \(s\) e chega diretamente em \(p^3\), atravessando o interior do polígono.

\subsection{O Mapa de Último Passo Mínimo}

As ideias das duas últimas seções sugerem uma maneira de particionar o plano de acordo com o último passo do \(i\)-path até cada ponto \(p\). Para cada polígono \(P_i\), podemos particionar o plano em regiões onde o último passo do \(i\)-path até qualquer ponto \(p\) dentro dessa região é um mesmo vértice de \(P_i\), uma mesma aresta de \(P_i\) ou atravessa o interior de \(P_i\). Denotamos essa partição por \(S_i\) e chamamos de \textbf{regiões de vértice}, \textbf{regiões de aresta} e \textbf{região de travessia} as regiões onde o último passo do \(i\)-path é um vértice, uma aresta ou atravessa o interior de \(P_i\), respectivamente.

\begin{wrapfigure}{l}{0.60\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.6\textwidth]{Problem1Images/first-contact.png}
	\caption{Mapa de último passo mínimo para um polígono.}
	\label{problem1-last-step-map}

\end{wrapfigure}

Ilustramos essa ideia na Figura~\ref{problem1-last-step-map}, onde temos o polígono \(P_1\) em laranja, as regiões de vértice em vermelho, aresta em verde e travessia em ciano, também colorimos \(T_1\) em azul. Note que para cada vértice \(v \in T_1\) de \(P_1\), temos que sua região de vértice é o cone formado pelas reflexões do vetor \(\overrightarrow{sv}\) em relação às duas arestas que se encontram em \(v\). Já para cada aresta \(e \subseteq T_1\) de \(P_1\), temos que sua região de aresta é o conjunto de pontos entre as reflexões dos raios que chegam nos dois vértices que limitam \(e\) em relação à aresta \(e\) e do lado externo de \(e\). Finalmente, a região de travessia é o restante do plano.

Para construir \(S_i\), começamos determinando \(T_i\), detalhamos mais a frente como fazer isso de maneira eficiente. Em seguida, para cada vértice \(v \in T_i\) de \(P_i\), construímos sua região de vértice calculando o ponto \(u\) que precede \(v\) no \((i - 1)\)-path até \(v\) e então calculando as reflexões do vetor \(\overrightarrow{uv}\) em relação às duas arestas que se encontram em \(v\). Uma vez que temos as regiões de vértice, não é necessário construir as regiões de aresta explicitamente, pois elas podem ser derivadas das regiões de vértice adjacentes e da aresta correspondente. Finalmente, a região de travessia é simplesmente o complemento das regiões de vértice e aresta.

Uma vez que definimos a partição \(S_i\) do plano, conseguimos determinar o \(i\)-path até qualquer ponto \(p\) de maneira eficiente. Basta determinar em qual região de \(S_i\) o ponto \(p\) está e então aplicar as condições de otimalidade local para construir o \(i\)-path até \(p\) de acordo com o último passo do caminho. Ademais, vamos expor adiante como localizar um ponto \(p\) em \(S_i\) em tempo \(O(\log(n))\), permitindo responder consultas de \(i\)-paths em tempo \(O(i \log(n))\).

A partir dessas ideias, note que primeiro contruímos a partição \(S_1\) usando apenas o ponto \(s\). Em seguida, podemos usar \(s\) e \(S_1\) para construir \(S_2\), depois usar \(s\), \(S_1\) e \(S_2\) para construir \(S_3\) e assim por diante, até construirmos \(S_k\). Finalmente, podemos usar \(s\), \(S_1, S_2, \ldots, S_k\) para determinar o \(k\)-path até o ponto \(t\), que é exatamente o caminho mínimo que buscamos. A Figura~\ref{problem1-partitions} ilustra as partições \(S_1, S_2\) e \(S_3\) para o exemplo da Figura~\ref{problem1-solution}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Problem1Images/partitions.png}
	\caption{Partição do plano para cada polígono do exemplo anterior.}
	\label{problem1-partitions}
\end{figure}

Dessa forma, concluímos o embasamento teórico necessário para implementar o algoritmo proposto por Dror et al. (2003) \cite{tpp-dror2003} para resolver o TPP Irrestrito. Nas próximas seções, vamos discutir em detalhe como implementar cada parte do algoritmo e as subrotinas necessárias para construir as partições \(S_i\) de maneira eficiente.

\subsection{Determinando a Região de Primeiro Contato}

Como discutido acima, a região de primeiro contato \(T_i\) de um polígono \(P_i\) é o conjunto de pontos \(p \in \partial P_i\) tais que o \((i - 1)\)-path até \(p\) toca \(P_i\) pela primeira vez em \(p\). Adicionalmente, sabemoos que \(T_i\) é contínua, delimitada por vértices de \(P_i\) e sempre contém pelo menos uma aresta de \(P_i\) e nunca contém o polígono inteiro. \textcolor{red}{Tentar provar isso...}

É importante ressaltar que apenas determinar quais vértices de \(P_i\) pertencem a \(T_i\) não é suficiente, pois \(T_i\) pode conter todos os vértices de \(P_i\) e ainda assim ter uma aresta que não pertence a \(T_i\). Por esse motivo, buscamos determinar o primeiro e o último vértice de \(P_i\) que pertencem a \(T_i\) e então considerar apenas as arestas entre esses dois vértices. 

Primeiramente, sejam \(b, v, a\) vértices consecutivos de \(P_i\) em sentido anti-horário (\(b\) para \textit{before} e \(a\) para \textit{after}) e seja \(u\) o ponto que precede \(v\) no \((i - 1)\)-path até \(v\). Usando as condições de otimalidade de primeira ordem, podems concluir que se as direções \(\overrightarrow{b v}\) e \(\overrightarrow{v a}\) estão em lados opostos do vetor \(\overrightarrow{uv}\), então \(v\) é um dos extremos de \(T_i\), mais especificamente, se \(\overrightarrow{b v}\) está no lado anti-horário de \(\overrightarrow{uv}\), então \(v\) é o primeiro vértice de \(T_i\), caso contrário, é o último vértice de \(T_i\). 

Enquanto a maioria dessas operações são simples verificações geométricas baseadas em produtos vetoriais, precisamos de uma maneira eficiente de determinar o ponto \(u\) que precede \(v\) no \((i - 1)\)-path até \(v\). No momento, só sabemos responder essa consulta para um \(0\)-path, que é simplesmente o ponto \(s\). No entanto, como discutimos acima, isso é suficiente para construir \(T_1\) e \(S_1\), os quais nos permitem responder consultas de \(1\)-paths. Assim, podemos usar \(s\), \(T_1\) e \(S_1\) para construir \(T_2\) e \(S_2\), os quais nos permitem responder consultas de \(2\)-paths. Repetindo esse processo, conseguimos construir \(T_i\) e \(S_i\) para qualquer \(i \in \{1, \ldots, k\}\).

Por esse motivo, vamos criar uma função \(\text{Consulta}(p, s, (P_1, \dots, P_i), (T_1, \dots, T_i), (S_1, \dots, S_i))\) que dado um ponto \(p\), o ponto inicial \(s\), os polígonos \(P_1, \dots, P_i\), as regiões de primeiro contato \(T_1, \dots, T_i\) e as partições \(S_1, \dots, S_i\), retorna o \(i\)-path até \(p\). Usando essa função, podemos determinar o ponto \(u\) que precede um vértice \(v\) no \((i - 1)\)-path até \(v\) simplesmente chamando \(\text{Consulta}(v, s, P_1, \dots, P_{i - 1}, T_1, \dots, T_{i - 1}, S_1, \dots, S_{i - 1})\) e então retornando o penúltimo ponto do caminho retornado. Vamos detalhar a implementação dessa função mais adiante, mas por enquanto, assumimos que essa função está disponível e funciona corretamente.

Utilizando essa função e as ideias acima, implementamos o Algoritmo~\algref{problem1-first-contact} para determinar a região de primeiro contato \(T_i\), que retorna uma lista de vértices consecutivos de \(P_i\) que pertencem a \(T_i\) e tais que o primero e o último vértice dessa lista são exatamente os extremos de \(T_i\).

\begin{algorithm}
\alglabel{problem1-first-contact}
\caption{Região de Primeiro Contato}
\Input{\(s\), \((P_1, \dots, P_i)\), \((T_1, \dots, T_{i - 1})\), \((S_1, \dots, S_{i - 1})\)}
\Output{\(T_i\) na forma de uma lista de vértices consecutivos de \(P_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\(i \leftarrow -1\) // Índice do primeiro vértice de \(T_i\) \\
\(j \leftarrow -1\) // Índice do último vértice de \(T_i\) \\

\For{\(v\) vértice de \(P_i\)} {

	\(b \leftarrow\) vértice antes de \(v\) em \(P_i\) \\
	\(a \leftarrow\) vértice depois de \(v\) em \(P_i\) \\
	\(path \leftarrow \text{Consulta}(v, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	\(u \leftarrow\) penúltimo ponto de \(path\) \\

	\(d^1 \leftarrow v - b\) \\
	\(d^2 \leftarrow a - v\) \\
	\(d^u \leftarrow u - v\) \\

	\If {\(d ^ u \times d ^ 1 \ge 0 \land d ^ u \times d ^ 2 \le 0\)} {
		\(i \leftarrow\) índice de \(v\) em \(P_i\) \\
	}
	\If {\(d ^ u \times d ^ 1 \le 0 \land d ^ u \times d ^ 2 \ge 0\)} {
		\(j \leftarrow\) índice de \(v\) em \(P_i\) \\
	}
}

\Return {vértices de \(P_i\) entre os índices \(i\) e \(j\) (inclusive)}

\end{algorithm}

\subsection{Construindo as Partições}

Uma vez que determinamos \(T_i\), o próximo passo é contruir a partição \(S_i\) do plano. Conforme discutido acima, para representar \(S_i\), precisamos apenas contruir as regiões de vértice, pois as regiões de aresta podem ser derivadas das regiões de vértice adjacentes e a região de travessia é simplesmente o complemento das regiões de vértice e aresta. 

Pelas condições de otimalidade local, sabemos que um ponto \(p\) pertence à região de vértice associada a um vértice \(v\) de \(P_i\) se \(v \in T_i\) e se o segmento \(\overline{vp}\) está contido no cone formado pelas reflexões do vetor \(\overrightarrow{uv}\) em relação às retas contendo as cada uma das duas arestas que se encontram em \(v\), onde \(u\) é o ponto que precede \(v\) no \((i - 1)\)-path até \(v\). Assim, para construir as regiões de vértice, precisamos apenas calcular essas reflexões para cada vértice \(v \in T_i\). Também devemos notar que uma das arestas incidentes a \(v\) pode não estar na região de primeiro contato, nesse caso, seria impossível refletir o vetor em relação a reta que contem essa aresta, assim, consideramos o raio seguindo a direção original de \(\overrightarrow{uv}\).

Para refletir um vetor \(d\) em relação a uma aresta \((v^1, v^2)\), podemos usar o Algoritmo~\algref{problem1-reflect-direction}, que calcula a direção refletida de \(d\) em relação à reta que contém a aresta \((v^1, v^2)\).

Juntado as ideias acima, implementamos o Algoritmo~\algref{problem1-vertex-region} para construir as regiões de vértice \(S_i\) de \(P_i\), que retorna \(S_i\) como uma sequência de pares ordenados de direções associadas aos vértices de \(T_i\).

\begin{algorithm}
\alglabel{problem1-reflect-direction}
\caption{RefleteDireção}
\Input{\(d\), \(v^1\), \(v^2\)}
\Output{Direção refletida de \(d\) em relação à reta que contém a aresta \((v^1, v^2)\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\(\omega \leftarrow v^2 - v^1\) \\
\(\omega \leftarrow \omega / ||\omega||\) // Normalizar \(\omega\) \\
\(d_{\perp} \leftarrow (-\omega_2, \omega_1)\) // Vetor perpendicular a \(\omega\) \\
\(proj_{\perp} \leftarrow \anglebrackets{d, d_{\perp}}\) \\
\Return {\(d - 2 \anglebrackets{proj_{\perp}, d_{\perp}}\)} // Refletir \(d\) em relação a reta

\end{algorithm}

\begin{algorithm}
\alglabel{problem1-vertex-region}
\caption{Região de Vértice}
\Input{\(s\), \((P_1, \dots, P_i)\), \((T_1, \dots, T_i)\), \((S_1, \dots, S_{i - 1})\)}
\Output{\(S_i\) como uma sequência de pares ordenados de direções associadas aos vértices de \(T_i\).}

\vspace{0.3em}
\hrule
\vspace{0.3em}

\(S_i \leftarrow \emptyset\)

\For {\(v\) vértice de \(T_i\)} {

	\(\text{path} \leftarrow \text{Consulta}(v, s, (P_1, \dots, P_{i - 1}), (T_1, \dots, T_{i - 1}), (S_1, \dots, S_{i - 1}))\) \\
	\(u \leftarrow\) penúltimo ponto de \(\text{path}\) \\
	\(d \leftarrow v - u\) \\

	\(v^1 \leftarrow\) vértice antes de \(v\) em \(P_i\) \\
	\(v^2 \leftarrow\) vértice depois de \(v\) em \(P_i\) \\

	\If {\( (v^1, v) \in T_i\)} {
		\(d^1 \leftarrow \text{RefleteDireção}(d, v^1, v)\) \\
	}
	\Else {
		\(d^1 \leftarrow d\)
	}

	\If {\( (v, v^2) \in T_i\)} {
		\(d^2 \leftarrow \text{RefleteDireção}(d, v, v^2)\)
	}
	\Else {
		\(d^2 \leftarrow d\)
	}

	// Adicionar região de vértice associada a \(v\) em \(S_i\) \\
	\(S_i \leftarrow S_i \oplus (d^1, d^2)\)
}

\Return {\(S_i\)}

\end{algorithm}

\subsection{Localizando Pontos na Partição}

Gostariamos de responder consultas do tipo \(\text{Query}(p, i)\) de maneira eficiente. Para isso, precisamos ser capazes de localizar o ponto \(p\) na partição \(S_i\) de maneira eficiente, ou seja, determinar se \(p\) pertence a uma região de vértice, região de aresta ou região de atravessar e, em caso positivo, qual região.

Esse processo não é trivial, principalmente se desejamos fazer isso de maneira eficiente. Para tal, primeiro vamos considerar dois problemas mais simples: determinar se \(p\) pertence a uma região de vértice e determinar se \(p\) pertence a uma região de aresta.

\subsubsection{Verificando Regiões de Vértice}

Primeiramente vamos implementar um procedimento auxiliar \algref{PontoEmVértice} que verifica se um ponto \(p\) está em uma região de vértice associada a um vértice \(v\) determinada pelo par \( (d_{\text{prev}},d_{\text{next}}) \). Basicamente, temos dois casos, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\) (considerando o sentido anti-horário):

\begin{itemize}

	\item Ângulo \(\le 180 ^ \circ\): Nesse caso, \(p\) deve estar à esquerda de \(d_{\text{prev}}\) e à direita de \(d_{\text{next}}\).

	\item Ângulo \(> 180 ^ \circ\): Nesse caso, \(p\) deve estar à direita de \(d_{\text{prev}}\) ou à esquerda de \(d_{\text{next}}\).

\end{itemize}

Podemos usar produtos vetoriais para determinar a posição relativa de \(p\) em relação às direções \(d_{\text{prev}}\) e \(d_{\text{next}}\), assim como o ângulo entre essas direções. Usando essas ideias, implementamos o procedimento no algoritmo \algref{PontoEmVértice}.

\begin{algorithm}
\alglabel{PontoEmVértice}
\caption{PontoEmVértice(\(p\), \(v\), \(d_{\text{prev}}\), \(d_{\text{next}}\)) \\
Verifica se o ponto \(p\) está na região de vértice associada ao vértice \(v\) delimitada pelas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\)}

\(c_1 \leftarrow (d_{\text{prev}} \times (p - v) \ge 0)\) \\
\(c_2 \leftarrow (d_{\text{next}} \times (p - v) \le 0)\)

\If {\(d_{\text{prev}} \times d_{\text{next}} \ge 0\)} {
	\Return{} \(c_1 \land c_2\)
	}
\Else {
	\Return{} \(c_1 \lor c_2\)
}

\end{algorithm}

\subsubsection{Verificando Regiões de Aresta}

Uma vez que conseguimos verificar se um ponto pertence a uma região de vértice, podemos usar essa funcionalidade para verificar se um ponto pertence a uma região de aresta. 

\begin{wrapfigure}{l}{0.69\textwidth} % 'r' for right, 'l' for left
	\centering
	\vspace{-1em} % adjust vertical alignment if needed
	\includegraphics[width=0.68\textwidth]{Problem1Images/edge-regions.png}
	\caption{Casos possíveis para região de aresta.}
	\label{problem1-edge-regions}
\end{wrapfigure}

Esse problema é mais complexo, uma vez que existem diferentes casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\). Esses casos não aparecem explicitamente na partição \(S_i\), na verdade apenas o primeiro caso aparece. No entanto, vamos usar esses outros casos adicionais para otimizar a localização de pontos na partição posteriormente, permitindo complexidade \(\log(\abs{P_i})\) para detecção.

Essencialmente existem 4 casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\). A Figura \ref{problem1-edge-regions} ilustra esses casos. Para sabermos com qual caso estamos lidando, definimos \(w = v - u\) e calculamos os produtos vetoriais \(c_1 = w \times d_{\text{prev}}\) e \(c_2 = w \times d_{\text{next}}\). Agora, temos os seguintes casos:

\begin{itemize}

	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado negativo}, que é o caso tradicional que aparece na partição \(S_i\). Nesse caso, verificamos se \(p\) está entre as semi-retas e a aresta \((u, v)\) usando produtos vetoriais.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado negativo e aresta posterior no lado positivo}, o \textit{Caso 1} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_{\text{prev}}, u - v)\) e \((v, u - v, d_{\text{next}})\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado positivo e aresta posterior no lado negativo}, o \textit{Caso 2} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_{\text{prev}}, v - u)\) e \((v, v - u, d_{\text{next}})\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado positivo}. Nesse caso, simplesmente verificamos se o ponto não pertence ao complemento da região, ou seja, verificamos se \(p\) não pertence à região de aresta definida por \((v, u, d_{\text{next}}, d_{\text{prev}})\).
\end{itemize}

Dessa forma, conseguimos verificar se um ponto pertence a uma região de aresta usando o procedimento de verificação de regiões de vértice. Agora podemos implementar o procedimento completo no algoritmo \algref{PontoEmAresta}.

\begin{algorithm}
\alglabel{PontoEmAresta}
\caption{PontoEmAresta(\(p\), \(u\), \(v\), \(d_{\text{prev}}, d_{\text{next}}\)) \\
Verifica se o ponto \(p\) está na região de aresta associada à aresta \(e = (u, v)\) delimitada pelas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\)}

// Se vértices são muito próximos, tratamos a região de aresta \\
// como uma região de vértice. \\
\If {\(\abs{u - v} < 10 ^ {-8}\)} {
	\Return {} PontoEmVértice(\(p\), \(v\), \(d_{\text{next}}\), \(d_{\text{prev}}\))
}

\(w \leftarrow v - u\) \\
\(c_1 \leftarrow d_{\text{prev}} \times w\) \\
\(c_2 \leftarrow w \times d_{\text{next}}\) \\

\If {\(c_1 \le 0 \land c_2 \le 0\)} {
	\Return{} \((d_{\text{prev}} \times (p - u) \ge 0) \land ((p - u) \times d_{\text{next}} \le 0) \land ((v - u) \times (p - u) \le 0)\)
}
\ElseIf {\(c_1 \le 0 \land c_2 > 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_{\text{prev}}\), \(u - v\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(u - v\), \(d_{\text{next}}\))
}
\ElseIf {\(c_1 > 0 \land c_2 \le 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_{\text{prev}}\), \(v - u\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(v - u\), \(d_{\text{next}}\))
}
\Else {
	\Return{} \(\lnot\) PontoEmAresta(\(p\), \(v\), \(u\), \(d_{\text{next}}\), \(d_{\text{prev}}\))
}

\end{algorithm}

\subsubsection{Localização Eficiente de Pontos na Partição}

Agora que sabemos como verificar se um ponto pertence a uma região de vértice ou de aresta, podemos usar essas funcionalidades para localizar um ponto \(p\) na partição \(S_i\). Uma abordagem ingênua seria iterar sobre todas as regiões de vértice e aresta, verificando se \(p\) pertence a alguma delas. Isso funcionaria, no entanto, essa abordagem tomaria tempo \(O(\abs{P_i})\), o que é muito lento.

Por esse motivo, desejamos explorar a ideia de busca binária para resolver o problema. Primeiramente, vamos assumir que o ponto não pertence ao polígono \(P_i\), isso vale como suposição inicial dos polígonos serem disjuntos e os pontos \(s\) e \(t\) estarem fora dos polígonos. Ainda assim, se desejássemos evitar essa suposição, poderíamos simplesmente verificar se o ponto está dentro do polígono \(P_i\) usando um teste de ponto em polígono antes de localizar o ponto na partição, o é um problema clássico que leva tempo \(O(\log(\abs{P_i}))\).

Uma questão que diferencia nosso problema de uma busca binária tradicional é que as regiões são circulares. Assim, o primeiro passo é verificar se o ponto pertence à região entre o último e o primeiro vértice de \(P_i\). Se sim, retornamos essa região. Caso contrário, reduzimos o problema para uma lista linear de regiões.

Outra diferença que precisamos considerar é que nossa entrada contém dois tipos de regiões: regiões de vértice e regiões de aresta. Para lidar com isso, podemos tratar regiões de vértice como regiões de aresta degeneradas, onde a aresta tem comprimento zero. Dessa forma, podemos aplicar o mesmo raciocínio para ambos os tipos de regiões, lidando com uma lista de \(2 \abs{P_i} - 1\) regiões de aresta, uma vez que já eliminamos a última. Note que a implementação de PontoEmAresta já lida com esse caso especial.

Finalmente, podemos implementar a busca binária propriamente dita. A ideia é manter dois índices \(l\) e \(r\) que representam o intervalo atual de regiões que estamos considerando. Inicialmente, definimos \(n = \abs{P_i}\), \(l = 0\) e \(r = 2n - 1\). Nos baseamos na ideia de que apenas as regiões após \(l\) e antes de \(r\) podem conter o ponto \(p\), ambos limites inclusivos. 

Enquanto \(l + 1 \ne r\), calculamos o índice médio \(m = \floor{(l + r) / 2}\) e verificamos se o ponto \(p\) pertence à região de aresta entre \(l\) e \(m\). Se estiver, atualizamos \(r = m\), caso contrário, atualizamos \(l = m\), isso vale pois \(P_i\) é convexo e a região de aresta entre \(l\) e \(m\) cobre todas as regiões entre \(l\) e \(m\) e nenhuma região entre \(m\) e \(r\).

Repetindo isso até que \(l + 1 = r\), sabemos que o ponto \(p\) pertence à região de aresta entre \(l\) e \(r\). Finalmente, retornamos essa região, vamos codificar essa região como um inteiro que representa o índice da região.

Essa codificação segue a seguinte lógica: regiões de vértice são representadas por índices pares, onde o índice \(2j\) representa a região de vértice associada ao \(j\)-ésimo vértice de \(P_i\). Regiões de aresta são representadas por índices ímpares, onde o índice \(2j + 1\) representa a região de aresta entre o \(j\)-ésimo e o \((j + 1)\)-ésimo vértice de \(P_i\). Note que a região entre o último e o primeiro vértice é representada pelo índice \(2 \abs{P_i} - 1\).

Implementamos essa ideia no algoritmo \algref{LocalizaRegião}, que recebe um ponto \(p\) e um polígono \(P_i\) e retorna o índice da região de \(S_i\) que contém \(p\).

\begin{algorithm}
\alglabel{LocalizaRegião}
\caption{LocalizaRegião(\(p\), \(P_i\)) \\
Localiza o ponto \(p\) na partição do polígono \(P_i\)}

\Function{getDireção(\(i\))} {
	\If {\(i \pmod 2 = 0\)} {
		\Return{} direção anterior associada ao vértice \(\floor{i / 2}\) de \(P_i\)
	}
	\Else {
		\Return{} direção anterior associada ao vértice \(\floor{i / 2}\) de \(P_i\)
	}
}

\Function{pertence(\(i\), \(j\))} {

	\(v_1 \leftarrow \) Vértice \(\floor{i / 2}\) do polígono \(P_i\) \\
	\(v_2 \leftarrow \) Vértice \(\floor{j / 2}\) do polígono \(P_i\) \\
	\(d_{\text{prev}} \leftarrow\) getDireção(\(i\)) \\
	\(d_{\text{next}} \leftarrow\) getDireção(\(j\)) \\

	\Return{} PontoEmAresta(\(p\), \(v_1\), \(v_2\), \(d_{\text{prev}}\), \(d_{\text{next}}\))
}

\(l \leftarrow 0\) \\
\(r \leftarrow 2 \abs{P} - 1\) \\

\If {pertence(\(r\), \(0\))} {
	\Return{} \(r\) // Ponto pertence à região entre o último e o primeiro vértice
}

\While {\(l + 1 \ne r\)} {

	\(m \leftarrow \floor{(l + r) / 2}\) \\
	
	\If {pertence(\(l\), \(m\))} {
		\(r \leftarrow m\)
	}
	\Else {
		\(l \leftarrow m\)
	}
}

\Return{} \(l\) // Ponto pertence à região entre \(l\) e \(r\)

\end{algorithm}

\subsection{Respondendo Consultas}

Finalemnte, podemos descrever como responder consultas do tipo \(\text{Query}(p, i)\) usando as partições \(S_i\) que construímos anteriormente. O procedimento utilizado é recursivo, assim, primeiro definimos o caso base, que é \(\text{Query}(p, 0) = s\), uma vez que um \(0\)-path não precisa tocar em nenhum polígono, assim, o menor caminho é uma linha reta de \(s\) até \(p\).

Para \(i > 0\), primeiramente determinamos a região \(R\) de \(S_i\) que contém \(p\). Uma vez que sabemos qual região contém \(p\), podemos responder a consulta dependendo do tipo de região:

\begin{itemize}

	\item Região de Vértice: Seja \(R = (v, d_{\text{prev}}, d_{\text{next}})\). Nesse caso, o \(i\)-path até \(p\) deve passar pelo vértice \(v\), tocando o polígono \(P_i\). Assim, temos que \(\text{Query}(p, i) = v\).
	
	\item Região de Aresta: Seja \(R = (u, v, d_{\text{prev}}, d_{\text{next}})\). Nesse caso, o \(i\)-path até \(p\) deve passar por algum ponto \(q\) da aresta \(e = (u, v)\), tocando o polígono \(P_i\). Para calcular \(q\), primeiro determinamos \(q' = \text{Query}(p', i - 1)\), onde \(p'\) é a reflexão de \(p\) em relação à aresta \(e\). 
	Agora, dizemos que \(q\) é a interseção entre \(\overline{q'p'}\) e a aresta \(e\). Finalmente, respondemos \(\text{Query}(p, i) = q\).

	\item Região de Atravessa: Seja \(R\) a região de atravessa. Nesse caso, o \(i\)-path até \(p\) automaticamente atravessa o polígono \(P_i\) em algum ponto. Portanto, podemos simplesmente responder \(\text{Query}(p, i) = \text{Query}(p, i - 1)\).

\end{itemize}

Para determinar o ponto de interseção entre o segmento \(\overline{q'p'}\) e a aresta \(e\), implementamos o procedimento \algref{InterseçãoRetas}, que calcula a interseção entre duas retas dadas por dois pontos e suas direções. A demonstração desse procedimento é simples e pode ser feita algebricamente, mas não é o foco desse relatório. Também estamos assumindo que as retas não são paralelas, o que é garantido pela construção do algoritmo.

Agora podemos usar essas ideias para implementar o procedimento completo de resposta a consultas na forma do algoritmo \algref{Query}.

\begin{algorithm}
\alglabel{InterseçãoRetas}
\caption{InterseçãoRetas(\(s, d, s', d'\)) \\ Calcula a interseção entre as retas definidas por pontos \(s + td\) e \(s' + t'd'\), onde \(t, t' \in \mathbb{R}\)}

\(\Delta s \leftarrow s - s'\) \\
\(r \leftarrow (\Delta s \times d') / (d \times d')\)

\Return{} \(s + r d\) // Ponto de interseção

\end{algorithm}

\begin{algorithm}
\alglabel{Query}
\caption{Query(\(p, i\)) \\ Responde a consulta \(\text{Query}(p, i)\)}

\If {\(i = 0\)} {
	\Return{} \(s\) // Caso base
}

\(R \leftarrow\) LocalizaRegião(\(p\), \(P_i\)) \\
\(j \leftarrow \floor{R / 2}\)

\ \\
// Região de vértice \\
\If {\(R \pmod 2 = 0\)} {
	\Return {} Vértice \(j\) do polígono \(P_i[j]\)
}
\ \\
// Região de atravessa \\
\If {Aresta \(j\) de \(P_i\) não pertence à \(T_i\)} {
	\Return{} Query(\(p, i - 1\)) // Região de atravessa
}
\ \\
// Região de aresta \\
\(u \leftarrow \) Vértice \(j\) de \(P_i\) \\
\(v \leftarrow \) Vértice que segue \(u\) em \(P_i\) \\

\(p' \leftarrow u + \text{RefleteDireção}((p - u), u, v)\) \\
\(q' \leftarrow \text{Query}(p', i - 1)\) \\
\(m \leftarrow \text{InterseçãoDeRetas}(p', q' - p', u, v - u)\) \\

\Return{} \(m\) // Ponto de interseção

\end{algorithm}

\subsection{Calculando o Caminho Mínimo}

Agora que sabemos como responder consultas do tipo \(\text{Query}(p, i)\), calcular o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\) é trivial.

Pela definição de Query, sabemos que o menor caminho que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_k\) e termina em \(t\) deve ter como penúltimo ponto \(q_k = \text{Query}(t, k)\). Ademais, o caminho que toca os polígonos \(P_1, \dots, P_{k - 1}\) e termina em \(q_k\) deve ter como penúltimo ponto \(q_{k - 1} = \text{Query}(q_k, k - 1)\). Repetindo esse raciocínio, chegamos até o ponto inicial \(s\).

Usando essa lógica e juntando as implementações anteriores no algoritmo \algref{CaminhoMínimo}, podemos calcular o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\).

\begin{algorithm}
\alglabel{CaminhoMínimo}
\caption{CaminhoMínimo(\(s, t, P_1, \dots, P_k\)) \\ Calcula o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\)}

\If {\(k = 0\)} {
	\Return{} [\(s, t\)] // Caso base: caminho direto de \(s\) até \(t\)
}

\For {\(i \leftarrow 1\) até \(k\)} {
	\(T_i \leftarrow\) ArestasVisíveis(\(P_i\)) \\
	\(S_i\) \(\leftarrow\) ConstróiRegiõesDeVértice(\(P_i\)) \\
}

caminho \(\leftarrow []\) // Lista vazia para armazenar o caminho \\
\(p \leftarrow t\) // Começamos do ponto final \(t\) \\

\For {\(i \leftarrow k\) até \(1\)} {
	\(q \leftarrow \text{Query}(p, k)\) // Penúltimo ponto do \(k\)-path até \(p\) \\
	// Verificamos se os pontos \(p\) e \(q\) são distintos devido à regiões de atravessar \\
	\If {\(\abs{q - p} > 10 ^ {-8}\)} {
		caminho.\text{append}(\(p\)) // Adiciona \(p\) ao caminho \\
	}
	\(p \leftarrow q\) // Atualiza \(p\) para o próximo ponto \\
	\(k \leftarrow k - 1\) // Decrementa \(k\)
}

caminho.\text{append}(\(s\)) // Adiciona o ponto inicial \(s\) \\
caminho.\text{reverse}() // Inverte a lista para obter o caminho correto \\

\Return{} caminho

\end{algorithm}

\subsection{Análise de Complexidade}

Nessa seção, vamos analisar a complexidade do algoritmo completo. Primeiramente, a função LocalizaRegião leva tempo \(O(\log(\abs{P_i}))\) para localizar um ponto na partição \(S_i\), uma vez que usa busca binária. Ademais, a função Query faz uma chamada recursiva para \(i - 1\) em cada nível de recursão, resultando em \(i\) níveis de recursão. Assim, o tempo total para responder uma consulta \(\text{Query}(p, i)\) é \(O(i \log(\abs{P_i}))\).

\begin{itemize}
	
	\item RefleteDireção(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmVértice(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmAresta(\(\dots\)): \(O(1)\), pois faz um número constante de operações e chamadas para PontoEmVértice.
	
	\item LocalizaRegião(\(P_i\), \(\dots\)): \(O(\log \abs{P_i})\), pois usa busca binária em \(2 \abs{P_i} - 1\) regiões.
	
	\item Query\((i, \dots)\): Fazemos no máximo \(i\) chamadas recursivas, cada uma chama LocalizaRegião(\(P_i\), \(\dots\)) uma vez. Assim, temos a complexidade: 
	
	\[
		O\parens[\bigg]{\sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item ArestasVisíveis(\(P_i\), \(\dots\)): Chamamos Query para os \(\abs{P_i}\) vértices de \(P_i\), assim, temos uma complexidade final de:
	
	\[
		O\parens[\bigg]{\abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item ConstróiRegiõesDeVértice(\(P_i\), \(\dots\)): Chamamos Query para os \(\abs{P_i}\) vértices de \(P_i\), assim, temos uma complexidade final de:
	
	\[
		O\parens[\bigg]{\abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item CaminhoMínimo: Chamamos ArestasVisíveis e ConstróiRegiõesDeVértice para cada polígono \(P_1, \dots, P_k\)e então calculamos o caminho final cuja complexidade é insignificante próximo do primeiro passo, então a complexidade final é:

	\[
		O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

\end{itemize}

Enquanto podemos dizer que determinamos a complexidade final do problema, gotaríamos de ter uma forma mais simples e de acordo com o artigo original. Assim, definimos \(n = \sum_{i = 1}^{k} \abs{P_i}\) e note que:

\begin{align*}
	O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}} &= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log \abs{P_j}} \\
	&= O\parens[\bigg]{\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i}} \cdot \parens[\bigg]{\sum_{i = 1}^{k} \log{\abs{P_i}}}} \\
	&= O\parens[\bigg]{n \sum_{i = 1}^{k} \log{\abs{P_i}}}
\end{align*}

Ademais, se fixarmos o valor de \(k\), temos que o valor de \(\sum_{i = 1}^{k} \log \abs{P_i}\) é máximo quando \(\abs{P_1} = \dots = \abs{P_k} = n / k\). Dessa forma, concluimos que em um pior caso a complexidade é:

\[
	O(n k \log(n / k))
\]

Dessa forma, nosso algoritmo está de acordo com o artigo original.

\section{O Problema de Visita de Polígonos Geral}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema restrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem2.py}.

\subsection{Definições e Notação}

O problema segue de forma similar ao anterior, mas agora também recebemos como entrada `cercas' \(F_0, \dots, F_k\) tais que para todo \(0 \le i \le k\) vale que o polígono \(P_i\) e \(P_{i + 1}\) estão contidos em \(F_i\), para tal, consideramos \(P_0 = \{s\}\) e \(P_{k + 1} = \{t\}\). Nosso objetivo é encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\), toca cada polígono \(P_i\) em pelo menos um ponto e nunca sai da cerca \(F_i\) no seu caminho entre \(P_i\) e \(P_{i + 1}\).

Dizemos que um caminho \(\pi\) de \(a\) até \(b\) respeita as cercas \(F_i, \dots, F_j\) se \(\pi\) toca todos os polígonos \(P_{i + 1}, \dots, P_j\) e para cada \(i \le l < j\), o trecho de \(\pi\) entre \(P_l\) e \(P_{l + 1}\) está contido em \(F_l\). Ademais, definimos um \(i\)-path até \(p\) como um caminho mínimo de \(s\) até \(p\) que respeita as cercas \(F_0, \dots, F_i\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\).

A função central desse algoritmo continua sendo Query, no entanto, dessa vez vamos adicionar um novo parâmetro, assim, a função \(\text{Query}(p, i, j)\) recebe um ponto \(p\) e dois índices \(i\) e \(j\) e retorna o penúltimo ponto \(q\) do menor caminho até \(p\) que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_i\) e respeita as cercas \(F_0, \dots, F_j\).

Primeiramente, é essencial que \(i \le j\), ademais, se \(i = j\) então \(\text{Query}(p, i, j)\) é simplesmente o penúltimo ponto do \(i\)-path até \(p\). Adicionamos o parâmetro \(j\) para o caso em que queremos um \(i\)-path, mas \(p\) está fora da cerca \(F_i\) um caso que aparece naturalmente na recursão do algoritmo. Por enquanto, vamos assumir que sabemos como respoder as consultas.

\subsection{Caminhos Restritos}

Outra função extremamente importante para a implementação desse algoritmo é a função \(\text{Fenced}(p_1, p_2, i, j)\) que retorna o menor caminho de \(p_1\) até \(p_2\) que respeita as cercas \(F_i, \dots, F_j\). Note que se \(i = j\), então \(\text{Fenced}(p_1, p_2, i, j)\) é simplesmente o segmento \(\overline{p_1p_2}\) se ele estiver contido em \(F_i\) e não existe caso contrário. Assim, vamos assumir que \(i < j\).


\newpage
\appendix

\newpage
\printbibliography

\end{document}
