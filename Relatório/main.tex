
\documentclass{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\SetKwIF{If}{ElseIf}{Else}{if}{:}{else if}{else}{end}
\SetKwFor{For}{for}{:}{end}
\SetKwRepeat{Do}{do}{while}
\SetKwProg{Function}{def}{:}{}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blockquote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Counter for proof lines
\newcounter{proofline}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\begin{document}

\begin{titlepage}

\begin{center}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.3\textwidth]{logo-small.png} % Ajuste o caminho da imagem conforme necessário
	\end{figure}

	\vspace{2cm}

	{\Large \sc UNIVERSIDADE DE SÃO PAULO} \\
	{\Large \sc INSTITUTO DE MATEMÁTICA E ESTATÍSTICA} \\ [0.7cm]
	{\sc DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO} \\

	\vspace{2cm}

	\rule{\linewidth}{2pt}
	
	\vspace{0.2em} % Ajuste ao seu gosto
	{\Large \bfseries 
		O Problema da Visita de Polígonos \\
	}
	\vspace{0.2em} % Ajuste ao seu gosto
	
	\rule{\linewidth}{2pt} \\

\end{center}

\vspace{2.8cm}

\begin{center}
	{\large \bfseries Gabriel Freire Ushijima} \\
\end{center}

\vfill

% Data
\begin{center}
	\makeatletter
	{\large São Paulo, SP \\
	\@date}
	\makeatother
\end{center}

\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{Introdução}

Este relatório descreve a implementação e os resultados obtidos na resolução do problema da visita de polígonos, usando como base o paper de Dror et al. (2003) \cite{tpp-dror2003} que descreve algoritmos para o caso sem e com restrições. Buscamos apresentar uma abordagem mais prática e detalhada para o problema, sem um foco tão grande na análise teórica.

\section{O Problema de Visita de Polígonos Irrestrito}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema irrestrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem1.py}.

\subsection{Definições e Notação}

\begin{wrapfigure}{r}{0.40\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.39\textwidth]{Problem1Images/solution.png}
	\caption{Caminho mínimo para um caso de 3 polígonos.}
	\label{problem1-solution}
\end{wrapfigure}

Considere o seguinte problema: dados dois pontos \(s, t \in \mathbb{R}^2\) e uma sequência de polígonos convexos disjuntos \(P_1, P_2, \ldots, P_k\), encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\) e toca cada polígono \(P_i\) em pelo menos um ponto, podendo atravessá-los.

A figura ao lado \ref{problem1-solution} ilustra um exemplo de entrada e a solução ótima para o problema para um caso com 3 polígonos. Temos \(s\) 
como o \textcolor[RGB]{0,128,0}{ponto verde}, \(t\) como o \textcolor[RGB]{255, 0, 0}{ponto vermelho} e os polígonos \(P_1, P_2\) e \(P_3\) como o \textcolor[RGB]{76, 146, 195}{triângulo azul}, o \textcolor[RGB]{255, 152, 62}{trapézio laranja} e o \textcolor[RGB]{86, 179, 86}{pentágono verde}, respectivamente. O caminho mínimo é representado pela \textcolor[RGB]{145, 41, 145}{linha roxa}.
% como o ponto verde, \(t\) como o ponto vermelho e os polígonos \(P_1, P_2\) e \(P_3\) como o triângulo azul, o trapézio laranja e o pentágono verde, respectivamente. O caminho mínimo é representado pela linha roxa.

Retomando o paper, definimos um \(i\)-path até \(p\) como um caminho mínimo que começa em \(s\), encosta em cada um dos polígonos \(P_1, P_2, \ldots, P_i\) e termina em \(p\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\). Enquanto não vamos entrar em detalhes, todo \(i\)-path é único.

A função central desse algoritmo será a função \(\text{Query}(p, i)\), que recebe um ponto \(p\) e um índice \(i\) e retorna o penúltimo ponto \(q\) do \(i\)-path até \(p\) (ou seja, o ponto imediatamente anterior à \(p\) nesse caminho). 

Primeiramente, vamos descrever procedimentos auxiliares que serão úteis para a implementação da função \(\text{Query}\). Finalmente, vamos descrever como respoder consultas usando esses procedimentos. Por enquanto, vamos assumir que sabemos como respoder as consultas.

\subsection{Representação dos Objetos}

Antes de descrever os procedimentos auxiliares, é importante definir como representamos os objetos geométricos envolvidos no problema. Utilizamos as seguintes representações:

\begin{itemize}[leftmargin=*, label={--}]

	\item \textbf{Pontos} e \textbf{Vetores}: Representados por uma classe \texttt{Vector2} que guarda um par de números reais \((x, y)\).
	
	\item \textbf{Polígonos}: Representados por uma classe \texttt{Polygon2} que guarda uma lista ordenada de seus vértices (representados por \texttt{Vector2}) no sentido anti-horário. Um vértice arbitrário é escolhido para ser indexado como o primeiro.

	\item \textbf{Caminho Final}: Representado como uma lista de pontos (representados por \texttt{Vector2}) na ordem em que aparecem no caminho.

\end{itemize}

\subsection{Particionando o Plano}

É possível mostrar \cite{tpp-dror2003} que para cada polígono \(P_i\) podemos criar uma partição \(S_i\) do plano tal que o comportamento da função \(\text{Query}(p, i)\) depende exclusivamente de qual região da partição \(S_i\) o ponto \(p\) pertence, sendo possível localizar cada ponto de maneira eficiente. Por falta de um nome melhor, chamamos cada parte de \(S_i\) de \textit{região}.

\begin{wrapfigure}{l}{0.60\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.6\textwidth]{Problem1Images/partitions.png}
	\caption{Partição do plano para cada polígono do exemplo anterior.}
	\label{problem1-partitions}

\end{wrapfigure}

Enquanto a quantidade de regiões de \(S_i\) pode ser numerosa a depender do número de vértices de \(P_i\), cada região pode ser de exatamente 3 tipos diferentes:, 
% \textcolor[RGB]{255, 140, 140}{Regiões de Vértice}, \textcolor[RGB]{140, 197, 140}{Regiões de Aresta} e \textcolor[RGB]{150, 208, 209}{Regiões de Atravessa}.
\textcolor[RGB]{255, 70, 70}{Regiões de Vértice}, \textcolor[RGB]{86, 179, 86}{Regiões de Aresta} e \textcolor[RGB]{76, 146, 195}{Regiões de Atravessar}.

Nas seções a seguir vamos descrever como usar essas partições para responder consultas, mas por enquanto vamos descrever como representar e construir essas partições. Por enquanto, apenas mantenha em mente que se conseguirmos representar e construir essas partições, então podemos usá-las para responder consultas e resolver o problema de maneira eficiente.

A partir da ilustração \ref{problem1-partitions}, note que cada região de vértice (\textit{Cone Region}) está associada a um vértice de \(P_i\), cada região de aresta (\textit{Edge Region}) está associada a uma aresta de \(P_i\) e há exatamente uma região de atravessar (\textit{Pass Through Region}). Ademais, essas regiões se complementam, ou seja, o conjunto de todas as regiões de vértice, aresta e atravessar é o plano todo e nenhuma região se sobrepõe a outra. Para que isso seja válido, devemos considerar pontos dentro dos polígonos \(P_i\) como pertencentes à região de atravessar.

Ademais, note que cada região de vértice é delimitada por duas semi-retas que partem de um vértice de \(P_i\), incluindo todos os pontos que estão entre essas semi-retas. Similarmente, cada região de aresta é delimitada por duas semi-retas que partem dos extremos de uma aresta de \(P_i\) e a prórpia aresta, incluindo todos os pontos que estão entre essas semi-retas e a aresta. Finalmente, a região de atravessar é o complemento das regiões de vértice e aresta.

\subsubsection{Representado as Partições}

Como mencionado, as regiões se complementam, assim, do ponto de vista de implementação, decidimos armazenar apenas as regiões de vértice, uma vez que as regiões de aresta podem ser construídas a partir delas, simplesmente verificando se um ponto está entre as semi-retas de duas regiões de vértice adjacentes e a aresta que as separa. 

Para representar as regiões de vértice, armazenamos uma lista de pares de direções \((d_1, d_2)\) para cada vértice \(v\) de \(P_i\), onde \(d_1\) e \(d_2\) são vetores unitários que representam as direções das semi-retas que delimitam a região de vértice associada a \(v\). Nem todo vértice de \(P_i\) gera uma região de vértice, assim, se um vértice \(v\) não gerar uma região, então armazenamos um par \((d, d)\) qualquer na posição correspondente da lista, representando uma região válida, mas vazia. Isso será mais relevante adiante.

Essa representação já permite que verifiquemos se um ponto \(p\) pertence a uma região de vértice e qual. No entanto, não conseguimos distinguir entre regiões de aresta e a região de atravessar. Para resolver esse problema, armazenamos uma lista de booleanas que indica se uma aresta é visível ou não. Assim, para determinar se um ponto \(p\) pertence a uma região de aresta ou à região de atravessar, basta verificar se \(p\) está entre as semi-retas de duas regiões de vértice adjacentes e, em caso positivo, verificar se a aresta que as separa é visível ou não.

\subsubsection{Detectando Arestas Visíveis}

Seja \(e\) um aresta de \(P_i\) e \(u, v\) seus vértices na ordem que aparecem em \(P_i\) (antihorário).
Dizemos que \(e\) é visível se e somente se para todo ponto interno \(p\) de \(e\) o \(i\)-path até \(p\) não passa pela parte interna de \(P_i\). Como a borda de \(P_i\) e sua parte interna são contínuas, podemos fazer esse teste para um único ponto interno de \(e\) e teremos o mesmo resultado.

Assim, temos a intuição de pegar o ponto médio \(m\) de \(e\) ou qualquer outro ponto interno de \(e\), calcular o último passo \(q\) do \(i\)-path até \(m\) e verificar se o segmento \(\overline{qm}\) passa por \(P_i\). No entanto, uma abordagem ingênua, testando cada aresta de \(P_i\) individualmente, seria muito lenta, tomando tempo \(O(\abs{P_i} ^ 2)\).

Felizmente, não é necessário implementar um teste eficiente de interseção de segmento e polígono, uma vez que temos a informação adicional que \(m\) pertence à borda de \(P_i\), mais especificamente na aresta \(e\). Por esse motivo, como \(P_i\) é convexo e suas arestas estão ordenadas em sentido antihorário, sabemos que se o produto interno de \(\overrightarrow{uv}\) com \(\overrightarrow{mq}\) for positivo, então \(\overrightarrow{mq}\) chega em \(m\) pela parte interna de \(P_i\).

\begin{algorithm}
\caption{Determina as arestas visíveis de \(P_i\)}

\(n \leftarrow \abs{P_i}\) // Número de vértices de \(P_i\)

\For {\(j \leftarrow 0\) até \(n - 1\)} {
	\(u \leftarrow e[0]\) \\
	\(v \leftarrow e[1]\) \\
	\(m \leftarrow (u + v) / 2\) \\
	\(q = \text{Query}(m, i)\) \\
	
}

\end{algorithm}

\begin{wrapfigure}{r}{0.40\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.4\textwidth]{Problem1Images/scene-general.png}
	\caption{Partição de um polígono com múltiplas arestas não visíveis.}
	\label{problem1-scene-general}

\end{wrapfigure}





\subsubsection{Construindo Regiões de Vértice}

Primeiramente, a partir da figura, note que nem todo vértice e nem toda aresta de \(P_i\) geram uma região na partição \(S_i\). Dizemos que uma aresta que gera uma região é uma aresta visível, assim, nosso primeiro passo é encontrar todas as arestas visíveis de \(P_i\). 

Uma maneira intuitiva de se uma aresta \(e\) é visível é calcular \(p = \text{Query}(m, i - 1)\) onde \(m\) é o ponto médio de \(e\) e verificamos se \(\overline{pm}\) atravessa \(P_i\). Se o segmento atravessa \(P_i\), então \(e\) não é visível, caso contrário, \(e\) é visível. No entanto, essa abordagem é ineficiente, uma vez que determinar se \(\overline{pm}\) atravessa \(P_i\) custa \(O(\abs{P_i})\) com uma abordagem ingênua e uma abordagem mais eficiente seria complexa de implementar. Por esse motivo vamos calcular essas arestas posteriormente.

Agora vamos calcular as regiões de vértice de um polígono \(P_i\). Vamos considerar o vértice \(v\) de \(P_i\) e calculamos \(p = \text{Query}(v, i - 1)\), a seguir explicamos como calcular \(p\), mas uma intuição inicial é pernsar que \(\text{Query}(q, 0) = s\) para qualquer \(q\), uma vez que um \(0\)-path não precisa tocar em nenhum polígono, assim, o menor caminho é uma linha reta de \(s\) até \(q\). 

Agora consideramos a direção de \(d = v - p\) e a maneira que esse raio chega em \(v\). Sejam \(v_1\) o vértice que precede e \(v_2\) o que segue \(v\) em \(P_i\) (no sentido anti-horário). Se a aresta \((v_1, v)\) é visível, então \(d_1\) será a reflexão de \(d\) em relação à aresta \((v_1, v)\), caso contrário, \(d_1\) será a mesma direção de \(d\). Similarmente, se a aresta \((v, v_2)\) é visível, então \(d_2\) será a reflexão de \(d\) em relação à aresta \((v, v_2)\), caso contrário, \(d_2\) será a mesma direção de \(d\). Assim, criamos a região de vértice \((d_1, d_2)\) associada à \(v\).

O cálculo em si da raflexão um vetor \(d\) em relação à uma aresta \(e = (u, v)\), é uma simples conta com base em projeções de vetores e pode ser implementada como a função abaixo:

\begin{verbatim}
def reflect(d: Vector2, e: Edge2) -> Vector2:
    dir = (e.v - e.u)
    normal = Vector2(-dir.y, dir.x)
    proj_len = d.dot(normal) / normal.dot(normal)
    projection = normal * proj_len
    return d - 2 * projection
\end{verbatim}

Usando essa função, definimos \(d_1 = \text{reflect}(d, (v_1, v))\) se a aresta \((v_1, v)\) for visível e \(d_1 = d\) caso contrário. A mesma lógica segue para \(d_2\).

Encorajamos o leitor a verificar que essa lógica se aplica nas duas imagens ao lado \ref{problem1-scene-general} \ref{problem1-scene-edge-case}, usando o ponto inicial \(s\) como resposta de \(\text{Query}(v, 0)\) para qualquer vértice \(v\). Para vértices com ambas arestas visíveis, ambas as direções são reflexões, para vértices com uma aresta visível, uma direção é reflexão e a outra é a mesma direção do raio, e para vértices com ambas as arestas não visíveis, ambas as direções são iguais à direção do raio, assim não são desenhada.

Isso completa a construção das regiões de vértice. No entanto, ainda não esclarecemos como determinar se uma aresta é visível ou não de maneira eficiente.



\subsection{Respondendo Consultas}

Agora que sabemos como construir as partições \(S_i\), podemos descrever como usá-las para responder consultas \(\text{Query}(p, i)\). O procedimento utilizado é recursivo, assim, primeiro definimos o caso base, que é \(\text{Query}(p, 0) = s\), uma vez que um \(0\)-path não precisa tocar em nenhum polígono, assim, o menor caminho é uma linha reta de \(s\) até \(p\).

Para \(i > 0\), primeiramente determinamos a região \(R\) de \(S_i\) que contém \(p\). Descrevemos acima como representar cada região e a partir dela é fácil determinar à qual um ponto \(p\) pertence. Também é importante ressaltar que \(p\) sempre pertence a exatamente uma região. Agora vamos analisar os 3 casos possíveis para \(R\):

\begin{itemize}

	\item Região de Vértice: Seja \(R = (v, d_1, d_2)\). Nesse caso, o \(i\)-path até \(p\) é deve passar pelo vértice \(v\), tocando o polígono \(P_i\). Assim, temos que \(\text{Query}(p, i) = v\).
	
	\item Região de Aresta: Seja \(R = (u, v, d_1, d_2)\). Nesse caso, o \(i\)-path até \(p\) deve passar por algum ponto \(q\) da aresta \(e = (u, v)\), tocando o polígono \(P_i\). Para calcular \(q\), primeiro determinamos \(q' = \text{Query}(p', i - 1)\), onde \(p'\) é a reflexão de \(p\) em relação à aresta \(e\). 
	Agora, dizemos que \(q\) é a interseção entre \(\overline{q'p'}\) e a aresta \(e\). Finalmente, respondemos \(\text{Query}(p, i) = q\).

	\item Região de Atravessa: Seja \(R\) a região de atravessa. Nesse caso, o \(i\)-path até \(p\) automaticamente atravessa o polígono \(P_i\) em algum ponto. Portanto, podemos simplesmente responder \(\text{Query}(p, i) = \text{Query}(p, i - 1)\).

\end{itemize}

\subsection{Calculando o Caminho Mínimo}

Uma vez que sabemos como responder consultas, calcular o caminho final é muito simples. Basta calcular \(q_k = \text{Query}(t, k)\), então \(q_{k - 1} =\text{Query}(q_k, k - 1)\) e assim por diante, até \(q_0 = s\). Assim, o caminho mínimo é simplesmente a sequência \(s, q_1, \ldots, q_k, t\).

\section{O Problema de Visita de Polígonos Geral}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema restrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem2.py}.

\subsection{Definições e Notação}

O problema segue de forma similar ao anterior, mas agora também recebemos como entrada `cercas' \(F_0, \dots, F_k\) tais que para todo \(0 \le i \le k\) vale que o polígono \(P_i\) e \(P_{i + 1}\) estão contidos em \(F_i\), para tal, consideramos \(P_0 = \{s\}\) e \(P_{k + 1} = \{t\}\). Nosso objetivo é encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\), toca cada polígono \(P_i\) em pelo menos um ponto e nunca sai da cerca \(F_i\) no seu caminho entre \(P_i\) e \(P_{i + 1}\).

Dizemos que um caminho \(\pi\) de \(a\) até \(b\) respeita as cercas \(F_i, \dots, F_j\) se \(\pi\) toca todos os polígonos \(P_{i + 1}, \dots, P_j\) e para cada \(i \le l < j\), o trecho de \(\pi\) entre \(P_l\) e \(P_{l + 1}\) está contido em \(F_l\). Ademais, definimos um \(i\)-path até \(p\) como um caminho mínimo de \(s\) até \(p\) que respeita as cercas \(F_0, \dots, F_i\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\).

A função central desse algoritmo continua sendo Query, no entanto, dessa vez vamos adicionar um novo parâmetro, assim, a função \(\text{Query}(p, i, j)\) recebe um ponto \(p\) e dois índices \(i\) e \(j\) e retorna o penúltimo ponto \(q\) do menor caminho até \(p\) que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_i\) e respeita as cercas \(F_0, \dots, F_j\).

Primeiramente, é essencial que \(i \le j\), ademais, se \(i = j\) então \(\text{Query}(p, i, j)\) é simplesmente o penúltimo ponto do \(i\)-path até \(p\). Adicionamos o parâmetro \(j\) para o caso em que queremos um \(i\)-path, mas \(p\) está fora da cerca \(F_i\) um caso que aparece naturalmente na recursão do algoritmo. Por enquanto, vamos assumir que sabemos como respoder as consultas.

\subsection{Caminhos Restritos}

Outra função extremamente importante para a implementação desse algoritmo é a função \(\text{Fenced}(p_1, p_2, i, j)\) que retorna o menor caminho de \(p_1\) até \(p_2\) que respeita as cercas \(F_i, \dots, F_j\). Note que se \(i = j\), então \(\text{Fenced}(p_1, p_2, i, j)\) é simplesmente o segmento \(\overline{p_1p_2}\) se ele estiver contido em \(F_i\) e não existe caso contrário. Assim, vamos assumir que \(i < j\).

\printbibliography

\end{document}
