
\documentclass{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\SetKwIF{If}{ElseIf}{Else}{if}{:}{else if}{else}{end}
\SetKwFor{For}{for}{:}{end}
\SetKwRepeat{Do}{do}{while}
\SetKwProg{Function}{def}{:}{}

\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{alg:#1}%
}

\newcommand{\algref}[1]{Algoritmo~\ref{alg:#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blockquote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Counter for proof lines
\newcounter{proofline}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\begin{document}

\begin{titlepage}

\begin{center}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.3\textwidth]{logo-small.png} % Ajuste o caminho da imagem conforme necessário
	\end{figure}

	\vspace{2cm}

	{\Large \sc UNIVERSIDADE DE SÃO PAULO} \\
	{\Large \sc INSTITUTO DE MATEMÁTICA E ESTATÍSTICA} \\ [0.7cm]
	{\sc DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO} \\

	\vspace{2cm}

	\rule{\linewidth}{2pt}
	
	\vspace{0.2em} % Ajuste ao seu gosto
	{\Large \bfseries 
		O Problema da Visita de Polígonos \\
	}
	\vspace{0.2em} % Ajuste ao seu gosto
	
	\rule{\linewidth}{2pt} \\

\end{center}

\vspace{2.8cm}

\begin{center}
	{\large \bfseries Gabriel Freire Ushijima} \\
\end{center}

\vfill

% Data
\begin{center}
	\makeatletter
	{\large São Paulo, SP \\
	\@date}
	\makeatother
\end{center}

\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{Introdução}

Este relatório descreve a implementação e os resultados obtidos na resolução do problema da visita de polígonos, usando como base o paper de Dror et al. (2003) \cite{tpp-dror2003} que descreve algoritmos para o caso sem e com restrições. Buscamos apresentar uma abordagem mais prática e detalhada para o problema, sem um foco tão grande na análise teórica.

\section{O Problema de Visita de Polígonos Irrestrito}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema irrestrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem1.py}.

\subsection{Definições e Notação}

\begin{wrapfigure}{r}{0.40\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.39\textwidth]{Problem1Images/solution.png}
	\caption{Caminho mínimo para um caso de 3 polígonos.}
	\label{problem1-solution}
\end{wrapfigure}

Considere o seguinte problema: dados dois pontos \(s, t \in \mathbb{R}^2\) e uma sequência de polígonos convexos disjuntos \(P_1, P_2, \ldots, P_k\), encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\) e toca cada polígono \(P_i\) em pelo menos um ponto, podendo atravessá-los.

A Figura~\ref{problem1-solution} ilustra um exemplo de entrada e a solução ótima para o problema para um caso com 3 polígonos. Temos \(s\) como o \textcolor[RGB]{0,128,0}{ponto verde}, \(t\) como o \textcolor[RGB]{255, 0, 0}{ponto vermelho} e os polígonos \(P_1, P_2\) e \(P_3\) como o \textcolor[RGB]{76, 146, 195}{triângulo azul}, o \textcolor[RGB]{255, 152, 62}{trapézio laranja} e o \textcolor[RGB]{86, 179, 86}{pentágono verde}, respectivamente. O caminho mínimo é representado pela \textcolor[RGB]{145, 41, 145}{linha roxa}.
% como o ponto verde, \(t\) como o ponto vermelho e os polígonos \(P_1, P_2\) e \(P_3\) como o triângulo azul, o trapézio laranja e o pentágono verde, respectivamente. O caminho mínimo é representado pela linha roxa.

Retomando o paper, definimos um \(i\)-path até \(p\) como um caminho mínimo que começa em \(s\), encosta em cada um dos polígonos \(P_1, P_2, \ldots, P_i\) e termina em \(p\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\). Enquanto não vamos entrar em detalhes, todo \(i\)-path é único.

A função central desse algoritmo será a função \(\text{Query}(p, i)\), que recebe um ponto \(p\) e um índice \(i\) e retorna o penúltimo ponto \(q\) do \(i\)-path até \(p\) (ou seja, o ponto imediatamente anterior à \(p\) nesse caminho). 

Primeiramente, vamos descrever procedimentos auxiliares que serão úteis para a implementação da função \(\text{Query}\). Finalmente, vamos descrever como respoder consultas usando esses procedimentos. Por enquanto, vamos assumir que sabemos como respoder as consultas. Para as seções a seguir, vamos assumir que os polígnos \(P_1, \dots, P_k\) são representados por listas de vértices ordenados em sentido anti-horário, com um vértice abitrário como o primeiro.

\subsection{Particionando o Plano}

É possível mostrar \cite{tpp-dror2003} que para cada polígono \(P_i\) podemos criar uma partição \(S_i\) do plano tal que o comportamento da função \(\text{Query}(p, i)\) dependa exclusivamente de a qual região da partição \(S_i\) o ponto \(p\) pertence, sendo possível localizar cada ponto de maneira eficiente. Por falta de um nome melhor, chamamos cada parte de \(S_i\) de \textit{região}.

Enquanto a quantidade de regiões de \(S_i\) pode ser numerosa a depender do número de vértices de \(P_i\), cada região pode ser de exatamente 3 tipos diferentes:, 
% \textcolor[RGB]{255, 140, 140}{Regiões de Vértice}, \textcolor[RGB]{140, 197, 140}{Regiões de Aresta} e \textcolor[RGB]{150, 208, 209}{Regiões de Atravessa}.
\textcolor[RGB]{255, 70, 70}{Regiões de Vértice}, \textcolor[RGB]{86, 179, 86}{Regiões de Aresta} e \textcolor[RGB]{76, 146, 195}{Regiões de Atravessar}.

Nas seções a seguir vamos descrever como usar essas partições para responder consultas, mas por enquanto vamos descrever como representar e construir essas partições. Por enquanto, apenas mantenha em mente que se conseguirmos representar e construir essas partições, então podemos usá-las para responder consultas e resolver o problema de maneira eficiente.

A partir da Figura~\ref{problem1-partitions}, note que cada região de vértice (\textit{Cone Region}) está associada a um vértice de \(P_i\), cada região de aresta (\textit{Edge Region}) está associada a uma aresta de \(P_i\) e há exatamente uma região de atravessar (\textit{Pass Through Region}). Ademais, essas regiões se complementam, ou seja, o conjunto de todas as regiões de vértice, aresta e atravessar é o plano todo e nenhuma região se sobrepõe a outra. Para que isso seja válido, devemos considerar pontos dentro dos polígonos \(P_i\) como pertencentes à região de atravessar. As fronteiras entre as regiões podem consideradas como pertencentes a qualquer uma das regiões que as delimitam, produzindo o mesmo resultado, mas para simplicidade, vamos considerar que pertencem às regiões de vértice.

\begin{wrapfigure}{l}{0.60\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.6\textwidth]{Problem1Images/partitions.png}
	\caption{Partição do plano para cada polígono do exemplo anterior.}
	\label{problem1-partitions}

\end{wrapfigure}

Ademais, note que cada região de vértice é delimitada por duas semi-retas que partem de um vértice de \(P_i\), incluindo todos os pontos que estão entre essas semi-retas. Similarmente, cada região de aresta é delimitada por duas semi-retas que partem dos extremos de uma aresta de \(P_i\) e a prórpia aresta, incluindo todos os pontos que estão entre essas semi-retas e a aresta. Finalmente, a região de atravessar é o complemento das regiões de vértice e aresta.

\subsubsection{Representado as Partições}

Como mencionado, as regiões se complementam, assim, do ponto de vista de implementação, decidimos armazenar apenas as regiões de vértice, uma vez que as regiões de aresta podem ser construídas a partir delas, simplesmente verificando se um ponto está entre as semi-retas de duas regiões de vértice adjacentes e a aresta que as separa. 

Para representar as regiões de vértice, associamos a cada vértice  \(v\) de \(P_i\) um par ordenado de direções \((d_1, d_2)\), onde \(d_1\) e \(d_2\) são vetores unitários que representam as direções das semi-retas que, em sentido anti-horário, delimitam a região de vértice associada a \(v\). Nem todo vértice de \(P_i\) gera uma região de vértice, assim, se um vértice \(v\) não gerar uma região, então marcamos essa entrada como \texttt{null}.

A partir dessa representação, já é possível verificar se um ponto \(p\) pertence à região de vértice associada ao vértice \(v\) delimitada pelas direções \(d_1\) e \(d_2\), usando produtos vetoriais. Recordando que o produto vetorial entre dois vetores \(v = (v_1, v_2)\) e \(u = (u_1, u_2)\) em \(\mathbb{R}^2\) é definido como:

\[
	v \times u = v_1 u_2 - v_2 u_1
\]

E tem a propriedade de que \(v \times u \ge 0\) se partindo de \(v\) e andando no sentido anti-horario, o angulo com \(u\) é de no máximo \(180 ^ \circ\) e \(v \times u \le 0\) se partindo de \(v\) e andando no sentido horario, o angulo com \(u\) é de no maximo \(180 ^ \circ\). A partir dessa definição, dizemos que um ponto \(p\) está do \textbf{lado esquerdo} de um vetor \(d\) se \(d \times p \ge 0\) e do \textbf{lado direito} se \(d \times p \le 0\).

Dessa forma, se o ângulo entre \(d_1\) e \(d_2\) é menor ou igual à \(180 ^ \circ\) (ou seja, \(d_1 \times d_2 \ge 0\)), podemos simplesmente verificar se o vetor \(\overrightarrow{vp} = p - v\) está do lado esquerdo de \(d_1\) e do lado direito de \(d_2\). Caso o ângulo entre \(d_1\) e \(d_2\) é maior que \(180 ^ \circ\), então verificamos se \(p\) não pertence ao complemento da região de vértice. Usando essa ideia, implementamos o algoritmo~\algref{PontoEmVértice}.

\begin{algorithm}
\alglabel{PontoEmVértice}
\caption{PontoEmVértice(\(p\), \(v\), \(d_1\), \(d_2\)) \\
Verifica se o ponto \(p\) está na região de vértice associada ao vértice \(v\) delimitada pelas direções \(d_1\) e \(d_2\)}

// Se o ângulo da região de vértice é maior que \(180 ^ \circ\)
// verificamos se \(p\) não pertence ao complemento da região. \\
\If {\(d_1 \times d_2 < 0\)} {
	\Return{\(\lnot\)} PontoEmVértice(\(p\), \(v\), \(d_2\), \(d_1\)) // Troca as direções e inverte o resultado
	}
	
	// Se o ângulo da região de vértice é menor ou igual a \(180 ^ \circ\) \\
	// Verificamos se \(p\) está entre as semi-retas \\
	\Return{} \((d_1 \times (p - v) \ge 0) \land (d_2 \times (p - v) \le 0)\)
\end{algorithm}

No entanto, não conseguimos distinguir entre regiões de aresta e a região de atravessar. Para resolver esse problema, armazenamos uma lista de booleanas que indica se uma aresta é visível ou não. Assim, para determinar se um ponto \(p\) pertence a uma região de aresta ou à região de atravessar, basta verificar se \(p\) está entre as semi-retas de duas regiões de vértice adjacentes e, em caso positivo, verificar se a aresta que as separa é visível ou não.

\subsubsection{Detectando Arestas Visíveis}

Seja \(e\) um aresta de \(P_i\) e \(u, v\) seus vértices na ordem que aparecem em \(P_i\) (antihorário).
Dizemos que \(e\) é visível se e somente se para todo ponto interno \(p\) de \(e\) o \(i\)-path até \(p\) não passa pela parte interna de \(P_i\). Como a borda de \(P_i\) e sua parte interna são contínuas, podemos fazer esse teste para um único ponto interno de \(e\) e teremos o mesmo resultado.

Assim, temos a intuição de pegar o ponto médio \(m\) de \(e\) ou qualquer outro ponto interno de \(e\), calcular o último ponto \(q\) do \(i\)-path até \(m\) e verificar se o segmento \(\overline{qm}\) passa por \(P_i\). No entanto, uma abordagem ingênua para detectar todas as arestas visíveis de $P_i$, testando cada aresta de \(P_i\) individualmente, seria muito lenta, tomando tempo \(O(\abs{P_i} ^ 2)\).

Felizmente, não é necessário implementar um teste eficiente de interseção de segmento e polígono, uma vez que temos a informação adicional de que \(m\) pertence à borda de \(P_i\), mais especificamente à aresta \(e\). Por esse motivo, como \(P_i\) é convexo e suas arestas estão ordenadas em sentido antihorário, sabemos que se o produto interno de \(\overrightarrow{uv}=(v-u)\) com \(\overrightarrow{mq}\) for positivo, então \(\overrightarrow{mq}\) chega em \(m\) pela parte interna de \(P_i\).

\begin{algorithm}
\caption{ArestasVisíveis(\(P_i\), \(i\)) \\ Determina as arestas visíveis de \(P_i\)}

\(n \leftarrow \abs{P_i}\) // Número de vértices de \(P_i\) \\
visível \(\leftarrow\) [False] * \(n\) // Inicializa todas as arestas como não visíveis \\

\For {\(j \leftarrow 0\) até \(n - 1\)} {
	\(u \leftarrow P_i[j]\) // j-ésimo vértice de \(P_i\) \\
	\(v \leftarrow P_i[j + 1]\) // vértice que segue \(u\), considerando \(P_i[n] = P_i[0]\) \\
	\(m \leftarrow (u + v) / 2\) // ponto médio \\
	\(q \leftarrow \text{Query}(m, i - 1)\) // penúltimo ponto do \((i - 1)\)-path até \(m\) \\
	
	\ \\
	// Marca a aresta \(j\) como visível se o produto vetorial for negativo \\
	visível[\(j\)] \(\leftarrow ((v - u) \times (q - u) < 0)\) 
}

\Return{} visível % Evita math mode desnecessário

\end{algorithm}

\subsubsection{Construindo Regiões de Vértice}

\begin{wrapfigure}{r}{0.40\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.4\textwidth]{Problem1Images/scene-general.png}
	\caption{Partição de um polígono com múltiplas arestas não visíveis.}
	\label{problem1-scene-general}

\end{wrapfigure}

Uma vez que sabemos quais arestas são visíveis, podemos construir as regiões de vértice. Vamos considerar o vértice \(v\) de \(P_i\) e calculamos \(p = \text{Query}(v, i - 1)\). Vamos explicar posteriormente como calcular \(p\), mas uma intuição inicial é pensar que \(\text{Query}(q, 0) = s\) para qualquer \(q\), uma vez que um \(0\)-path não precisa tocar em nenhum polígono, assim, o menor caminho é uma linha reta de \(s\) até \(q\). 

Agora consideramos a direção de \(d = v - p\) e a maneira que esse raio chega em \(v\). Sejam \(v_1\) o vértice que precede e \(v_2\) o que segue \(v\) em \(P_i\) (no sentido anti-horário). Se a aresta \((v_1, v)\) é visível, então \(d_1\) será a reflexão de \(d\) em relação à aresta \((v_1, v)\), caso contrário, \(d_1\) será a mesma direção de \(d\). Similarmente, se a aresta \((v, v_2)\) é visível, então \(d_2\) será a reflexão de \(d\) em relação à aresta \((v, v_2)\), caso contrário, \(d_2\) será a mesma direção de \(d\). Assim, criamos a região de vértice \((d_1, d_2)\) associada à \(v\).

Encorajamos o leitor a verificar que essa lógica se aplica à Figura~\ref{problem1-scene-general}, usando o ponto inicial \(s\) como resposta de \(\text{Query}(v, 0)\) para qualquer vértice \(v\). Os vértices (-2, 0) e (0, 0) terão as suas duas arestas incidentes visíveis, assim, suas regiões de vértice serão delimitadas pelas reflexões do raio que parte de \(s\). O vértice (-3, 1) terá apenas a aresta posterior visível, assim, sua região de vértice será delimitada pela reflexão do raio em relação à aresta posterior e a própria direção do raio. Similarmente, o vértice (2, 1) tem apenas a aresta anterior visível. Finalmente, os vértices (1, 1.25) e (-1, 1.5) não terão nenhuma aresta visível, assim, suas regiões de vértice serão simplesmente a direção do raio em ambas as semi-retas. \textcolor{red}{Verificar se podemos aqui apenas dizer que estes vertices terao uma regiao de vertice vazia ou dizer que estes vertices nao pertencem à regiao de pimeiro contato e portanto não tem uma regiao de vertice associada a eles.}

\begin{algorithm}
\caption{RefleteDireção(\(d, v_1, v_2\)) \\ Reflete a direção \(d\) em relação à aresta \((v_1, v_2)\)}

\(e \leftarrow v_2 - v_1\) \\
\(N \leftarrow \text{Vector2}(-e.y, e.x) / \abs{e}\) // Vetor normal à aresta \\
\Return{\(d - 2 \cdot (d ^ \intercal \cdot N) N\)} // Fórmula de reflexão

\end{algorithm}

\begin{algorithm}
\caption{Particiona(\(P_1, \dots, P_k\)) \\ Constroi as partições dos polígonos}

regiõesDeVértice \(\leftarrow\) [] // Lista vazia \\

\For{\(i \leftarrow 1\) até \(k\)} {

	visível \(\leftarrow \text{ArestasVisíveis}(P_i, i)\) \\
	regiõesDeVértice.\text{append}([]) // Adiciona uma nova lista para as regiões de vértice de \(P_i\) \\
	
	\For{\(j \leftarrow 0\) até \(\abs{P_i} - 1\)} {
	
		\(v \leftarrow P_i[j]\) // j-ésimo vértice de \(P_i\) \\
		\(v_1 \leftarrow P_i[j - 1]\) // vértice que precede \(v\), considerando \(P_i[-1] = P_i[\abs{P_i} - 1]\) \\
		\(v_2 \leftarrow P_i[j + 1]\) // vértice que segue \(v\), considerando \(P_i[\abs{P_i}] = P_i[0]\) \\
		
		\ \\
		
		\(p \leftarrow \text{Query}(v, i - 1)\) // penúltimo ponto do \((i - 1)\)-path até \(v\) \\
		\(d \leftarrow v - p\) // direção do raio de \(p\) até \(v\) \\
		
		\ \\

		\If{visível[\(j - 1\)]} {
			\(d_1 \leftarrow \text{Reflete}(d, v_1, v)\) // reflexão de \(d\) em relação à aresta \((v_1, v)\)
		}
		\Else {
			\(d_1 \leftarrow d\)
		}
		
		\If{visível[\(j\)]} {
			\(d_2 \leftarrow \text{Reflete}(d, v, v_2)\) // reflexão de \(d\) em relação à aresta \((v, v_2)\)
		}
		\Else {
			\(d_2 \leftarrow d\)
		}
		
		// Armazena a região de vértice associada a \(v\) como o par \((d_1, d_2)\) \\
		regiõesDeVértice[i - 1].\text{append}(\((d_1, d_2)\)) \\
	}
}

\end{algorithm}

\subsection{Localizando Pontos na Partição}

Gostariamos de responder consultas do tipo \(\text{Query}(p, i)\) de maneira eficiente. Para isso, precisamos ser capazes de localizar o ponto \(p\) na partição \(S_i\) de maneira eficiente, ou seja, determinar se \(p\) pertence a uma região de vértice, região de aresta ou região de atravessar e, em caso positivo, qual região.

Esse processo não é trivial, principalmente se desejamos fazer isso de maneira eficiente. Para tal, primeiro vamos considerar dois problemas mais simples: determinar se \(p\) pertence a uma região de vértice e determinar se \(p\) pertence a uma região de aresta.

\subsubsection{Verificando Regiões de Vértice}

Primeiramente vamos implementar um procedimento auxiliar que verifica se um ponto \(p\) está em uma região de vértice associada a um vértice \(v\) delimitada por duas direções \(d_1\) e \(d_2\). Basicamente, se o ângulo entre \(d_1\) e \(d_2\) é menor ou igual a \(180 ^ \circ\), então verificamos se \(p\) está entre as semi-retas usando produtos vetoriais. Caso contrário, verificamos se \(p\) não está no complemento da região.

\subsubsection{Verificando Regiões de Aresta}

Uma vez que conseguimos verificar se um ponto pertence a uma região de vértice, podemos usar essa funcionalidade para verificar se um ponto pertence a uma região de aresta. 

\begin{wrapfigure}{l}{0.69\textwidth} % 'r' for right, 'l' for left
    \centering
    \vspace{-1em} % adjust vertical alignment if needed
	\includegraphics[width=0.68\textwidth]{Problem1Images/edge-regions.png}
    \caption{Casos possíveis para região de aresta.}
	\label{problem1-edge-regions}
\end{wrapfigure}

Esse problema é mais complexo, uma vez que existem diferentes casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_1\) e \(d_2\). Esses casos não aparecem explicitamente na partição \(S_i\), na verdade apenas o primeiro caso aparece. No entanto, vamos usar esses outros casos adicionais para otimizar a localização de pontos na partição posteriormente, permitindo complexidade \(\log(\abs{P_i})\) para detecção.

Essencialmente existem 4 casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_1\) e \(d_2\). A figura ao lado \ref{problem1-edge-regions} ilustra esses casos. Para sabermos com qual caso estamos lidando, definimos \(e = v - u\) e calculamos os produtos vetoriais \(c_1 = e \times d_1\) e \(c_2 = e \times d_2\). Agora, temos os seguintes casos:

\begin{itemize}

	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado negativo}, que é o caso tradicional que aparece na partição \(S_i\). Nesse caso, verificamos se \(p\) está entre as semi-retas e a aresta \(e\) usando produtos vetoriais.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado negativo e aresta posterior no lado positivo}, o \textit{Caso 1} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_1, u - v)\) e \((v, u - v, d_2)\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado positivo e aresta posterior no lado negativo}, o \textit{Caso 2} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_1, v - u)\) e \((v, v - u, d_2)\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado positivo}. Nesse caso, simplesmente verificamos se o ponto não pertence ao complemento da região, ou seja, verificamos se \(p\) não pertence à região de aresta definida por \((v, u, d_2, d_1)\).
\end{itemize}

Dessa forma, conseguimos verificar se um ponto pertence a uma região de aresta usando o procedimento de verificação de regiões de vértice. Agora podemos implementar o procedimento completo na forma de um algoritmo.

\begin{algorithm}
\caption{PontoEmAresta(\(p\), \(u\), \(v\), \(d_1, d_2\)) \\
Verifica se o ponto \(p\) está na região de aresta associada à aresta \(e = (u, v)\) delimitada pelas direções \(d_1\) e \(d_2\)}

// Se vértices são muito próximos, tratamos a região de aresta \\
// como uma região de vértice. \\
\If {\(\abs{u - v} < 10 ^ {-8}\)} {
	\Return {} PontoEmVértice(\(p\), \(v\), \(d_2\), \(d_1\))
}

\(e \leftarrow v - u\) \\
\(c_1 \leftarrow d_1 \times e\) \\
\(c_2 \leftarrow e \times d_2\) \\

\If {\(c_1 \le 0 \land c_2 \le 0\)} {
	\Return{} \((d_1 \times (p - u) \ge 0) \land ((p - u) \times d_2 \le 0) \land ((v - u) \times (p - u)\)
}
\ElseIf {\(c_1 \le 0 \land c_2 > 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_1\), \(u - v\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(u - v\), \(d_2\))
}
\ElseIf {\(c_1 > 0 \land c_2 \le 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_1\), \(v - u\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(v - u\), \(d_2\))
}
\Else {
	\Return{} \(\lnot\) PontoEmAresta(\(p\), \(v\), \(u\), \(d_2\), \(d_1\))
}

\end{algorithm}

\subsubsection{Localização Eficiente de Pontos na Partição}

Agora que sabemos como verificar se um ponto pertence a uma região de vértice ou de aresta, podemos usar essas funcionalidades para localizar um ponto \(p\) na partição \(S_i\). Uma abordagem ingênua seria iterar sobre todas as regiões de vértice e aresta, verificando se \(p\) pertence a alguma delas. Isso funcionaria, no entanto, essa abordagem tomaria tempo \(O(\abs{P_i})\), o que é muito lento.

Por esse motivo, desejamos explorar a ideia de busca binária para resolver o problema. Primeiramente, vamos assumir que o ponto não pertence ao polígono \(P_i\), isso vale como suposição inicial dos polígonos serem disjuntos e os pontos \(s\) e \(t\) estarem fora dos polígonos. Ainda assim, se desejássemos evitar essa suposição, poderíamos simplesmente verificar se o ponto está dentro do polígono \(P_i\) usando um teste de ponto em polígono antes de localizar o ponto na partição, o é um problema clássico que leva tempo \(O(\log(\abs{P_i}))\).

Uma questão que diferencia nosso problema de uma busca binária tradicional é que as regiões são circulares. Assim, o primeiro passo é verificar se o ponto pertence à região entre o último e o primeiro vértice de \(P_i\). Se sim, retornamos essa região. Caso contrário, reduzimos o problema para uma lista linear de regiões.

Outra diferença que precisamos considerar é que nossa entrada contém dois tipos de regiões: regiões de vértice e regiões de aresta. Para lidar com isso, podemos tratar regiões de vértice como regiões de aresta degeneradas, onde a aresta tem comprimento zero. Dessa forma, podemos aplicar o mesmo raciocínio para ambos os tipos de regiões, lidando com uma lista de \(2 \abs{P_i} - 1\) regiões de aresta, uma vez que já eliminamos a última. Note que a implementação de PontoEmAresta já lida com esse caso especial.

Finalmente, podemos implementar a busca binária propriamente dita. A ideia é manter dois índices \(l\) e \(r\) que representam o intervalo atual de regiões que estamos considerando. Inicialmente, definimos \(n = \abs{P_i}\), \(l = 0\) e \(r = 2n - 1\). Nos baseamos na ideia de que apenas as regiões após \(l\) e antes de \(r\) podem conter o ponto \(p\), ambos limites inclusivos. 

Enquanto \(l + 1 \ne r\), calculamos o índice médio \(m = \floor{(l + r) / 2}\) e verificamos se o ponto \(p\) pertence à região de aresta entre \(l\) e \(m\). Se estiver, atualizamos \(r = m\), caso contrário, atualizamos \(l = m\), isso vale pois \(P_i\) é convexo e a região de aresta entre \(l\) e \(m\) cobre todas as regiões entre \(l\) e \(m\) e nenhuma região entre \(m\) e \(r\).

Repetindo isso até que \(l + 1 = r\), sabemos que o ponto \(p\) pertence à região de aresta entre \(l\) e \(r\). Finalmente, retornamos essa região, vamos codificar essa região como um inteiro que representa o índice da região.

Essa codificação segue a seguinte lógica: regiões de vértice são representadas por índices pares, onde o índice \(2j\) representa a região de vértice associada ao \(j\)-ésimo vértice de \(P_i\). Regiões de aresta são representadas por índices ímpares, onde o índice \(2j + 1\) representa a região de aresta entre o \(j\)-ésimo e o \((j + 1)\)-ésimo vértice de \(P_i\). Note que a região entre o último e o primeiro vértice é representada pelo índice \(2 \abs{P_i} - 1\).

\begin{algorithm}
\caption{LocalizaRegião(\(p\), \(P\), regiõesDeVértice) \\
Localiza o ponto \(p\) na partição do polígono \(P\)}


// Criamos uma função auxiliar usando fechamento \\
// para facilitar a implementação da busca binária \\
\Function{pertence(\(i\), \(j\))} {

	\(v_1 \leftarrow P[\floor{i / 2}]\) // Vértice \(i\) do polígono \(P\) \\
	\(v_2 \leftarrow P[\floor{j / 2}]\) // Vértice \(j\) do polígono \(P\) \\


	// Vamos lembrar que \textit{regiõesDeVértice} é uma lista de pares \((d_1, d_2)\) \\
	// Também vamos tratar \(i \pmod 2\) como uma operação tradicional de módulo \\
	\(d_1 \leftarrow \text{regiõesDeVértice}[\floor{i / 2}][i \pmod 2]\) \\
	\(d_2 \leftarrow \text{regiõesDeVértice}[\floor{j / 2}][j \pmod 2]\) \\

	\Return{} PontoEmAresta(\(p\), \(v_1\), \(v_2\), \(d_1\), \(d_2\))
}

\(l \leftarrow 0\)
\(r \leftarrow 2 \cdot \abs{P} - 1\) \\

\If {pertence(\(r\), \(0\))} {
	\Return{} \(r\) // Ponto pertence à região entre o último e o primeiro vértice
}

\While {\(l + 1 \ne r\)} {

	\(m \leftarrow \floor{(l + r) / 2}\) \\
	
	\If {pertence(\(l\), \(m\))} {
		\(r \leftarrow m\)
	}
	\Else {
		\(l \leftarrow m\)
	}
}

\Return{} \(l\) // Ponto pertence à região entre \(l\) e \(r\)

\end{algorithm}

\subsection{Respondendo Consultas}

Finalemnte, podemos descrever como responder consultas do tipo \(\text{Query}(p, i)\) usando as partições \(S_i\) que construímos anteriormente. O procedimento utilizado é recursivo, assim, primeiro definimos o caso base, que é \(\text{Query}(p, 0) = s\), uma vez que um \(0\)-path não precisa tocar em nenhum polígono, assim, o menor caminho é uma linha reta de \(s\) até \(p\).

Para \(i > 0\), primeiramente determinamos a região \(R\) de \(S_i\) que contém \(p\). Uma vez que sabemos qual região contém \(p\), podemos responder a consulta dependendo do tipo de região:

\begin{itemize}

	\item Região de Vértice: Seja \(R = (v, d_1, d_2)\). Nesse caso, o \(i\)-path até \(p\) deve passar pelo vértice \(v\), tocando o polígono \(P_i\). Assim, temos que \(\text{Query}(p, i) = v\).
	
	\item Região de Aresta: Seja \(R = (u, v, d_1, d_2)\). Nesse caso, o \(i\)-path até \(p\) deve passar por algum ponto \(q\) da aresta \(e = (u, v)\), tocando o polígono \(P_i\). Para calcular \(q\), primeiro determinamos \(q' = \text{Query}(p', i - 1)\), onde \(p'\) é a reflexão de \(p\) em relação à aresta \(e\). 
	Agora, dizemos que \(q\) é a interseção entre \(\overline{q'p'}\) e a aresta \(e\). Finalmente, respondemos \(\text{Query}(p, i) = q\).

	\item Região de Atravessa: Seja \(R\) a região de atravessa. Nesse caso, o \(i\)-path até \(p\) automaticamente atravessa o polígono \(P_i\) em algum ponto. Portanto, podemos simplesmente responder \(\text{Query}(p, i) = \text{Query}(p, i - 1)\).

\end{itemize}

Agora vamos implementar esse procedimento como um algoritmo, usando as contruções que fizemos anteriormente, uma vez que é um pouco mais complexo do que a descrição acima. 

Vamos usar também uma função auxiliar \text{InterseçãoDeSegmento} que calcula a interseção entre dois segmentos dados seus extremos. Essa não é descrita aqui, mas é uma implementação padrão de geometria computacional.

\begin{algorithm}
\caption{Query(\(p, i\)) \\ Responde a consulta \(\text{Query}(p, i)\)}

\If {\(i = 0\)} {
	\Return{} \(s\) // Caso base
}

\(R \leftarrow\) LocalizaRegião(\(p\), \(P_i\), regiõesDeVértice[\(i - 1\)]) \\
\(j \leftarrow \floor{R / 2}\)

\If {\(R \pmod 2 = 0\)} {
	\Return {} \(v \leftarrow P_i[j]\) // Vértice associado à região de vértice
}

\If {\(\lnot\) visível[\(j\)]} {
	\Return{} Query(\(p, i - 1\)) // Região de atravessa
}

// Região de aresta \\
\(u \leftarrow P_i[j]\) // Vértice inicial da aresta \\
\(v \leftarrow P_i[j + 1]\) // Vértice final da aresta \\

\(p' \leftarrow u + \text{RefleteDireção}((p - u), u, v)\) \\
\(q' \leftarrow \text{Query}(p', i - 1)\) \\
\(m \leftarrow \text{InterseçãoDeSegmento}(p', q', u, v)\) \\

\Return{} \(m\) // Ponto de interseção

\end{algorithm}

\subsection{Calculando o Caminho Mínimo}

Agora que sabemos como responder consultas do tipo \(\text{Query}(p, i)\), calcular o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\) é trivial.

Pela definição de Query, sabemos que o menor caminho que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_k\) e termina em \(t\) deve ter como penúltimo ponto \(q_k = \text{Query}(t, k)\). Ademais, o caminho que toca os polígonos \(P_1, \dots, P_{k - 1}\) e termina em \(q_k\) deve ter como penúltimo ponto \(q_{k - 1} = \text{Query}(q_k, k - 1)\). Repetindo esse raciocínio, chegamos até o ponto inicial \(s\).

Usando essa lógica e juntando as implementações anteriores em um algoritmo completo, temos:

\begin{algorithm}
\caption{CaminhoMínimo(\(s, t, P_1, \dots, P_k\)) \\ Calcula o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\)}

\If {\(k = 0\)} {
	\Return{} [\(s, t\)] // Caso base: caminho direto de \(s\) até \(t\)
}

regiãoDeVértice \(\leftarrow\) Particiona(\(P_1, \dots, P_k\)) \\
caminho \(\leftarrow []\) // Lista vazia para armazenar o caminho \\
\(p \leftarrow t\) // Começamos do ponto final \(t\) \\

\For {\(i \leftarrow k\) até \(1\)} {
	\(q \leftarrow \text{Query}(p, k)\) // Penúltimo ponto do \(k\)-path até \(p\) \\
	// Verificamos se os pontos \(p\) e \(q\) são distintos devido à regiões de atravessar \\
	\If {\(\abs{q - p} > 10 ^ {-8}\)} {
		caminho.\text{append}(\(p\)) // Adiciona \(p\) ao caminho \\
	}
	\(p \leftarrow q\) // Atualiza \(p\) para o próximo ponto \\
	\(k \leftarrow k - 1\) // Decrementa \(k\)
}

caminho.\text{append}(\(s\)) // Adiciona o ponto inicial \(s\) \\
caminho.\text{reverse}() // Inverte a lista para obter o caminho correto \\

\Return{} caminho

\end{algorithm}

\subsection{Análise de Complexidade}

Nessa seção, vamos analisar a complexidade do algoritmo completo. Primeiramente, a função LocalizaRegião leva tempo \(O(\log(\abs{P_i}))\) para localizar um ponto na partição \(S_i\), uma vez que usa busca binária. Ademais, a função Query faz uma chamada recursiva para \(i - 1\) em cada nível de recursão, resultando em \(i\) níveis de recursão. Assim, o tempo total para responder uma consulta \(\text{Query}(p, i)\) é \(O(i \log(\abs{P_i}))\).

\begin{itemize}
	
	\item RefleteDireção(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmVértice(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmAresta(\(\dots\)): \(O(1)\), pois faz um número constante de operações e chamadas para PontoEmVértice.
	
	\item LocalizaRegião(\(P_i\), \(\dots\)): \(O(\log \abs{P_i})\), pois usa busca binária em \(2 \abs{P_i} - 1\) regiões.
	
	\item Query\((i, \dots)\): Fazemos no máximo \(i\) chamadas recursivas, cada uma chama LocalizaRegião \(p\) umas vez. Assim, temos a complexidade: 
	
	\[
		O\parens[\bigg]{\sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item ArestasVisíveis(\(P_i\), \(\dots\)): Chamamos Query para os \(\abs{P_i}\) vértices de \(P_i\), assim, temos uma complexidade final de:
	
	\[
		O\parens[\bigg]{\abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]
	
	\item Particiona(\(P_1, \dots, P_n\)): Chamamos ArestasVisíveis para cada polígono \(P_i\), assim, temos:
	
	\[
		O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item CaminhoMínimo: Chamamos Particiona uma única vez e então calculamos o caminho final cuja complexidade é insignificante próximo de Particiona, então a complexidade final é a mesma:

	\[
		O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

\end{itemize}

Enquanto podemos dizer que determinamos a complexidade final do problema, gotaríamos de ter uma forma mais simples e de acordo com o artigo original. Assim, definimos \(n = \sum_{i = 1}^{k} \abs{P_i}\) e note que:

\begin{align*}
	O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}} &= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log \abs{P_j}} \\
	&= O\parens[\bigg]{\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i}} \cdot \parens[\bigg]{\sum_{i = 1}^{k} \log{\abs{P_i}}}} \\
	&= O\parens[\bigg]{n \sum_{i = 1}^{k} \log{\abs{P_i}}}
\end{align*}

Ademais, se fixarmos o valor de \(k\), temos que o valor de \(\sum_{i = 1}^{k} \log \abs{P_i}\) é máximo quando \(\abs{P_1} = \dots = \abs{P_k} = n / k\). Dessa forma, concluimos que em um pior caso a complexidade é:

\[
	O(n k \log(n / k))
\]

Dessa forma, nosso algoritmo está de acordo com o artigo original.

\section{O Problema de Visita de Polígonos Geral}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema restrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem2.py}.

\subsection{Definições e Notação}

O problema segue de forma similar ao anterior, mas agora também recebemos como entrada `cercas' \(F_0, \dots, F_k\) tais que para todo \(0 \le i \le k\) vale que o polígono \(P_i\) e \(P_{i + 1}\) estão contidos em \(F_i\), para tal, consideramos \(P_0 = \{s\}\) e \(P_{k + 1} = \{t\}\). Nosso objetivo é encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\), toca cada polígono \(P_i\) em pelo menos um ponto e nunca sai da cerca \(F_i\) no seu caminho entre \(P_i\) e \(P_{i + 1}\).

Dizemos que um caminho \(\pi\) de \(a\) até \(b\) respeita as cercas \(F_i, \dots, F_j\) se \(\pi\) toca todos os polígonos \(P_{i + 1}, \dots, P_j\) e para cada \(i \le l < j\), o trecho de \(\pi\) entre \(P_l\) e \(P_{l + 1}\) está contido em \(F_l\). Ademais, definimos um \(i\)-path até \(p\) como um caminho mínimo de \(s\) até \(p\) que respeita as cercas \(F_0, \dots, F_i\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\).

A função central desse algoritmo continua sendo Query, no entanto, dessa vez vamos adicionar um novo parâmetro, assim, a função \(\text{Query}(p, i, j)\) recebe um ponto \(p\) e dois índices \(i\) e \(j\) e retorna o penúltimo ponto \(q\) do menor caminho até \(p\) que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_i\) e respeita as cercas \(F_0, \dots, F_j\).

Primeiramente, é essencial que \(i \le j\), ademais, se \(i = j\) então \(\text{Query}(p, i, j)\) é simplesmente o penúltimo ponto do \(i\)-path até \(p\). Adicionamos o parâmetro \(j\) para o caso em que queremos um \(i\)-path, mas \(p\) está fora da cerca \(F_i\) um caso que aparece naturalmente na recursão do algoritmo. Por enquanto, vamos assumir que sabemos como respoder as consultas.

\subsection{Caminhos Restritos}

Outra função extremamente importante para a implementação desse algoritmo é a função \(\text{Fenced}(p_1, p_2, i, j)\) que retorna o menor caminho de \(p_1\) até \(p_2\) que respeita as cercas \(F_i, \dots, F_j\). Note que se \(i = j\), então \(\text{Fenced}(p_1, p_2, i, j)\) é simplesmente o segmento \(\overline{p_1p_2}\) se ele estiver contido em \(F_i\) e não existe caso contrário. Assim, vamos assumir que \(i < j\).

\printbibliography

\end{document}
