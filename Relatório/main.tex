
\documentclass{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

% make conditions/keyword arguments use text mode
\SetArgSty{textnormal}

\SetKwIF{If}{ElseIf}{Else}{if}{:}{else if}{else}{end}
\SetKwFor{For}{for}{:}{end}
\SetKwRepeat{Do}{do}{while}
\SetKwProg{Function}{def}{:}{}

\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{alg:#1}%
}

\newcommand{\algref}[1]{\ref{alg:#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}
\usepackage{csquotes}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{cleveref}
\usepackage{desclist}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blank}{}{} % Blank enviroment for folding sections in editors

\newenvironment{blockQuote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Counter for proof lines
\newcounter{proofline}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}
\DeclarePairedDelimiter{\anglebrackets}{\langle}{\rangle}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\begin{document}

\pagenumbering{roman}

\begin{titlepage}

\begin{center}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.3\textwidth]{logo-small.png} % Ajuste o caminho da imagem conforme necessário
	\end{figure}

	\vspace{2cm}

	{\Large \sc UNIVERSIDADE DE SÃO PAULO} \\
	{\Large \sc INSTITUTO DE MATEMÁTICA E ESTATÍSTICA} \\ [0.7cm]
	{\sc DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO} \\

	\vspace{2cm}

	\rule{\linewidth}{2pt}
	
	\vspace{0.2em} % Ajuste ao seu gosto
	{\Large \bfseries 
		O Problema da Visita de Polígonos \\
	}
	\vspace{0.2em} % Ajuste ao seu gosto
	
	\rule{\linewidth}{2pt} \\

\end{center}

\vspace{2.8cm}

\begin{center}
	{\large \bfseries Gabriel Freire Ushijima} \\
\end{center}

\vfill

% Data
\begin{center}
	\makeatletter
	{\large São Paulo, SP \\
	\@date}
	\makeatother
\end{center}

\end{titlepage}

\newpage

\begin{center}
	\textbf{\LARGE Resumo}
\end{center}

Em diferentes contextos, como robótica, planejamento de rotas e gráficos computacionais, surge a necessidade de encontrar caminhos eficientes que visitem uma série de regiões ou objetos no espaço. O Problema da Visita de Polígonos (TPP) é um problema clássico de otimização geométrica que busca determinar o caminho mais curto que visita uma sequência de polígonos convexos disjuntos em um plano. No presente trabalho se apresentam algoritmos para resolver o TPP em dois cenários distintos: o TPP Irrestrito, onde o caminho pode atravessar os polígonos, e o TPP Restrito, onde o caminho deve contornar os polígonos sem atravessá-los. Baseando-se no trabalho seminal de Dror et al. (2003), este relatório detalha a implementação prática dos algoritmos propostos, destacando suas complexidades computacionais e estratégias de otimização. Além disso, são apresentados resultados experimentais que ilustram a eficácia dos algoritmos em diferentes configurações de entrada. O código-fonte desenvolvido está disponível em um repositório público, facilitando a reprodução dos resultados e a exploração adicional do problema.

\newpage

\tableofcontents

\newpage

\section*{Notações}

\vspace{0.5cm}

% Increase spacing between rows

\begin{blank}

\setlength{\extrarowheight}{10pt}

\begin{tabular}{>{$}l<{$} @{\hspace{1.5em}} p{0.7\linewidth} l}
	v = (v_1, v_2) & Representação de vetores em \(\mathbb{R} ^ 2\) como tupla de coordenadas reais. \\
	\|{v}\| = \sqrt{v_1 ^ 2 + v_2 ^ 2} & Norma Euclidiana de um vetor. \\
	\anglebrackets{u, v} = u_1 v_1 + u_2 v_2 & Produto interno definido como produto escalar de vetores. \\
	u \times v = u_1 v_2 - u_2 v_1 & Produto vetorial definido como determinante 2D, retornando um escalar. Essa definição tem a seguinte propriedade:

	\begin{blank}
	\setlength{\extrarowheight}{4pt}
	\vspace{-10pt}
	\begin{equation*}
		\text{sign}(u \times v) =
		\begin{cases}
			+1, & \text{se o ângulo no sentido \textbf{anti-horário} entre } u \text{ e } v \text{ é menor que } 180 ^ \circ \\
			-1, & \text{se o ângulo no sentido \textbf{horário} entre } u \text{ e } v \text{ é menor que } 180 ^ \circ \\
			0, & u \text{ e } v \text{ colineares} \\
		\end{cases}
	\end{equation*}
	\vspace{-10pt}
	\end{blank} \\
	
	\overline{uv} & Segmento de reta entre os pontos \(u\) e \(v\). \\
	\overrightarrow{uv} = v - u & Vetor direcionado do ponto \(u\) até o ponto \(v\). \\
	\abs{P} & Se \(P\) é um polígono, então \(\abs{P}\) é o número de vértices de \(P\). \\
	\partial P & Fronteira (perímetro) do polígono \(P\). \\
\end{tabular}

\end{blank}

\clearpage
\pagenumbering{arabic}

\section{Introdução}

O Problema de Visita de Polígonos (TPP - \textit{Touring Polygons Problem}) é um problema clássico de otimização geométrica que envolve encontrar o caminho mais curto que visita em ordem uma sequência de polígonos em um plano. O problema é ilustrado pela Figura~\ref{problem-intro}.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{exemplo.png}
	\caption{Exemplo do Problema de Visita de Polígonos Irrestrito com 4 polígonos.}
	\label{problem-intro}
\end{figure}

Esse é um caso específico do problema do Caxeiro Viajante com Vizinhanças (TSPN - \textit{Traveling Salesman Problem with Neighborhoods}) \cite{tspn-iacopo-2011}, que é por sua vez uma generalização do famoso Problema do Caxeiro Viajante (TSP - \textit{Traveling Salesman Problem}) \cite{tsp-applegate2006}. Esse problema tem aplicações em diversas áreas, principalmente em robótica no contexto de planejamento de rotas, onde um robô precisa visitar uma série de regiões de interesse, representadas por polígonos, de maneira eficiente.

Enquanto os problemas de TSP e TSPN são conhecidos por serem NP-difíceis \cite{tsp-applegate2006, tspn-iacopo-2011}, o TPP exige que a ordem de visita dos polígonos seja pré-definida, o que permite o desenvolvimento de algoritmos polinomiais para resolver o problema em certos casos. Em particular, Dror et al. (2003) \cite{tpp-dror2003} propuseram algoritmos eficientes para resolver o TPP em dois cenários distintos: o TPP Irrestrito, onde o caminho pode atravessar os polígonos, e o TPP Restrito, onde o caminho deve se manter dentro de "cercas" que delimitam os polígonos, como se a visita dos polígonos fosse feita por um robô que não pode sair de uma área segura que engloba os polígonos.

Nesse relatório, buscamos discutir e implementar os algoritmos propostos por Dror et al. (2003) \cite{tpp-dror2003}, apresentando uma visão prática do problema e suas soluções. Enquanto o artigo original foca bastante na análise teórica dos algoritmos, nosso objetivo é fornecer uma abordagem mais acessível e detalhada, enfatizando a implementação e os resultados experimentais. Vamos introduzir os conceitos fundamentais lentamente, junto de diversas visualizações, com o objetivo de facilitar o entendimento do leitor. Para quem deseja uma compreensão mais profunda dos aspectos teóricos, recomendamos a leitura do artigo original.

Além dessas duas variações, também buscamos explorar o caso onde os polígonos não são necessariamente convexos, o que adiciona uma camada extra de complexidade ao problema. Podemos mostrar que nesse caso, mesmo quando não temos "cercas", o problema é NP-difícil \cite{tpp-dror2003}, no entanto, exploramos diferentes estratégias para lidar com essa complexidade adicional, partindo de uma enumeração completa e então removendo diversas soluções inviáveis através de uma estratégia de Branch and Bound, usando os algoritmos para o TPP Irrestrito como cálculo de limites inferiores. Dessa forma, conseguimos resolver instâncias razoavelmente grandes do problema com polígonos não convexos em um tempo aceitável. Esse caso não foi abordado no artigo original, na verdade, essa variação não parece ter sido estudada na literatura no momento da escrita deste relatório, por esse motivo consideramos que essa é uma contribuição original deste trabalho.

Uma parte central desse trabalho é a implementação prática dos algoritmos propostos, uma vez que isso distingue esse relatório do artigo original, que não inclui detalhes de implementação. Por esse motivo, disponibilizamos todo o código-fonte desenvolvido em um \href{https://github.com/YushiPy/TouringPolygons}{repositório público no GitHub}, permitindo que outros pesquisadores e entusiastas possam reproduzir os resultados apresentados aqui, bem como explorar e expandir o trabalho realizado. As implementações dos algoritmos foram realizadas tanto em \textit{Python} quanto em \textit{C++}, enquanto as visualizações utilizaram a biblioteca \textit{matplotlib} para \textit{Python} e a biblioteca \textit{Pygame} para criar um editor gráfico interativo. Além do código em si, também incluímos instruções detalhadas sobre como executar os algoritmos e reproduzir os experimentos apresentados neste relatório.

\section{O Problema de Visita de Polígonos Irrestrito}

Primeiramente vamos considerar o caso do Problema de Visita de Polígonos Irrestrito (TPP Irrestrito), onde não vamos impor restrições sobre o caminho que visita os polígonos. Esse problema foi originalmente descrito por Dror et al. (2003) \cite{tpp-dror2003}, que propuseram um algoritmo com complexidade \(O(n k \log(n / k))\) para resolver o problema, onde \(n\) é o número total de vértices dos polígonos e \(k\) é o número de polígonos. Buscamos apresentar uma versão prática desse algoritmo, focando no entendimento e implementação. O problema em si pode ser enunciado da seguinte maneira:

\begin{blockQuote}
	Dados dois pontos \(s, t \in \mathbb{R}^2\) e uma sequência de polígonos convexos disjuntos \(P_1, P_2, \ldots, P_k\), encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\) e toca cada polígono \(P_i\) em ordem em pelo menos um ponto, podendo atravessá-los.
\end{blockQuote}

\begin{wrapfigure}{r}{0.40\textwidth}
	\centering
	\includegraphics[width=0.39\textwidth]{Problem1Images/solution.png}
	\caption{Caminho mínimo para um caso de 3 polígonos.}
	\label{problem1-solution}
\end{wrapfigure}

A Figura~\ref{problem1-solution} ilustra um exemplo de entrada e a solução ótima para o problema para um caso com 3 polígonos. Temos \(s\) como o \textcolor[RGB]{0,128,0}{ponto verde}, \(t\) como o \textcolor[RGB]{255, 0, 0}{ponto vermelho} e os polígonos \(P_1, P_2\) e \(P_3\) como o \textcolor[RGB]{76, 146, 195}{triângulo azul}, o \textcolor[RGB]{255, 152, 62}{trapézio laranja} e o \textcolor[RGB]{86, 179, 86}{pentágono verde}, respectivamente. O caminho mínimo é representado pela \textcolor[RGB]{145, 41, 145}{linha roxa}.
% como o ponto verde, \(t\) como o ponto vermelho e os polígonos \(P_1, P_2\) e \(P_3\) como o triângulo azul, o trapézio laranja e o pentágono verde, respectivamente. O caminho mínimo é representado pela linha roxa.

No contexto de otimização geométrica, muitos problemas similares podem ser resolvidos usando uma técnica geral de computar um \textit{mapa de caminho mínimo}, que particiona o plano em regiões onde o comportamento do caminho mínimo é o mesmo. Para o nosso problema, qualquer solução deve tocar cada polígono \(P_i\) pela primeira vez em algum vértice ou aresta, assim, poderíamos agrupar os pontos de acordo com a sequência de vértices e arestas onde o caminho mínimo toca os polígonos. De fato, se calculássemos esse mapa, poderíamos responder consultas em tempo \(O(k + \log(n))\) \cite[Theorem 5.]{tpp-dror2003}, no entanto, no pior caso, esse mapa tem complexidade \(\Theta((n - k) 2 ^ k)\), ou seja, exponencial no número de polígonos \(k\) \cite[Theorem 4.]{tpp-dror2003}, tornando essa abordagem inviável.

Por esse motivo, usamos uma nova técnica baseada em subdividir o plano de acordo com \textit{mapas de último passo mínimo}, que para cada polígono \(P_i\), agrupa pontos \(p\) tais que o ponto \(q\) que antecede \(p\) do caminho mínimo partindo de \(s\), tocando \(P_1, \dots, P_i\) e chegando em \(p\) é um mesmo vértice ou uma mesma aresta. O conjunto dessas partições pode ser contruído em tempo \(O(nk \log(n / k))\), permitindo responder consultas em tempo \(O(k \log(n / k))\) \cite[Theorem 1.]{tpp-dror2003}. Dessa forma, podemos encontrar o caminho mínimo que visita todos os polígonos em tempo Polinomial.

\subsection{Condições de Otimalidade Local}

Primeiramente, definimos um \(i\)-path até \(p\) como um caminho mínimo que se inicia em \(s\) e toca os polígonos \(P_1, \ldots, P_i\) em ordem, terminando em um ponto \(p\), tal \(i\)-path é \textbf{único} \cite[Lemma 1.]{tpp-dror2003}. Note que um \(k\)-path até \(t\) é exatamente o caminho mínimo que buscamos.

Claramente, apenas precisamos considerar caminhos formados pela união de segmentos de reta entre \(s\) e \(t\). Ademais, tal caminho é \textit{localmente mínimo} se dobras ocorrem apenas no perímetro de cada polígono e, para cada dobra \(b \in \partial P_i\), mover \(b\) ligeiramente ao longo de qualquer direção na fronteira de \(P_i\) enquanto mantemos os outros pontos do caminho fixos aumenta o comprimento total do caminho. Isso implica que para pontos de dobra \(b\) no interior de uma aresta de \(P_i\), o ângulo de incidência do segmento que chega em \(b\) é igual ao ângulo de reflexão do segmento que sai de \(b\) (Lei da Reflexão). 

Já para pontos de dobra que são vértices \(v = e^1 \cap e ^ 2\) de \(P_i\), as condições de otimalidade dizem que, assumindo que \(u\) é o ponto imediatamente antes de \(v\) no caminho, um segmento saindo de \(v\) deve estar contido no cone \(\gamma\) delimitado pelas reflexões \(r^1\) e \(r^2\) da direção \(\overrightarrow{uv}\) em relação às duas arestas \(e^1\) e \(e^2\). Intuitivamente, isso ocorre porque qualquer segmento saindo de \(v\) fora desse cone poderia ser substituído por um segmento refletido em uma das arestas, reduzindo o comprimento total do caminho. A Figura~\ref{problem1-local-optimality} ilustra essas condições de otimalidade local.

\subsection{O Mapa de Último Passo Mínimo}

. A partir disso, podemos definir a função \(\text{Query}(p, i)\) que retorna o ponto \(q\) que antecede \(p\) no \(i\)-path até \(p\). Note que se \(i = 0\), então \(\text{Query}(p, 0) = s\) para qualquer ponto \(p \in \mathbb{R} ^ 2\).

\begin{wrapfigure}{l}{0.60\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.6\textwidth]{Problem1Images/partitions.png}
	\caption{Partição do plano para cada polígono do exemplo anterior.}
	\label{problem1-partitions}

\end{wrapfigure}

Ademais, para cada polígono \(P_i\), criamos uma partição \(S_i\) do plano chamada de \textbf{mapa de último passo mínimo}, que agrupa pontos \(p\) com base no último passo \(q\) do \(i\)-path até \(p\). Essencialmente, temos três tipos de regiões em \(S_i\), \textcolor[RGB]{255, 70, 70}{Regiões de Vértice}, \textcolor[RGB]{86, 179, 86}{Regiões de Aresta} e uma \textcolor[RGB]{76, 146, 195}{Região de Sombra}. Regiões de vértice agrupam pontos cujo último passo do \(i\)-path até eles é um mesmo vértice de \(P_{i - 1}\), regiões de aresta agrupam pontos cujo último passo do \(i\)-path até eles é uma mesma aresta de \(P_{i - 1}\) e a região de sombra agrupa pontos cujo \(i\)-path até eles atravessa o interior de \(P_{i - 1}\) para chegar neles. A Figura~\ref{problem1-partitions} ilustra essas partições para o exemplo da Figura~\ref{problem1-solution}.

Se considerarmos que pontos dentro de \(P_i\) pertencem à região de sombra e que pontos na fronteira entre as regiões podem ser considerados como pertencentes a qualquer uma das regiões que as delimitam, concluimos que qualquer ponto do plano pertence a exatamente uma dessas regiões, ou seja, essas três regiões são complementares.

Além disso, 

\subsubsection{Região de Primeiro Contato}

Seja $p \in P_i$ tal que a interseção entre o último segmento do \((i - 1)\)-path até \(p\) e $P_i$ consiste apenas no ponto $p$. Em outras palavras, $p$ é tal que o \((i - 1)\)-path até \(p\) chega a $P_i$ por ``fora''. Denominamos região de primeiro contato de $P_i$, que denotamos por $T_i$, ao conjunto de todos os pontos $p \in P_i$ com essa propriedade. \textcolor{red}{Tentar provar que se o sinal do produto vetorial usando o ponto $m$ tem o sinal correto, o mesmo vale para qualquer outro ponto no segmento.}


Para cada polígono \(P_i\), definimos \(T_i\) como a \textit{região de primeiro contato} de \(P_i\), ou seja, o conjunto de pontos \(p\) no perímetro de \(P_i\) tais que o \((i - 1)\)-path até \(p\) toca em \(P_i\) pela primeira vez em \(p\). Podemos provar \cite[Teorema~3.4, p. 243]{tpp-dror2003} que \(T_i\) é uma região contínua do perímetro de \(P_i\) e que \(T_i\) é delimitada por vértices de \(P_i\), ou seja, \(T_i\) é a união de uma sequência de arestas consecutivas de \(P_i\). Por esse motivo, chamamos arestas de \(P_i\) que pertencem à \(T_i\) de \textbf{arestas visíveis} e as que não pertencem de \textbf{arestas bloqueadas}.

\begin{wrapfigure}{r}{0.45\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.45\textwidth]{Problem1Images/visibility-test.png}
	\caption{Testando aresta para região de primeiro contato.}
	\label{problem1-visibility-test}

\end{wrapfigure}

Essa região é importante, pois apenas as arestas visíveis de \(P_i\) que pertencem à \(T_i\) geram regiões de aresta em \(S_i\), além disso, se um vértice está entre duas arestas bloqueadas, então ele não gera uma região de vértice em \(S_i\).

Como \(T_i\) é a união de arestas, para determinar quais arestas de \(P_i\) pertencem à \(T_i\), podemos simplesmente iterar sobre as arestas de \(P_i\) e verificar se o \((i - 1)\)-path até um ponto interno qualquer da aresta, por exemplo o ponto médio, chega em \(P_i\) pela primeira vez nesse ponto. Se isso for verdade, então a aresta pertence à \(T_i\), caso contrário, não pertence.

No entanto, precisamos de uma maneira eficiente de fazer isso para todas as arestas de \(P_i\). Se simplesmente fizermos isso de maneira ingênua, verificando se o segmento entre o último ponto \(q\) do \((i - 1)\)-path até o ponto médio \(m\) da aresta intersecta \(P_i\), teríamos uma complexidade de \(O(\abs{P_i})\) por aresta, resultando em \(O(\abs{P_i} ^ 2)\) para todas as arestas de \(P_i\). 

Felizmente, como~\(P_i\) é convexo e suas arestas estão ordenadas em sentido anti-horário, sabemos que o segmento \(\overline{qm}\) toca \(P_i\) pela primeira vez em \(m\) se e somente se o produto vetorial de \(\overrightarrow{mv}\) com \(\overrightarrow{mq}\) for positivo. Usando essa ideia, podemos determinar todas as arestas visíveis de \(P_i\) em tempo \(O(1)\) por aresta, totalizando \(O(\abs{P_i})\).

A Figura~\ref{problem1-visibility-test} ilustra essa ideia. Temos o polígono \(P_i\) em azul, os vértices \(u\) e \(v\) em azul, o ponto médio~\(m\) da aresta em laranja e 4 pontos \(q_1, q_2, q_3\) e \(q_4\) representando possíveis últimos pontos do \((i - 1)\)-path até~\(m\). Note que os segmentos \(\overline{q_1 m}\) e \(\overline{q_2 m}\) passam pela parte interna de \(P_i\), assim, o produto vetorial de \(\overrightarrow{uv}\) com \(\overrightarrow{m q_1}\) e \(\overrightarrow{m q_2}\) é positivo. Já os segmentos \(\overline{q_3 m}\) e \(\overline{q_4 m}\) não passam pela parte interna de \(P_i\), assim, o produto vetorial de \(\overrightarrow{uv}\) com \(\overrightarrow{m q_3}\) e \(\overrightarrow{m q_4}\) é negativo.

Implementamos essa ideia no Algoritmo \algref{ArestasVisíveis}, que recebe um polígono \(P_i\) e seu índice \(i\) e retorna uma lista booleana indicando quais arestas de \(P_i\) são visíveis. Para os próximos algoritmos, vamos referenciar os objetos \(T_1, \dots, T_k\) como listas booleanas indicando quais arestas de cada polígono \(P_1, \dots, P_k\) são visíveis.

\begin{algorithm}
\alglabel{ArestasVisíveis}
\caption{ArestasVisíveis(\(P_i\)) \\ Determina as arestas visíveis de \(P_i\)}

\(n \leftarrow \abs{P_i}\) // Número de vértices de \(P_i\) \\
visível \(\leftarrow\) [False] * \(n\) // Inicializa todas as arestas como não visíveis \\

\For {\(j \leftarrow 0\) até \(n - 1\)} {
	\(u \leftarrow\) \(j\)-ésimo vértice de \(P_i\) \\
	\(v \leftarrow\) vértice que segue \(u\) em \(P_i\) \\
	\(m \leftarrow (u + v) / 2\) // ponto médio \\
	\(q \leftarrow \text{Query}(m, i - 1)\) // penúltimo ponto do \((i - 1)\)-path até \(m\) \\
	
	\ \\
	// Marca a aresta \(j\) como visível se o produto vetorial for negativo \\
	visível[\(j\)] \(\leftarrow ((v - m) \times (q - m) < 0)\) 
}

\Return{visível}

\end{algorithm}

\subsubsection{Construindo Regiões de Vértice}

Uma vez que sabemos quais arestas são visíveis, podemos construir as regiões de vértice. Observamos anteriormente que essas são delimitadas por duas semi-retas que partem de um vértice de \(P_i\). Por esse motivo, nessa etapa, à cada vértice \(v\) vamos associar um par ordenado de direções \((d_{\text{prev}}, d_{\text{next}})\) tais que a região de vértice associada a \(v\) são os pontos entre as semi-retas que partem de \(v\) nas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\), no sentido anti-horário.

\begin{wrapfigure}{r}{0.40\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.4\textwidth]{Problem1Images/scene-general.png}
	\caption{Partição de um polígono com múltiplas arestas não visíveis.}
	\label{problem1-scene-general}

\end{wrapfigure}

Para calcular as direções da regiões de vértice de um vértice \(v\) de \(P_i\), devemos considerar o ponto \(p = \text{Query}(v, i - 1)\) e definimos \(d = v - p\). Sejam \(v_{\text{prev}}\) o vértice que precede e \(v_{\text{next}}\) o que segue \(v\) em \(P_i\) (no sentido anti-horário). Se a aresta \((v_{\text{prev}}, v)\) é visível, então \(d_{\text{prev}}\) será a reflexão de \(d\) em relação à aresta \((v_{\text{prev}}, v)\), caso contrário, \(d_{\text{prev}}\) será a mesma direção de \(d\). Similarmente, se a aresta \((v, v_{\text{next}})\) é visível, então \(d_{\text{next}}\) será a reflexão de \(d\) em relação à \textcolor{red}{reta que contem a} aresta \((v, v_{\text{next}})\), caso contrário, \(d_{\text{next}}\) \textcolor{red}{pode ser definido como qualquer multiplo positivo de $d$} será a mesma direção de \(d\). Assim, criamos a região de vértice \((d_{\text{prev}}, d_{\text{next}})\) associada à \(v\).

Vale notar que se ambas as arestas incidentes a \(v\) estão bloqueadas, então \textcolor{red}{a regio de vertice $v$ é vazia e denotamos isso definindo} \(d_{\text{prev}} = d_{\text{next}} = d\). %, assim, a região de vértice associada a \(v\) é válida, mas vazia.

Encorajamos o leitor a verificar que essa lógica se aplica à Figura~\ref{problem1-scene-general} que ilustra um polígono $P_1$, observando que a resposta de \(\text{Query}(v, 0)\) é o ponto inicial \(s\) para qualquer vértice \(v\) de $P_1$. Os vértices (-2, 0) e (0, 0) terão as suas duas arestas incidentes visíveis, assim, suas regiões de vértice serão delimitadas pelas reflexões do raio que parte de \(s\). O vértice (-3, 1) terá apenas a aresta posterior visível, assim, sua região de vértice será delimitada pela reflexão do raio em relação à aresta posterior e a própria direção do raio. Similarmente, o vértice (2, 1) tem apenas a aresta anterior visível. Finalmente, os vértices (1, 1.25) e (-1, 1.5) não terão nenhuma aresta incidente visível, assim, suas regiões de vértice serão vazias. 

Implementamos essas ideias nos algoritmos \algref{RefleteDireção} e \algref{ConstróiRegiõesDeVértice}. O primeiro reflete uma direção em relação a uma reta que passa por dois pontos dados, enquanto o segundo cria a partição \(S_i\) de um polígono \(P_i\), retornando uma lista de pares ordenados de direções representando as regiões de vértice associadas a cada vértice de \(P_i\). \textcolor{red}{Cada elemento da lista corresponde a um vertice de $P_i$ e os elementos aparecem na mesma ordem em que os vertices de $P_i$ aparecem na descricao de $P_i$} Para os próximos algoritmos, vamos referenciar os objetos \(S_1, \dots, S_k\) como listas de pares ordenados de direções representando as regiões de vértice de cada polígono \(P_1, \dots, P_k\).

% \textcolor{red}{Verificar se podemos aqui apenas dizer que estes vertices terao uma regiao de vertice vazia ou dizer que estes vertices nao pertencem à regiao de pimeiro contato e portanto não tem uma regiao de vertice associada a eles.}

\begin{algorithm}
\alglabel{RefleteDireção}
\caption{RefleteDireção(\(d, v_{\text{prev}}, v_{\text{next}}\)) \\ Reflete a direção \(d\) em relação à aresta \((v_{\text{prev}}, v_{\text{next}})\)}

\(u \leftarrow v_{\text{prev}} - v_{\text{next}}\) \\
\(w \leftarrow \) Vetor normal à \(u\), tal que \(\abs{w} = 1\) \textcolor{red}{Colocar a formula e deixar isso como comentario. Usar $\| \cdot \|_2$ para norma Euclidiana} \\ 
\Return{\(d - 2 \anglebrackets{d, w} w\)} // Fórmula de reflexão

\end{algorithm}

\begin{algorithm}
\alglabel{ConstróiRegiõesDeVértice}
\caption{ConstróiRegiõesDeVértice(\(P_i\)) \\ Constroi as partições do polígono \(P_i\)}

\(S_i \leftarrow \emptyset\) // Lista vazia \\

\For{\(j \leftarrow 0\) até \(\abs{P_i} - 1\)} {

	\(v \leftarrow\) \(j\)-ésimo vértice de \(P_i\) \\
	\(v_{\text{prev}} \leftarrow\) vértice que precede \(v\) em \(P_i\) \\
	\(v_{\text{next}} \leftarrow\) vértice que segue \(v\) em \(P_i\) \\
	
	\ \\
	
	\(p \leftarrow \text{Query}(v, i - 1)\) // penúltimo ponto do \((i - 1)\)-path até \(v\) \\
	\(d \leftarrow v - p\) // direção do raio de \(p\) até \(v\) \\
	
	\ \\

	\If{Aresta \(j - 1\) de \(P_i\) pertence à \(T_i\)} {
		\(d_{\text{prev}} \leftarrow \text{Reflete}(d, v_{\text{prev}}, v)\) // reflexão de \(d\) em relação à aresta \((v_{\text{prev}}, v)\)
	}
	\Else {
		\(d_{\text{prev}} \leftarrow d\)
	}
	
	\If{Aresta \(j\) de \(P_i\) pertence à \(T_i\)} {
		\(d_{\text{next}} \leftarrow \text{Reflete}(d, v, v_{\text{next}})\) // reflexão de \(d\) em relação à \textcolor{red}{reta que contem a} aresta \((v, v_{\text{next}})\)
	}
	\Else {
		\(d_{\text{next}} \leftarrow d\)
	}
	
	// Armazena a região de vértice associada a \(v\) como o par \((d_{\text{prev}}, d_{\text{next}})\) \\
	\(S_i \leftarrow S_i + (d_{\text{prev}}, d_{\text{next}})\) %regiões.\text{append}(\((d_{\text{prev}}, d_{\text{next}})\)) \\
}

\Return{regiões}

\end{algorithm}

\subsection{Localizando Pontos na Partição}

Gostariamos de responder consultas do tipo \(\text{Query}(p, i)\) de maneira eficiente. Para isso, precisamos ser capazes de localizar o ponto \(p\) na partição \(S_i\) de maneira eficiente, ou seja, determinar se \(p\) pertence a uma região de vértice, região de aresta ou região de atravessar e, em caso positivo, qual região.

Esse processo não é trivial, principalmente se desejamos fazer isso de maneira eficiente. Para tal, primeiro vamos considerar dois problemas mais simples: determinar se \(p\) pertence a uma região de vértice e determinar se \(p\) pertence a uma região de aresta.

\subsubsection{Verificando Regiões de Vértice}

Primeiramente vamos implementar um procedimento auxiliar \algref{PontoEmVértice} que verifica se um ponto \(p\) está em uma região de vértice associada a um vértice \(v\) determinada pelo par \( (d_{\text{prev}},d_{\text{next}}) \). Basicamente, temos dois casos, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\) (considerando o sentido anti-horário):

\begin{itemize}

	\item Ângulo \(\le 180 ^ \circ\): Nesse caso, \(p\) deve estar à esquerda de \(d_{\text{prev}}\) e à direita de \(d_{\text{next}}\).

	\item Ângulo \(> 180 ^ \circ\): Nesse caso, \(p\) deve estar à direita de \(d_{\text{prev}}\) ou à esquerda de \(d_{\text{next}}\).

\end{itemize}

Podemos usar produtos vetoriais para determinar a posição relativa de \(p\) em relação às direções \(d_{\text{prev}}\) e \(d_{\text{next}}\), assim como o ângulo entre essas direções. Usando essas ideias, implementamos o procedimento no algoritmo \algref{PontoEmVértice}.

\begin{algorithm}
\alglabel{PontoEmVértice}
\caption{PontoEmVértice(\(p\), \(v\), \(d_{\text{prev}}\), \(d_{\text{next}}\)) \\
Verifica se o ponto \(p\) está na região de vértice associada ao vértice \(v\) delimitada pelas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\)}

\(c_1 \leftarrow (d_{\text{prev}} \times (p - v) \ge 0)\) \\
\(c_2 \leftarrow (d_{\text{next}} \times (p - v) \le 0)\)

\If {\(d_{\text{prev}} \times d_{\text{next}} \ge 0\)} {
	\Return{} \(c_1 \land c_2\)
	}
\Else {
	\Return{} \(c_1 \lor c_2\)
}

\end{algorithm}

\subsubsection{Verificando Regiões de Aresta}

Uma vez que conseguimos verificar se um ponto pertence a uma região de vértice, podemos usar essa funcionalidade para verificar se um ponto pertence a uma região de aresta. 

\begin{wrapfigure}{l}{0.69\textwidth} % 'r' for right, 'l' for left
    \centering
    \vspace{-1em} % adjust vertical alignment if needed
	\includegraphics[width=0.68\textwidth]{Problem1Images/edge-regions.png}
    \caption{Casos possíveis para região de aresta.}
	\label{problem1-edge-regions}
\end{wrapfigure}

Esse problema é mais complexo, uma vez que existem diferentes casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\). Esses casos não aparecem explicitamente na partição \(S_i\), na verdade apenas o primeiro caso aparece. No entanto, vamos usar esses outros casos adicionais para otimizar a localização de pontos na partição posteriormente, permitindo complexidade \(\log(\abs{P_i})\) para detecção.

Essencialmente existem 4 casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\). A Figura \ref{problem1-edge-regions} ilustra esses casos. Para sabermos com qual caso estamos lidando, definimos \(w = v - u\) e calculamos os produtos vetoriais \(c_1 = w \times d_{\text{prev}}\) e \(c_2 = w \times d_{\text{next}}\). Agora, temos os seguintes casos:

\begin{itemize}

	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado negativo}, que é o caso tradicional que aparece na partição \(S_i\). Nesse caso, verificamos se \(p\) está entre as semi-retas e a aresta \((u, v)\) usando produtos vetoriais.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado negativo e aresta posterior no lado positivo}, o \textit{Caso 1} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_{\text{prev}}, u - v)\) e \((v, u - v, d_{\text{next}})\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado positivo e aresta posterior no lado negativo}, o \textit{Caso 2} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_{\text{prev}}, v - u)\) e \((v, v - u, d_{\text{next}})\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado positivo}. Nesse caso, simplesmente verificamos se o ponto não pertence ao complemento da região, ou seja, verificamos se \(p\) não pertence à região de aresta definida por \((v, u, d_{\text{next}}, d_{\text{prev}})\).
\end{itemize}

Dessa forma, conseguimos verificar se um ponto pertence a uma região de aresta usando o procedimento de verificação de regiões de vértice. Agora podemos implementar o procedimento completo no algoritmo \algref{PontoEmAresta}.

\begin{algorithm}
\alglabel{PontoEmAresta}
\caption{PontoEmAresta(\(p\), \(u\), \(v\), \(d_{\text{prev}}, d_{\text{next}}\)) \\
Verifica se o ponto \(p\) está na região de aresta associada à aresta \(e = (u, v)\) delimitada pelas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\)}

// Se vértices são muito próximos, tratamos a região de aresta \\
// como uma região de vértice. \\
\If {\(\abs{u - v} < 10 ^ {-8}\)} {
	\Return {} PontoEmVértice(\(p\), \(v\), \(d_{\text{next}}\), \(d_{\text{prev}}\))
}

\(w \leftarrow v - u\) \\
\(c_1 \leftarrow d_{\text{prev}} \times w\) \\
\(c_2 \leftarrow w \times d_{\text{next}}\) \\

\If {\(c_1 \le 0 \land c_2 \le 0\)} {
	\Return{} \((d_{\text{prev}} \times (p - u) \ge 0) \land ((p - u) \times d_{\text{next}} \le 0) \land ((v - u) \times (p - u) \le 0)\)
}
\ElseIf {\(c_1 \le 0 \land c_2 > 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_{\text{prev}}\), \(u - v\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(u - v\), \(d_{\text{next}}\))
}
\ElseIf {\(c_1 > 0 \land c_2 \le 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_{\text{prev}}\), \(v - u\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(v - u\), \(d_{\text{next}}\))
}
\Else {
	\Return{} \(\lnot\) PontoEmAresta(\(p\), \(v\), \(u\), \(d_{\text{next}}\), \(d_{\text{prev}}\))
}

\end{algorithm}

\subsubsection{Localização Eficiente de Pontos na Partição}

Agora que sabemos como verificar se um ponto pertence a uma região de vértice ou de aresta, podemos usar essas funcionalidades para localizar um ponto \(p\) na partição \(S_i\). Uma abordagem ingênua seria iterar sobre todas as regiões de vértice e aresta, verificando se \(p\) pertence a alguma delas. Isso funcionaria, no entanto, essa abordagem tomaria tempo \(O(\abs{P_i})\), o que é muito lento.

Por esse motivo, desejamos explorar a ideia de busca binária para resolver o problema. Primeiramente, vamos assumir que o ponto não pertence ao polígono \(P_i\), isso vale como suposição inicial dos polígonos serem disjuntos e os pontos \(s\) e \(t\) estarem fora dos polígonos. Ainda assim, se desejássemos evitar essa suposição, poderíamos simplesmente verificar se o ponto está dentro do polígono \(P_i\) usando um teste de ponto em polígono antes de localizar o ponto na partição, o é um problema clássico que leva tempo \(O(\log(\abs{P_i}))\).

Uma questão que diferencia nosso problema de uma busca binária tradicional é que as regiões são circulares. Assim, o primeiro passo é verificar se o ponto pertence à região entre o último e o primeiro vértice de \(P_i\). Se sim, retornamos essa região. Caso contrário, reduzimos o problema para uma lista linear de regiões.

Outra diferença que precisamos considerar é que nossa entrada contém dois tipos de regiões: regiões de vértice e regiões de aresta. Para lidar com isso, podemos tratar regiões de vértice como regiões de aresta degeneradas, onde a aresta tem comprimento zero. Dessa forma, podemos aplicar o mesmo raciocínio para ambos os tipos de regiões, lidando com uma lista de \(2 \abs{P_i} - 1\) regiões de aresta, uma vez que já eliminamos a última. Note que a implementação de PontoEmAresta já lida com esse caso especial.

Finalmente, podemos implementar a busca binária propriamente dita. A ideia é manter dois índices \(l\) e \(r\) que representam o intervalo atual de regiões que estamos considerando. Inicialmente, definimos \(n = \abs{P_i}\), \(l = 0\) e \(r = 2n - 1\). Nos baseamos na ideia de que apenas as regiões após \(l\) e antes de \(r\) podem conter o ponto \(p\), ambos limites inclusivos. 

Enquanto \(l + 1 \ne r\), calculamos o índice médio \(m = \floor{(l + r) / 2}\) e verificamos se o ponto \(p\) pertence à região de aresta entre \(l\) e \(m\). Se estiver, atualizamos \(r = m\), caso contrário, atualizamos \(l = m\), isso vale pois \(P_i\) é convexo e a região de aresta entre \(l\) e \(m\) cobre todas as regiões entre \(l\) e \(m\) e nenhuma região entre \(m\) e \(r\).

Repetindo isso até que \(l + 1 = r\), sabemos que o ponto \(p\) pertence à região de aresta entre \(l\) e \(r\). Finalmente, retornamos essa região, vamos codificar essa região como um inteiro que representa o índice da região.

Essa codificação segue a seguinte lógica: regiões de vértice são representadas por índices pares, onde o índice \(2j\) representa a região de vértice associada ao \(j\)-ésimo vértice de \(P_i\). Regiões de aresta são representadas por índices ímpares, onde o índice \(2j + 1\) representa a região de aresta entre o \(j\)-ésimo e o \((j + 1)\)-ésimo vértice de \(P_i\). Note que a região entre o último e o primeiro vértice é representada pelo índice \(2 \abs{P_i} - 1\).

Implementamos essa ideia no algoritmo \algref{LocalizaRegião}, que recebe um ponto \(p\) e um polígono \(P_i\) e retorna o índice da região de \(S_i\) que contém \(p\).

\begin{algorithm}
\alglabel{LocalizaRegião}
\caption{LocalizaRegião(\(p\), \(P_i\)) \\
Localiza o ponto \(p\) na partição do polígono \(P_i\)}

\Function{getDireção(\(i\))} {
	\If {\(i \pmod 2 = 0\)} {
		\Return{} direção anterior associada ao vértice \(\floor{i / 2}\) de \(P_i\)
	}
	\Else {
		\Return{} direção anterior associada ao vértice \(\floor{i / 2}\) de \(P_i\)
	}
}

\Function{pertence(\(i\), \(j\))} {

	\(v_1 \leftarrow \) Vértice \(\floor{i / 2}\) do polígono \(P_i\) \\
	\(v_2 \leftarrow \) Vértice \(\floor{j / 2}\) do polígono \(P_i\) \\
	\(d_{\text{prev}} \leftarrow\) getDireção(\(i\)) \\
	\(d_{\text{next}} \leftarrow\) getDireção(\(j\)) \\

	\Return{} PontoEmAresta(\(p\), \(v_1\), \(v_2\), \(d_{\text{prev}}\), \(d_{\text{next}}\))
}

\(l \leftarrow 0\) \\
\(r \leftarrow 2 \abs{P} - 1\) \\

\If {pertence(\(r\), \(0\))} {
	\Return{} \(r\) // Ponto pertence à região entre o último e o primeiro vértice
}

\While {\(l + 1 \ne r\)} {

	\(m \leftarrow \floor{(l + r) / 2}\) \\
	
	\If {pertence(\(l\), \(m\))} {
		\(r \leftarrow m\)
	}
	\Else {
		\(l \leftarrow m\)
	}
}

\Return{} \(l\) // Ponto pertence à região entre \(l\) e \(r\)

\end{algorithm}

\subsection{Respondendo Consultas}

Finalemnte, podemos descrever como responder consultas do tipo \(\text{Query}(p, i)\) usando as partições \(S_i\) que construímos anteriormente. O procedimento utilizado é recursivo, assim, primeiro definimos o caso base, que é \(\text{Query}(p, 0) = s\), uma vez que um \(0\)-path não precisa tocar em nenhum polígono, assim, o menor caminho é uma linha reta de \(s\) até \(p\).

Para \(i > 0\), primeiramente determinamos a região \(R\) de \(S_i\) que contém \(p\). Uma vez que sabemos qual região contém \(p\), podemos responder a consulta dependendo do tipo de região:

\begin{itemize}

	\item Região de Vértice: Seja \(R = (v, d_{\text{prev}}, d_{\text{next}})\). Nesse caso, o \(i\)-path até \(p\) deve passar pelo vértice \(v\), tocando o polígono \(P_i\). Assim, temos que \(\text{Query}(p, i) = v\).
	
	\item Região de Aresta: Seja \(R = (u, v, d_{\text{prev}}, d_{\text{next}})\). Nesse caso, o \(i\)-path até \(p\) deve passar por algum ponto \(q\) da aresta \(e = (u, v)\), tocando o polígono \(P_i\). Para calcular \(q\), primeiro determinamos \(q' = \text{Query}(p', i - 1)\), onde \(p'\) é a reflexão de \(p\) em relação à aresta \(e\). 
	Agora, dizemos que \(q\) é a interseção entre \(\overline{q'p'}\) e a aresta \(e\). Finalmente, respondemos \(\text{Query}(p, i) = q\).

	\item Região de Atravessa: Seja \(R\) a região de atravessa. Nesse caso, o \(i\)-path até \(p\) automaticamente atravessa o polígono \(P_i\) em algum ponto. Portanto, podemos simplesmente responder \(\text{Query}(p, i) = \text{Query}(p, i - 1)\).

\end{itemize}

Para determinar o ponto de interseção entre o segmento \(\overline{q'p'}\) e a aresta \(e\), implementamos o procedimento \algref{InterseçãoRetas}, que calcula a interseção entre duas retas dadas por dois pontos e suas direções. A demonstração desse procedimento é simples e pode ser feita algebricamente, mas não é o foco desse relatório. Também estamos assumindo que as retas não são paralelas, o que é garantido pela construção do algoritmo.

Agora podemos usar essas ideias para implementar o procedimento completo de resposta a consultas na forma do algoritmo \algref{Query}.

\begin{algorithm}
\alglabel{InterseçãoRetas}
\caption{InterseçãoRetas(\(s, d, s', d'\)) \\ Calcula a interseção entre as retas definidas por pontos \(s + td\) e \(s' + t'd'\), onde \(t, t' \in \mathbb{R}\)}

\(\Delta s \leftarrow s - s'\) \\
\(r \leftarrow (\Delta s \times d') / (d \times d')\)

\Return{} \(s + r d\) // Ponto de interseção

\end{algorithm}

\begin{algorithm}
\alglabel{Query}
\caption{Query(\(p, i\)) \\ Responde a consulta \(\text{Query}(p, i)\)}

\If {\(i = 0\)} {
	\Return{} \(s\) // Caso base
}

\(R \leftarrow\) LocalizaRegião(\(p\), \(P_i\)) \\
\(j \leftarrow \floor{R / 2}\)

\ \\
// Região de vértice \\
\If {\(R \pmod 2 = 0\)} {
	\Return {} Vértice \(j\) do polígono \(P_i[j]\)
}
\ \\
// Região de atravessa \\
\If {Aresta \(j\) de \(P_i\) não pertence à \(T_i\)} {
	\Return{} Query(\(p, i - 1\)) // Região de atravessa
}
\ \\
// Região de aresta \\
\(u \leftarrow \) Vértice \(j\) de \(P_i\) \\
\(v \leftarrow \) Vértice que segue \(u\) em \(P_i\) \\

\(p' \leftarrow u + \text{RefleteDireção}((p - u), u, v)\) \\
\(q' \leftarrow \text{Query}(p', i - 1)\) \\
\(m \leftarrow \text{InterseçãoDeRetas}(p', q' - p', u, v - u)\) \\

\Return{} \(m\) // Ponto de interseção

\end{algorithm}

\subsection{Calculando o Caminho Mínimo}

Agora que sabemos como responder consultas do tipo \(\text{Query}(p, i)\), calcular o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\) é trivial.

Pela definição de Query, sabemos que o menor caminho que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_k\) e termina em \(t\) deve ter como penúltimo ponto \(q_k = \text{Query}(t, k)\). Ademais, o caminho que toca os polígonos \(P_1, \dots, P_{k - 1}\) e termina em \(q_k\) deve ter como penúltimo ponto \(q_{k - 1} = \text{Query}(q_k, k - 1)\). Repetindo esse raciocínio, chegamos até o ponto inicial \(s\).

Usando essa lógica e juntando as implementações anteriores no algoritmo \algref{CaminhoMínimo}, podemos calcular o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\).

\begin{algorithm}
\alglabel{CaminhoMínimo}
\caption{CaminhoMínimo(\(s, t, P_1, \dots, P_k\)) \\ Calcula o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\)}

\If {\(k = 0\)} {
	\Return{} [\(s, t\)] // Caso base: caminho direto de \(s\) até \(t\)
}

\For {\(i \leftarrow 1\) até \(k\)} {
	\(T_i \leftarrow\) ArestasVisíveis(\(P_i\)) \\
	\(S_i\) \(\leftarrow\) ConstróiRegiõesDeVértice(\(P_i\)) \\
}

caminho \(\leftarrow []\) // Lista vazia para armazenar o caminho \\
\(p \leftarrow t\) // Começamos do ponto final \(t\) \\

\For {\(i \leftarrow k\) até \(1\)} {
	\(q \leftarrow \text{Query}(p, k)\) // Penúltimo ponto do \(k\)-path até \(p\) \\
	// Verificamos se os pontos \(p\) e \(q\) são distintos devido à regiões de atravessar \\
	\If {\(\abs{q - p} > 10 ^ {-8}\)} {
		caminho.\text{append}(\(p\)) // Adiciona \(p\) ao caminho \\
	}
	\(p \leftarrow q\) // Atualiza \(p\) para o próximo ponto \\
	\(k \leftarrow k - 1\) // Decrementa \(k\)
}

caminho.\text{append}(\(s\)) // Adiciona o ponto inicial \(s\) \\
caminho.\text{reverse}() // Inverte a lista para obter o caminho correto \\

\Return{} caminho

\end{algorithm}

\subsection{Análise de Complexidade}

Nessa seção, vamos analisar a complexidade do algoritmo completo. Primeiramente, a função LocalizaRegião leva tempo \(O(\log(\abs{P_i}))\) para localizar um ponto na partição \(S_i\), uma vez que usa busca binária. Ademais, a função Query faz uma chamada recursiva para \(i - 1\) em cada nível de recursão, resultando em \(i\) níveis de recursão. Assim, o tempo total para responder uma consulta \(\text{Query}(p, i)\) é \(O(i \log(\abs{P_i}))\).

\begin{itemize}
	
	\item RefleteDireção(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmVértice(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmAresta(\(\dots\)): \(O(1)\), pois faz um número constante de operações e chamadas para PontoEmVértice.
	
	\item LocalizaRegião(\(P_i\), \(\dots\)): \(O(\log \abs{P_i})\), pois usa busca binária em \(2 \abs{P_i} - 1\) regiões.
	
	\item Query\((i, \dots)\): Fazemos no máximo \(i\) chamadas recursivas, cada uma chama LocalizaRegião(\(P_i\), \(\dots\)) uma vez. Assim, temos a complexidade: 
	
	\[
		O\parens[\bigg]{\sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item ArestasVisíveis(\(P_i\), \(\dots\)): Chamamos Query para os \(\abs{P_i}\) vértices de \(P_i\), assim, temos uma complexidade final de:
	
	\[
		O\parens[\bigg]{\abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item ConstróiRegiõesDeVértice(\(P_i\), \(\dots\)): Chamamos Query para os \(\abs{P_i}\) vértices de \(P_i\), assim, temos uma complexidade final de:
	
	\[
		O\parens[\bigg]{\abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item CaminhoMínimo: Chamamos ArestasVisíveis e ConstróiRegiõesDeVértice para cada polígono \(P_1, \dots, P_k\)e então calculamos o caminho final cuja complexidade é insignificante próximo do primeiro passo, então a complexidade final é:

	\[
		O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

\end{itemize}

Enquanto podemos dizer que determinamos a complexidade final do problema, gotaríamos de ter uma forma mais simples e de acordo com o artigo original. Assim, definimos \(n = \sum_{i = 1}^{k} \abs{P_i}\) e note que:

\begin{align*}
	O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}} &= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log \abs{P_j}} \\
	&= O\parens[\bigg]{\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i}} \cdot \parens[\bigg]{\sum_{i = 1}^{k} \log{\abs{P_i}}}} \\
	&= O\parens[\bigg]{n \sum_{i = 1}^{k} \log{\abs{P_i}}}
\end{align*}

Ademais, se fixarmos o valor de \(k\), temos que o valor de \(\sum_{i = 1}^{k} \log \abs{P_i}\) é máximo quando \(\abs{P_1} = \dots = \abs{P_k} = n / k\). Dessa forma, concluimos que em um pior caso a complexidade é:

\[
	O(n k \log(n / k))
\]

Dessa forma, nosso algoritmo está de acordo com o artigo original.

\section{O Problema de Visita de Polígonos Geral}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema restrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem2.py}.

\subsection{Definições e Notação}

O problema segue de forma similar ao anterior, mas agora também recebemos como entrada `cercas' \(F_0, \dots, F_k\) tais que para todo \(0 \le i \le k\) vale que o polígono \(P_i\) e \(P_{i + 1}\) estão contidos em \(F_i\), para tal, consideramos \(P_0 = \{s\}\) e \(P_{k + 1} = \{t\}\). Nosso objetivo é encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\), toca cada polígono \(P_i\) em pelo menos um ponto e nunca sai da cerca \(F_i\) no seu caminho entre \(P_i\) e \(P_{i + 1}\).

Dizemos que um caminho \(\pi\) de \(a\) até \(b\) respeita as cercas \(F_i, \dots, F_j\) se \(\pi\) toca todos os polígonos \(P_{i + 1}, \dots, P_j\) e para cada \(i \le l < j\), o trecho de \(\pi\) entre \(P_l\) e \(P_{l + 1}\) está contido em \(F_l\). Ademais, definimos um \(i\)-path até \(p\) como um caminho mínimo de \(s\) até \(p\) que respeita as cercas \(F_0, \dots, F_i\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\).

A função central desse algoritmo continua sendo Query, no entanto, dessa vez vamos adicionar um novo parâmetro, assim, a função \(\text{Query}(p, i, j)\) recebe um ponto \(p\) e dois índices \(i\) e \(j\) e retorna o penúltimo ponto \(q\) do menor caminho até \(p\) que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_i\) e respeita as cercas \(F_0, \dots, F_j\).

Primeiramente, é essencial que \(i \le j\), ademais, se \(i = j\) então \(\text{Query}(p, i, j)\) é simplesmente o penúltimo ponto do \(i\)-path até \(p\). Adicionamos o parâmetro \(j\) para o caso em que queremos um \(i\)-path, mas \(p\) está fora da cerca \(F_i\) um caso que aparece naturalmente na recursão do algoritmo. Por enquanto, vamos assumir que sabemos como respoder as consultas.

\subsection{Caminhos Restritos}

Outra função extremamente importante para a implementação desse algoritmo é a função \(\text{Fenced}(p_1, p_2, i, j)\) que retorna o menor caminho de \(p_1\) até \(p_2\) que respeita as cercas \(F_i, \dots, F_j\). Note que se \(i = j\), então \(\text{Fenced}(p_1, p_2, i, j)\) é simplesmente o segmento \(\overline{p_1p_2}\) se ele estiver contido em \(F_i\) e não existe caso contrário. Assim, vamos assumir que \(i < j\).


\newpage
\appendix

\newpage
\printbibliography

\end{document}
