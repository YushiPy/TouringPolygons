
\documentclass{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\SetKwIF{If}{ElseIf}{Else}{if}{:}{else if}{else}{end}
\SetKwFor{For}{for}{:}{end}
\SetKwRepeat{Do}{do}{while}
\SetKwProg{Function}{def}{:}{}

\newcounter{algorithm}

% Command for referencing algorithms
\newcommand{\alglabel}[1]{%
	\refstepcounter{algorithm}%
	\label{alg:#1}%
}

\newcommand{\algref}[1]{\ref{alg:#1}}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\usepackage{cleveref}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blockquote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Counter for proof lines
\newcounter{proofline}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}
\DeclarePairedDelimiter{\anglebrackets}{\langle}{\rangle}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\begin{document}

\begin{titlepage}

\begin{center}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.3\textwidth]{logo-small.png} % Ajuste o caminho da imagem conforme necessário
	\end{figure}

	\vspace{2cm}

	{\Large \sc UNIVERSIDADE DE SÃO PAULO} \\
	{\Large \sc INSTITUTO DE MATEMÁTICA E ESTATÍSTICA} \\ [0.7cm]
	{\sc DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO} \\

	\vspace{2cm}

	\rule{\linewidth}{2pt}
	
	\vspace{0.2em} % Ajuste ao seu gosto
	{\Large \bfseries 
		O Problema da Visita de Polígonos \\
	}
	\vspace{0.2em} % Ajuste ao seu gosto
	
	\rule{\linewidth}{2pt} \\

\end{center}

\vspace{2.8cm}

\begin{center}
	{\large \bfseries Gabriel Freire Ushijima} \\
\end{center}

\vfill

% Data
\begin{center}
	\makeatletter
	{\large São Paulo, SP \\
	\@date}
	\makeatother
\end{center}

\end{titlepage}

\newpage

\tableofcontents

\newpage

\section{Introdução}

Este relatório descreve a implementação e os resultados obtidos na resolução do problema da visita de polígonos, usando como base o paper de Dror et al. (2003) \cite{tpp-dror2003} que descreve algoritmos para o caso sem e com restrições. Buscamos apresentar uma abordagem mais prática e detalhada para o problema, sem um foco tão grande na análise teórica.

Recomendamos a leitura do paper original para uma compreensão mais profunda dos conceitos e das provas por trás dos algoritmos apresentados aqui. Também é importante notar que este relatório não cobre todos os detalhes do paper, mas sim uma visão geral e a implementação prática dos algoritmos.

O código implementado pode ser encontrado no \href{https://github.com/YushiPy/TouringPolygons}{repositório GitHub}, contendo scripts em \textit{Python} para resolver ambos os casos do problema.

Finalmente, recomendamos a leitura do Apêndice \ref{sec:appendixA} para entender as notações usadas ao longo do relatório.

\section{O Problema de Visita de Polígonos Irrestrito}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema irrestrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem1.py}.

\subsection{Definindo o Problema}

\begin{wrapfigure}{r}{0.40\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.39\textwidth]{Problem1Images/solution.png}
	\caption{Caminho mínimo para um caso de 3 polígonos.}
	\label{problem1-solution}
\end{wrapfigure}

Considere o seguinte problema: dados dois pontos \(s, t \in \mathbb{R}^2\) e uma sequência de polígonos convexos disjuntos \(P_1, P_2, \ldots, P_k\), encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\) e toca cada polígono \(P_i\) em pelo menos um ponto, podendo atravessá-los.

A Figura~\ref{problem1-solution} ilustra um exemplo de entrada e a solução ótima para o problema para um caso com 3 polígonos. Temos \(s\) como o \textcolor[RGB]{0,128,0}{ponto verde}, \(t\) como o \textcolor[RGB]{255, 0, 0}{ponto vermelho} e os polígonos \(P_1, P_2\) e \(P_3\) como o \textcolor[RGB]{76, 146, 195}{triângulo azul}, o \textcolor[RGB]{255, 152, 62}{trapézio laranja} e o \textcolor[RGB]{86, 179, 86}{pentágono verde}, respectivamente. O caminho mínimo é representado pela \textcolor[RGB]{145, 41, 145}{linha roxa}.
% como o ponto verde, \(t\) como o ponto vermelho e os polígonos \(P_1, P_2\) e \(P_3\) como o triângulo azul, o trapézio laranja e o pentágono verde, respectivamente. O caminho mínimo é representado pela linha roxa.

Retomando o paper, definimos um \(i\)-path até \(p\) como um caminho mínimo que começa em \(s\), encosta em cada um dos polígonos \(P_1, P_2, \ldots, P_i\) e termina em \(p\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\). Enquanto não vamos entrar em detalhes, todo \(i\)-path é único.

A função central desse algoritmo será a função \(\text{Query}(p, i)\), que recebe um ponto \(p\) e um índice \(i\) e retorna o penúltimo ponto \(q\) do \(i\)-path até \(p\) (ou seja, o ponto imediatamente anterior à \(p\) nesse caminho). 

Primeiramente, vamos descrever procedimentos auxiliares que serão úteis para a implementação da função \(\text{Query}\). Finalmente, vamos descrever como respoder consultas usando esses procedimentos. Por enquanto, vamos assumir que sabemos como respoder as consultas. Para as seções a seguir, vamos assumir que os polígnos \(P_1, \dots, P_k\) são representados por listas de vértices ordenados em sentido anti-horário, com um vértice abitrário como o primeiro.

\subsection{Particionando o Plano}

É possível mostrar \cite{tpp-dror2003} que para cada polígono \(P_i\) podemos criar uma partição \(S_i\) do plano tal que o comportamento da função \(\text{Query}(p, i)\) dependa exclusivamente de a qual região da partição \(S_i\) o ponto \(p\) pertence, sendo possível localizar cada ponto de maneira eficiente. Por falta de um nome melhor, chamamos cada parte de \(S_i\) de \textit{região}.

Nas seções a seguir vamos descrever como usar essas partições para responder consultas, mas por enquanto vamos descrever como representar e construir essas partições. Por enquanto, apenas mantenha em mente que se conseguirmos representar e construir essas partições, então podemos usá-las para responder consultas e resolver o problema de maneira eficiente.

Enquanto a quantidade de regiões de \(S_i\) pode ser numerosa a depender do número de vértices de \(P_i\), cada região pode ser de exatamente 3 tipos diferentes:, 
% \textcolor[RGB]{255, 140, 140}{Regiões de Vértice}, \textcolor[RGB]{140, 197, 140}{Regiões de Aresta} e \textcolor[RGB]{150, 208, 209}{Regiões de Atravessa}.
\textcolor[RGB]{255, 70, 70}{Regiões de Vértice}, \textcolor[RGB]{86, 179, 86}{Regiões de Aresta} e \textcolor[RGB]{76, 146, 195}{Regiões de Atravessar}.

\begin{wrapfigure}{l}{0.60\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.6\textwidth]{Problem1Images/partitions.png}
	\caption{Partição do plano para cada polígono do exemplo anterior.}
	\label{problem1-partitions}

\end{wrapfigure}

A partir da Figura~\ref{problem1-partitions}, note que cada região de vértice (\textit{Cone Region}) está associada a um vértice de \(P_i\), cada região de aresta (\textit{Edge Region}) está associada a uma aresta de \(P_i\) e há exatamente uma região de atravessar (\textit{Pass Through Region}). Ademais, essas regiões se complementam, ou seja, o conjunto de todas as regiões de vértice, aresta e atravessar é o plano todo e nenhuma região se sobrepõe a outra. Para que isso seja válido, devemos considerar pontos dentro dos polígonos \(P_i\) como pertencentes à região de atravessar. As fronteiras entre as regiões podem ser consideradas como pertencentes a qualquer uma das regiões que as delimitam, produzindo o mesmo resultado, mas para simplicidade, vamos considerar que pertencem às regiões de vértice.

Ademais, note que cada região de vértice é delimitada por duas semi-retas que partem de um vértice de \(P_i\), incluindo todos os pontos que estão entre essas semi-retas. Similarmente, cada região de aresta é delimitada por duas semi-retas que partem dos extremos de uma aresta de \(P_i\) e a prórpia aresta, incluindo todos os pontos que estão entre essas semi-retas e a aresta. Finalmente, a região de atravessar é o complemento das regiões de vértice e aresta.

\subsubsection{Região de Primeiro Contato}

Para cada polígono \(P_i\), definimos \(T_i\) como a \textit{região de primeiro contato} de \(P_i\), ou seja, o conjunto de pontos \(p\) no perímetro de \(P_i\) tais que o \((i - 1)\)-path até \(p\) toca em \(P_i\) pela primeira vez em \(p\). Podemos provar \cite{tpp-dror2003} que \(T_i\) é uma região contínua do perímetro de \(P_i\) e que \(T_i\) é delimitada por vértices de \(P_i\), ou seja, \(T_i\) é a união de uma sequência de arestas consecutivas de \(P_i\). Por esse motivo, chamamos arestas de \(P_i\) que pertencem à \(T_i\) de \textbf{arestas visíveis} e as que não pertencem de \textbf{arestas bloqueadas}.

\begin{wrapfigure}{r}{0.45\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.45\textwidth]{Problem1Images/visibility-test.png}
	\caption{Testando aresta para região de primeiro contato.}
	\label{problem1-visibility-test}

\end{wrapfigure}

Essa região é importante, pois apenas as arestas visíveis de \(P_i\) que pertencem à \(T_i\) geram regiões de aresta em \(S_i\), além disso, se um vértice está entre duas arestas bloqueadas, então ele não gera uma região de vértice em \(S_i\).

Como \(T_i\) é a união de arestas, para determinar quais arestas de \(P_i\) pertencem à \(T_i\), podemos simplesmente iterar sobre as arestas de \(P_i\) e verificar se o \((i - 1)\)-path até um ponto interno qualquer da aresta, por exemplo o ponto médio, chega em \(P_i\) pela primeira vez nesse ponto. Se isso for verdade, então a aresta pertence à \(T_i\), caso contrário, não pertence.

No entanto, precisamos de uma maneira eficiente de fazer isso para todas as arestas de \(P_i\). Se simplesmente fizermos isso de maneira ingênua, verificando se o segmento entre o último ponto \(q\) do \((i - 1)\)-path até o ponto médio \(m\) da aresta intersecta \(P_i\), teríamos uma complexidade de \(O(\abs{P_i})\) por aresta, resultando em \(O(\abs{P_i} ^ 2)\) para todas as arestas de \(P_i\). 

Felizmente, como \(P_i\) é convexo e suas arestas estão ordenadas em sentido anti-horário, sabemos que o segmento \(\overline{qm}\) toca \(P_i\) pela primeira vez em \(m\) se e somente se o produto vetorial de \(\overrightarrow{mv}\) com \(\overrightarrow{mq}\) for positivo. Usando essa ideia, podemos determinar todas as arestas visíveis de \(P_i\) em tempo \(O(1)\) por aresta, totalizando \(O(\abs{P_i})\).

A Figura~\ref{problem1-visibility-test} ilustra essa ideia. Temos o polígono \(P_i\) em azul, os vértices \(u\) e \(v\) em azul, o ponto médio \(m\) da aresta em laranja e 4 pontos \(q_1, q_2, q_3\) e \(q_4\) representando possíveis últimos pontos do \((i - 1)\)-path até \(m\). Note que os segmentos \(\overline{q_1 m}\) e \(\overline{q_2 m}\) passam pela parte interna de \(P_i\), assim, o produto vetorial de \(\overrightarrow{uv}\) com \(\overrightarrow{m q_1}\) e \(\overrightarrow{m q_2}\) é positivo. Já os segmentos \(\overline{q_3 m}\) e \(\overline{q_4 m}\) não passam pela parte interna de \(P_i\), assim, o produto vetorial de \(\overrightarrow{uv}\) com \(\overrightarrow{m q_3}\) e \(\overrightarrow{m q_4}\) é negativo.

Implementamos essa ideia no algoritmo \algref{ArestasVisíveis}, que recebe um polígono \(P_i\) e seu índice \(i\) e retorna uma lista booleana indicando quais arestas de \(P_i\) são visíveis.

\begin{algorithm}
\alglabel{ArestasVisíveis}
\caption{ArestasVisíveis(\(P_i\)) \\ Determina as arestas visíveis de \(P_i\)}

\(n \leftarrow \abs{P_i}\) // Número de vértices de \(P_i\) \\
visível \(\leftarrow\) [False] * \(n\) // Inicializa todas as arestas como não visíveis \\

\For {\(j \leftarrow 0\) até \(n - 1\)} {
	\(u \leftarrow\) \(j\)-ésimo vértice de \(P_i\) \\
	\(v \leftarrow\) vértice que segue \(u\) em \(P_i\) \\
	\(m \leftarrow (u + v) / 2\) // ponto médio \\
	\(q \leftarrow \text{Query}(m, i - 1)\) // penúltimo ponto do \((i - 1)\)-path até \(m\) \\
	
	\ \\
	// Marca a aresta \(j\) como visível se o produto vetorial for negativo \\
	visível[\(j\)] \(\leftarrow ((v - m) \times (q - m) < 0)\) 
}

\Return{} visível % Evita math mode desnecessário

\end{algorithm}

\subsubsection{Construindo Regiões de Vértice}

Uma vez que sabemos quais arestas são visíveis, podemos construir as regiões de vértice. Observamos anteriormente que essas são delimitadas por duas semi-retas que partem de um vértice de \(P_i\). Por esse motivo, nessa etapa, à cada vértice \(v\) vamos associar um par ordenado de direções \((d_{\text{prev}}, d_{\text{next}})\) tais que a região de vértice associada a \(v\) são os pontos entre as semi-retas que partem de \(v\) nas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\), no sentido anti-horário.

\begin{wrapfigure}{r}{0.40\textwidth}

	\vspace{-5pt}
	\centering
	\includegraphics[width=0.4\textwidth]{Problem1Images/scene-general.png}
	\caption{Partição de um polígono com múltiplas arestas não visíveis.}
	\label{problem1-scene-general}

\end{wrapfigure}

Para calcular as direções da regiões de vértice de um vértice \(v\) de \(P_i\), devemos considerar o ponto \(p = \text{Query}(v, i - 1)\) e definimos \(d = v - p\). Sejam \(v_{\text{prev}}\) o vértice que precede e \(v_{\text{next}}\) o que segue \(v\) em \(P_i\) (no sentido anti-horário). Se a aresta \((v_{\text{prev}}, v)\) é visível, então \(d_{\text{prev}}\) será a reflexão de \(d\) em relação à aresta \((v_{\text{prev}}, v)\), caso contrário, \(d_{\text{prev}}\) será a mesma direção de \(d\). Similarmente, se a aresta \((v, v_{\text{next}})\) é visível, então \(d_{\text{next}}\) será a reflexão de \(d\) em relação à aresta \((v, v_{\text{next}})\), caso contrário, \(d_{\text{next}}\) será a mesma direção de \(d\). Assim, criamos a região de vértice \((d_{\text{next}}, d_{\text{next}})\) associada à \(v\).

Vale notar que se ambas as arestas incidentes a \(v\) estão bloqueadas, então \(d_{\text{prev}} = d_{\text{next}} = d\), assim, a região de vértice associada a \(v\) é válida, mas vazia.

Encorajamos o leitor a verificar que essa lógica se aplica à Figura~\ref{problem1-scene-general}, usando o ponto inicial \(s\) como resposta de \(\text{Query}(v, 0)\) para qualquer vértice \(v\). Os vértices (-2, 0) e (0, 0) terão as suas duas arestas incidentes visíveis, assim, suas regiões de vértice serão delimitadas pelas reflexões do raio que parte de \(s\). O vértice (-3, 1) terá apenas a aresta posterior visível, assim, sua região de vértice será delimitada pela reflexão do raio em relação à aresta posterior e a própria direção do raio. Similarmente, o vértice (2, 1) tem apenas a aresta anterior visível. Finalmente, os vértices (1, 1.25) e (-1, 1.5) não terão nenhuma aresta visível, assim, suas regiões de vértice serão vazias. 

Implementamos essas ideias nos algoritmos \algref{RefleteDireção} e \algref{ConstróiRegiõesDeVértice}. O primeiro reflete uma direção em relação a uma aresta, enquanto o segundo a partição \(S_i\) de um polígono \(P_i\), retornando uma lista de pares ordenados de direções representando as regiões de vértice associadas a cada vértice de \(P_i\).

% \textcolor{red}{Verificar se podemos aqui apenas dizer que estes vertices terao uma regiao de vertice vazia ou dizer que estes vertices nao pertencem à regiao de pimeiro contato e portanto não tem uma regiao de vertice associada a eles.}

\begin{algorithm}
\alglabel{RefleteDireção}
\caption{RefleteDireção(\(d, v_{\text{prev}}, v_{\text{next}}\)) \\ Reflete a direção \(d\) em relação à aresta \((v_{\text{prev}}, v_{\text{next}})\)}

\(u \leftarrow v_{\text{prev}} - v_{\text{next}}\) \\
\(w \leftarrow \) Vetor normal à \(u\), tal que \(\abs{w} = 1\) \\
\Return{\(d - 2 \anglebrackets{d, w} w\)} // Fórmula de reflexão

\end{algorithm}

\begin{algorithm}
\alglabel{ConstróiRegiõesDeVértice}
\caption{ConstróiRegiõesDeVértice(\(P_i\)) \\ Constroi as partições do polígono \(P_i\)}

regiões \(\leftarrow\) [] // Lista vazia \\
visível \(\leftarrow \text{ArestasVisíveis}(P_i)\) \\

\For{\(j \leftarrow 0\) até \(\abs{P_i} - 1\)} {

	\(v \leftarrow\) \(j\)-ésimo vértice de \(P_i\) \\
	\(v_{\text{prev}} \leftarrow\) vértice que precede \(v\) em \(P_i\) \\
	\(v_{\text{next}} \leftarrow\) vértice que segue \(v\) em \(P_i\) \\
	
	\ \\
	
	\(p \leftarrow \text{Query}(v, i - 1)\) // penúltimo ponto do \((i - 1)\)-path até \(v\) \\
	\(d \leftarrow v - p\) // direção do raio de \(p\) até \(v\) \\
	
	\ \\

	\If{visível[\(j - 1\)]} {
		\(d_{\text{prev}} \leftarrow \text{Reflete}(d, v_{\text{prev}}, v)\) // reflexão de \(d\) em relação à aresta \((v_{\text{prev}}, v)\)
	}
	\Else {
		\(d_{\text{prev}} \leftarrow d\)
	}
	
	\If{visível[\(j\)]} {
		\(d_{\text{next}} \leftarrow \text{Reflete}(d, v, v_{\text{next}})\) // reflexão de \(d\) em relação à aresta \((v, v_{\text{next}})\)
	}
	\Else {
		\(d_{\text{next}} \leftarrow d\)
	}
	
	// Armazena a região de vértice associada a \(v\) como o par \((d_{\text{prev}}, d_{\text{next}})\) \\
	regiões.\text{append}(\((d_{\text{prev}}, d_{\text{next}})\)) \\
}

\Return{} regiões % Evita math mode desnecessário

\end{algorithm}

\subsection{Localizando Pontos na Partição}

Gostariamos de responder consultas do tipo \(\text{Query}(p, i)\) de maneira eficiente. Para isso, precisamos ser capazes de localizar o ponto \(p\) na partição \(S_i\) de maneira eficiente, ou seja, determinar se \(p\) pertence a uma região de vértice, região de aresta ou região de atravessar e, em caso positivo, qual região.

Esse processo não é trivial, principalmente se desejamos fazer isso de maneira eficiente. Para tal, primeiro vamos considerar dois problemas mais simples: determinar se \(p\) pertence a uma região de vértice e determinar se \(p\) pertence a uma região de aresta.

\subsubsection{Verificando Regiões de Vértice}

Primeiramente vamos implementar um procedimento auxiliar \algref{PontoEmVértice} que verifica se um ponto \(p\) está em uma região de vértice associada a um vértice \(v\) delimitada por duas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\). Basicamente, temos dois casos, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\) (considerando o sentido anti-horário):

\begin{itemize}

	\item Ângulo \(\le 180 ^ \circ\): Nesse caso, \(p\) deve estar à esquerda de \(d_{\text{prev}}\) e à direita de \(d_{\text{next}}\).

	\item Ângulo \(> 180 ^ \circ\): Nesse caso, \(p\) deve estar à direita de \(d_{\text{prev}}\) ou à esquerda de \(d_{\text{next}}\).

\end{itemize}

Podemos usar produtos vetoriais para determinar a posição relativa de \(p\) em relação às direções \(d_{\text{prev}}\) e \(d_{\text{next}}\), assim como o ângulo entre essas direções. Usando essas ideias, implementamos o procedimento no algoritmo \algref{PontoEmVértice}.

\begin{algorithm}
\alglabel{PontoEmVértice}
\caption{PontoEmVértice(\(p\), \(v\), \(d_{\text{prev}}\), \(d_{\text{next}}\)) \\
Verifica se o ponto \(p\) está na região de vértice associada ao vértice \(v\) delimitada pelas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\)}

\(c_1 \leftarrow (d_{\text{prev}} \times (p - v) \ge 0)\) \\
\(c_2 \leftarrow (d_{\text{next}} \times (p - v) \le 0)\)

\If {\(d_{\text{prev}} \times d_{\text{next}} \ge 0\)} {
	\Return{} \(c_1 \land c_2\)
	}
\Else {
	\Return{} \(c_1 \lor c_2\)
}

\end{algorithm}

\subsubsection{Verificando Regiões de Aresta}

Uma vez que conseguimos verificar se um ponto pertence a uma região de vértice, podemos usar essa funcionalidade para verificar se um ponto pertence a uma região de aresta. 

\begin{wrapfigure}{l}{0.69\textwidth} % 'r' for right, 'l' for left
    \centering
    \vspace{-1em} % adjust vertical alignment if needed
	\includegraphics[width=0.68\textwidth]{Problem1Images/edge-regions.png}
    \caption{Casos possíveis para região de aresta.}
	\label{problem1-edge-regions}
\end{wrapfigure}

Esse problema é mais complexo, uma vez que existem diferentes casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\). Esses casos não aparecem explicitamente na partição \(S_i\), na verdade apenas o primeiro caso aparece. No entanto, vamos usar esses outros casos adicionais para otimizar a localização de pontos na partição posteriormente, permitindo complexidade \(\log(\abs{P_i})\) para detecção.

Essencialmente existem 4 casos possíveis para uma região de aresta, dependendo do ângulo entre as direções \(d_{\text{prev}}\) e \(d_{\text{next}}\). A Figura \ref{problem1-edge-regions} ilustra esses casos. Para sabermos com qual caso estamos lidando, definimos \(w = v - u\) e calculamos os produtos vetoriais \(c_1 = w \times d_{\text{prev}}\) e \(c_2 = w \times d_{\text{next}}\). Agora, temos os seguintes casos:

\begin{itemize}

	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado negativo}, que é o caso tradicional que aparece na partição \(S_i\). Nesse caso, verificamos se \(p\) está entre as semi-retas e a aresta \((u, v)\) usando produtos vetoriais.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado negativo e aresta posterior no lado positivo}, o \textit{Caso 1} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_{\text{prev}}, u - v)\) e \((v, u - v, d_{\text{next}})\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{aresta anterior no lado positivo e aresta posterior no lado negativo}, o \textit{Caso 2} na figura. Nesse caso, dividimos a região de aresta em duas regiões de vértice, definidas por \((u, d_{\text{prev}}, v - u)\) e \((v, v - u, d_{\text{next}})\), então verificamos se o ponto está em qualquer uma das duas.
	
	\item \(c_1 \le 0 \land c_2 \le 0\): Esse é o caso em que temos \textbf{ambas arestas no lado positivo}. Nesse caso, simplesmente verificamos se o ponto não pertence ao complemento da região, ou seja, verificamos se \(p\) não pertence à região de aresta definida por \((v, u, d_{\text{next}}, d_{\text{prev}})\).
\end{itemize}

Dessa forma, conseguimos verificar se um ponto pertence a uma região de aresta usando o procedimento de verificação de regiões de vértice. Agora podemos implementar o procedimento completo na forma de um algoritmo.

\begin{algorithm}
\caption{PontoEmAresta(\(p\), \(u\), \(v\), \(d_{\text{prev}}, d_{\text{next}}\)) \\
Verifica se o ponto \(p\) está na região de aresta associada à aresta \(e = (u, v)\) delimitada pelas direções \(d_{\text{prev}}\) e \(d_{\text{next}}\)}

// Se vértices são muito próximos, tratamos a região de aresta \\
// como uma região de vértice. \\
\If {\(\abs{u - v} < 10 ^ {-8}\)} {
	\Return {} PontoEmVértice(\(p\), \(v\), \(d_{\text{next}}\), \(d_{\text{prev}}\))
}

\(w \leftarrow v - u\) \\
\(c_1 \leftarrow d_{\text{prev}} \times w\) \\
\(c_2 \leftarrow w \times d_{\text{next}}\) \\

\If {\(c_1 \le 0 \land c_2 \le 0\)} {
	\Return{} \((d_{\text{prev}} \times (p - u) \ge 0) \land ((p - u) \times d_{\text{next}} \le 0) \land ((v - u) \times (p - u) \le 0)\)
}
\ElseIf {\(c_1 \le 0 \land c_2 > 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_{\text{prev}}\), \(u - v\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(u - v\), \(d_{\text{next}}\))
}
\ElseIf {\(c_1 > 0 \land c_2 \le 0\)} {
	\Return{} PontoEmVértice(\(p\), \(u\), \(d_{\text{prev}}\), \(v - u\)) \(\lor\) PontoEmVértice(\(p\), \(v\), \(v - u\), \(d_{\text{next}}\))
}
\Else {
	\Return{} \(\lnot\) PontoEmAresta(\(p\), \(v\), \(u\), \(d_{\text{next}}\), \(d_{\text{prev}}\))
}

\end{algorithm}

\subsubsection{Localização Eficiente de Pontos na Partição}

Agora que sabemos como verificar se um ponto pertence a uma região de vértice ou de aresta, podemos usar essas funcionalidades para localizar um ponto \(p\) na partição \(S_i\). Uma abordagem ingênua seria iterar sobre todas as regiões de vértice e aresta, verificando se \(p\) pertence a alguma delas. Isso funcionaria, no entanto, essa abordagem tomaria tempo \(O(\abs{P_i})\), o que é muito lento.

Por esse motivo, desejamos explorar a ideia de busca binária para resolver o problema. Primeiramente, vamos assumir que o ponto não pertence ao polígono \(P_i\), isso vale como suposição inicial dos polígonos serem disjuntos e os pontos \(s\) e \(t\) estarem fora dos polígonos. Ainda assim, se desejássemos evitar essa suposição, poderíamos simplesmente verificar se o ponto está dentro do polígono \(P_i\) usando um teste de ponto em polígono antes de localizar o ponto na partição, o é um problema clássico que leva tempo \(O(\log(\abs{P_i}))\).

Uma questão que diferencia nosso problema de uma busca binária tradicional é que as regiões são circulares. Assim, o primeiro passo é verificar se o ponto pertence à região entre o último e o primeiro vértice de \(P_i\). Se sim, retornamos essa região. Caso contrário, reduzimos o problema para uma lista linear de regiões.

Outra diferença que precisamos considerar é que nossa entrada contém dois tipos de regiões: regiões de vértice e regiões de aresta. Para lidar com isso, podemos tratar regiões de vértice como regiões de aresta degeneradas, onde a aresta tem comprimento zero. Dessa forma, podemos aplicar o mesmo raciocínio para ambos os tipos de regiões, lidando com uma lista de \(2 \abs{P_i} - 1\) regiões de aresta, uma vez que já eliminamos a última. Note que a implementação de PontoEmAresta já lida com esse caso especial.

Finalmente, podemos implementar a busca binária propriamente dita. A ideia é manter dois índices \(l\) e \(r\) que representam o intervalo atual de regiões que estamos considerando. Inicialmente, definimos \(n = \abs{P_i}\), \(l = 0\) e \(r = 2n - 1\). Nos baseamos na ideia de que apenas as regiões após \(l\) e antes de \(r\) podem conter o ponto \(p\), ambos limites inclusivos. 

Enquanto \(l + 1 \ne r\), calculamos o índice médio \(m = \floor{(l + r) / 2}\) e verificamos se o ponto \(p\) pertence à região de aresta entre \(l\) e \(m\). Se estiver, atualizamos \(r = m\), caso contrário, atualizamos \(l = m\), isso vale pois \(P_i\) é convexo e a região de aresta entre \(l\) e \(m\) cobre todas as regiões entre \(l\) e \(m\) e nenhuma região entre \(m\) e \(r\).

Repetindo isso até que \(l + 1 = r\), sabemos que o ponto \(p\) pertence à região de aresta entre \(l\) e \(r\). Finalmente, retornamos essa região, vamos codificar essa região como um inteiro que representa o índice da região.

Essa codificação segue a seguinte lógica: regiões de vértice são representadas por índices pares, onde o índice \(2j\) representa a região de vértice associada ao \(j\)-ésimo vértice de \(P_i\). Regiões de aresta são representadas por índices ímpares, onde o índice \(2j + 1\) representa a região de aresta entre o \(j\)-ésimo e o \((j + 1)\)-ésimo vértice de \(P_i\). Note que a região entre o último e o primeiro vértice é representada pelo índice \(2 \abs{P_i} - 1\).

\begin{algorithm}
\caption{LocalizaRegião(\(p\), \(P\), regiõesDeVértice) \\
Localiza o ponto \(p\) na partição do polígono \(P\)}


// Criamos uma função auxiliar usando fechamento \\
// para facilitar a implementação da busca binária \\
\Function{pertence(\(i\), \(j\))} {

	\(v_1 \leftarrow P[\floor{i / 2}]\) // Vértice \(i\) do polígono \(P\) \\
	\(v_2 \leftarrow P[\floor{j / 2}]\) // Vértice \(j\) do polígono \(P\) \\


	// Vamos lembrar que \textit{regiõesDeVértice} é uma lista de pares \((d_{\text{prev}}, d_{\text{next}})\) \\
	// Também vamos tratar \(i \pmod 2\) como uma operação tradicional de módulo \\
	\(d_{\text{prev}} \leftarrow \text{regiõesDeVértice}[\floor{i / 2}][i \pmod 2]\) \\
	\(d_{\text{next}} \leftarrow \text{regiõesDeVértice}[\floor{j / 2}][j \pmod 2]\) \\

	\Return{} PontoEmAresta(\(p\), \(v_1\), \(v_2\), \(d_{\text{prev}}\), \(d_{\text{next}}\))
}

\(l \leftarrow 0\)
\(r \leftarrow 2 \cdot \abs{P} - 1\) \\

\If {pertence(\(r\), \(0\))} {
	\Return{} \(r\) // Ponto pertence à região entre o último e o primeiro vértice
}

\While {\(l + 1 \ne r\)} {

	\(m \leftarrow \floor{(l + r) / 2}\) \\
	
	\If {pertence(\(l\), \(m\))} {
		\(r \leftarrow m\)
	}
	\Else {
		\(l \leftarrow m\)
	}
}

\Return{} \(l\) // Ponto pertence à região entre \(l\) e \(r\)

\end{algorithm}

\subsection{Respondendo Consultas}

Finalemnte, podemos descrever como responder consultas do tipo \(\text{Query}(p, i)\) usando as partições \(S_i\) que construímos anteriormente. O procedimento utilizado é recursivo, assim, primeiro definimos o caso base, que é \(\text{Query}(p, 0) = s\), uma vez que um \(0\)-path não precisa tocar em nenhum polígono, assim, o menor caminho é uma linha reta de \(s\) até \(p\).

Para \(i > 0\), primeiramente determinamos a região \(R\) de \(S_i\) que contém \(p\). Uma vez que sabemos qual região contém \(p\), podemos responder a consulta dependendo do tipo de região:

\begin{itemize}

	\item Região de Vértice: Seja \(R = (v, d_{\text{prev}}, d_{\text{next}})\). Nesse caso, o \(i\)-path até \(p\) deve passar pelo vértice \(v\), tocando o polígono \(P_i\). Assim, temos que \(\text{Query}(p, i) = v\).
	
	\item Região de Aresta: Seja \(R = (u, v, d_{\text{prev}}, d_{\text{next}})\). Nesse caso, o \(i\)-path até \(p\) deve passar por algum ponto \(q\) da aresta \(e = (u, v)\), tocando o polígono \(P_i\). Para calcular \(q\), primeiro determinamos \(q' = \text{Query}(p', i - 1)\), onde \(p'\) é a reflexão de \(p\) em relação à aresta \(e\). 
	Agora, dizemos que \(q\) é a interseção entre \(\overline{q'p'}\) e a aresta \(e\). Finalmente, respondemos \(\text{Query}(p, i) = q\).

	\item Região de Atravessa: Seja \(R\) a região de atravessa. Nesse caso, o \(i\)-path até \(p\) automaticamente atravessa o polígono \(P_i\) em algum ponto. Portanto, podemos simplesmente responder \(\text{Query}(p, i) = \text{Query}(p, i - 1)\).

\end{itemize}

Agora vamos implementar esse procedimento como um algoritmo, usando as contruções que fizemos anteriormente, uma vez que é um pouco mais complexo do que a descrição acima. 

Vamos usar também uma função auxiliar \text{InterseçãoDeSegmento} que calcula a interseção entre dois segmentos dados seus extremos. Essa não é descrita aqui, mas é uma implementação padrão de geometria computacional.

\begin{algorithm}
\caption{Query(\(p, i\)) \\ Responde a consulta \(\text{Query}(p, i)\)}

\If {\(i = 0\)} {
	\Return{} \(s\) // Caso base
}

\(R \leftarrow\) LocalizaRegião(\(p\), \(P_i\), regiõesDeVértice[\(i - 1\)]) \\
\(j \leftarrow \floor{R / 2}\)

\If {\(R \pmod 2 = 0\)} {
	\Return {} \(v \leftarrow P_i[j]\) // Vértice associado à região de vértice
}

\If {\(\lnot\) visível[\(j\)]} {
	\Return{} Query(\(p, i - 1\)) // Região de atravessa
}

// Região de aresta \\
\(u \leftarrow P_i[j]\) // Vértice inicial da aresta \\
\(v \leftarrow P_i[j + 1]\) // Vértice final da aresta \\

\(p' \leftarrow u + \text{RefleteDireção}((p - u), u, v)\) \\
\(q' \leftarrow \text{Query}(p', i - 1)\) \\
\(m \leftarrow \text{InterseçãoDeSegmento}(p', q', u, v)\) \\

\Return{} \(m\) // Ponto de interseção

\end{algorithm}

\subsection{Calculando o Caminho Mínimo}

Agora que sabemos como responder consultas do tipo \(\text{Query}(p, i)\), calcular o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\) é trivial.

Pela definição de Query, sabemos que o menor caminho que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_k\) e termina em \(t\) deve ter como penúltimo ponto \(q_k = \text{Query}(t, k)\). Ademais, o caminho que toca os polígonos \(P_1, \dots, P_{k - 1}\) e termina em \(q_k\) deve ter como penúltimo ponto \(q_{k - 1} = \text{Query}(q_k, k - 1)\). Repetindo esse raciocínio, chegamos até o ponto inicial \(s\).

Usando essa lógica e juntando as implementações anteriores em um algoritmo completo, temos:

\begin{algorithm}
\caption{CaminhoMínimo(\(s, t, P_1, \dots, P_k\)) \\ Calcula o caminho mínimo de \(s\) até \(t\) que toca todos os polígonos \(P_1, \dots, P_k\)}

\If {\(k = 0\)} {
	\Return{} [\(s, t\)] // Caso base: caminho direto de \(s\) até \(t\)
}

regiãoDeVértice \(\leftarrow\) Particiona(\(P_1, \dots, P_k\)) \\
caminho \(\leftarrow []\) // Lista vazia para armazenar o caminho \\
\(p \leftarrow t\) // Começamos do ponto final \(t\) \\

\For {\(i \leftarrow k\) até \(1\)} {
	\(q \leftarrow \text{Query}(p, k)\) // Penúltimo ponto do \(k\)-path até \(p\) \\
	// Verificamos se os pontos \(p\) e \(q\) são distintos devido à regiões de atravessar \\
	\If {\(\abs{q - p} > 10 ^ {-8}\)} {
		caminho.\text{append}(\(p\)) // Adiciona \(p\) ao caminho \\
	}
	\(p \leftarrow q\) // Atualiza \(p\) para o próximo ponto \\
	\(k \leftarrow k - 1\) // Decrementa \(k\)
}

caminho.\text{append}(\(s\)) // Adiciona o ponto inicial \(s\) \\
caminho.\text{reverse}() // Inverte a lista para obter o caminho correto \\

\Return{} caminho

\end{algorithm}

\subsection{Análise de Complexidade}

Nessa seção, vamos analisar a complexidade do algoritmo completo. Primeiramente, a função LocalizaRegião leva tempo \(O(\log(\abs{P_i}))\) para localizar um ponto na partição \(S_i\), uma vez que usa busca binária. Ademais, a função Query faz uma chamada recursiva para \(i - 1\) em cada nível de recursão, resultando em \(i\) níveis de recursão. Assim, o tempo total para responder uma consulta \(\text{Query}(p, i)\) é \(O(i \log(\abs{P_i}))\).

\begin{itemize}
	
	\item RefleteDireção(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmVértice(\(\dots\)): \(O(1)\), pois faz um número constante de operações.
	\item PontoEmAresta(\(\dots\)): \(O(1)\), pois faz um número constante de operações e chamadas para PontoEmVértice.
	
	\item LocalizaRegião(\(P_i\), \(\dots\)): \(O(\log \abs{P_i})\), pois usa busca binária em \(2 \abs{P_i} - 1\) regiões.
	
	\item Query\((i, \dots)\): Fazemos no máximo \(i\) chamadas recursivas, cada uma chama LocalizaRegião \(p\) umas vez. Assim, temos a complexidade: 
	
	\[
		O\parens[\bigg]{\sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item ArestasVisíveis(\(P_i\), \(\dots\)): Chamamos Query para os \(\abs{P_i}\) vértices de \(P_i\), assim, temos uma complexidade final de:
	
	\[
		O\parens[\bigg]{\abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]
	
	\item Particiona(\(P_1, \dots, P_n\)): Chamamos ArestasVisíveis para cada polígono \(P_i\), assim, temos:
	
	\[
		O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

	\item CaminhoMínimo: Chamamos Particiona uma única vez e então calculamos o caminho final cuja complexidade é insignificante próximo de Particiona, então a complexidade final é a mesma:

	\[
		O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}}
	\]

\end{itemize}

Enquanto podemos dizer que determinamos a complexidade final do problema, gotaríamos de ter uma forma mais simples e de acordo com o artigo original. Assim, definimos \(n = \sum_{i = 1}^{k} \abs{P_i}\) e note que:

\begin{align*}
	O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{i} \log \abs{P_j}} &= O\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i} \sum_{j = 1}^{k} \log \abs{P_j}} \\
	&= O\parens[\bigg]{\parens[\bigg]{\sum_{i = 1}^{k} \abs{P_i}} \cdot \parens[\bigg]{\sum_{i = 1}^{k} \log{\abs{P_i}}}} \\
	&= O\parens[\bigg]{n \sum_{i = 1}^{k} \log{\abs{P_i}}}
\end{align*}

Ademais, se fixarmos o valor de \(k\), temos que o valor de \(\sum_{i = 1}^{k} \log \abs{P_i}\) é máximo quando \(\abs{P_1} = \dots = \abs{P_k} = n / k\). Dessa forma, concluimos que em um pior caso a complexidade é:

\[
	O(n k \log(n / k))
\]

Dessa forma, nosso algoritmo está de acordo com o artigo original.

\section{O Problema de Visita de Polígonos Geral}

Vamos tomar como base a implementação do algoritmo de Mitchell para o problema restrito que fizemos em \textit{Python}. O código pode ser encontrado no arquivo \texttt{TouringPolygons/problem2.py}.

\subsection{Definições e Notação}

O problema segue de forma similar ao anterior, mas agora também recebemos como entrada `cercas' \(F_0, \dots, F_k\) tais que para todo \(0 \le i \le k\) vale que o polígono \(P_i\) e \(P_{i + 1}\) estão contidos em \(F_i\), para tal, consideramos \(P_0 = \{s\}\) e \(P_{k + 1} = \{t\}\). Nosso objetivo é encontrar o caminho de menor comprimento que se inicia em \(s\), termina em \(t\), toca cada polígono \(P_i\) em pelo menos um ponto e nunca sai da cerca \(F_i\) no seu caminho entre \(P_i\) e \(P_{i + 1}\).

Dizemos que um caminho \(\pi\) de \(a\) até \(b\) respeita as cercas \(F_i, \dots, F_j\) se \(\pi\) toca todos os polígonos \(P_{i + 1}, \dots, P_j\) e para cada \(i \le l < j\), o trecho de \(\pi\) entre \(P_l\) e \(P_{l + 1}\) está contido em \(F_l\). Ademais, definimos um \(i\)-path até \(p\) como um caminho mínimo de \(s\) até \(p\) que respeita as cercas \(F_0, \dots, F_i\). Note que nosso objetivo é encontrar um \(k\)-path até \(t\).

A função central desse algoritmo continua sendo Query, no entanto, dessa vez vamos adicionar um novo parâmetro, assim, a função \(\text{Query}(p, i, j)\) recebe um ponto \(p\) e dois índices \(i\) e \(j\) e retorna o penúltimo ponto \(q\) do menor caminho até \(p\) que parte de \(s\), toca todos os polígonos \(P_1, \dots, P_i\) e respeita as cercas \(F_0, \dots, F_j\).

Primeiramente, é essencial que \(i \le j\), ademais, se \(i = j\) então \(\text{Query}(p, i, j)\) é simplesmente o penúltimo ponto do \(i\)-path até \(p\). Adicionamos o parâmetro \(j\) para o caso em que queremos um \(i\)-path, mas \(p\) está fora da cerca \(F_i\) um caso que aparece naturalmente na recursão do algoritmo. Por enquanto, vamos assumir que sabemos como respoder as consultas.

\subsection{Caminhos Restritos}

Outra função extremamente importante para a implementação desse algoritmo é a função \(\text{Fenced}(p_1, p_2, i, j)\) que retorna o menor caminho de \(p_1\) até \(p_2\) que respeita as cercas \(F_i, \dots, F_j\). Note que se \(i = j\), então \(\text{Fenced}(p_1, p_2, i, j)\) é simplesmente o segmento \(\overline{p_1p_2}\) se ele estiver contido em \(F_i\) e não existe caso contrário. Assim, vamos assumir que \(i < j\).


\newpage
\appendix

\section{Notações}
\label{sec:appendixA}

\begin{enumerate}

	\item \(v = (v_1, v_2), v \in \mathbb{R} ^ 2\). Vetores são representados como tuplas de coordenadas.

	\item \(\abs{v} = \sqrt{v_1 ^ 2 + v_2 ^ 2}\). Norma Euclidiana de um vetor.

	\item \(\anglebrackets{u, v} = u_1 v_1 + u_2 v_2\). Produto interno definido como produto escalar de vetores.

	\item \(u \times v = u_1 v_2 - u_2 v_1\). Produto vetorial definido como determinante 2D, retornando um escalar. Essa definição tem a seguinte propriedade:

	\[
		\text{sign}(u \times v) =
		\begin{cases}
			+1, & \text{se ângulo no sentido anti-horário entre } u \text{ e } v \text{ é menor que } 180 ^ \circ \\
			-1, & \text{se ângulo no sentido horário entre } u \text{ e } v \text{ é menor que } 180 ^ \circ \\
			0, & \text{se } u \text{ e } v \text{ são colineares} \\
		\end{cases}
	\]
	
	Pode-se interpretar \(u \times v\) como a área do paralelogramo formado por \(u\) e \(v\), onde o sinal indica a orientação.

	\item Dizemos que um ponto \(p\) está do \textbf{lado esquerdo} de uma direção \(d\) se \(d \times p \ge 0\) e do \textbf{lado direito} se \(d \times p \le 0\).
	
	\item \(\overline{uv}\): Segmento de reta entre os pontos \(u\) e \(v\).
	
	\item \(\overrightarrow{uv} = v - u\). Vetor direcionado do ponto \(u\) até o ponto \(v\).
	
	\item \(\abs{P}\). Se \(P\) é um polígono, então \(\abs{P}\) é o número de vértices de \(P\).

\end{enumerate}

\newpage
\printbibliography

\end{document}
