
\documentclass{article}

% Page layout and margins
\usepackage[
	a4paper,
	bindingoffset=0.2in,
	left=0.8in,
	right=0.8in,
	top=1in,
	bottom=1in,
	footskip=.25in
]{geometry}

% Language
\usepackage[brazil]{babel}

% Math and symbols
\usepackage{amsmath, amssymb, mathtools}

% Algorithms
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}

\SetKwIF{If}{ElseIf}{Else}{if}{:}{else if}{else}{end}
\SetKwFor{For}{for}{:}{end}
\SetKwRepeat{Do}{do}{while}
\SetKwProg{Function}{def}{:}{}

% Graphics and figures
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{caption}
\usepackage{float}
\usepackage{adjustbox}
\usepackage{tikz}

% Text formatting and layout
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{quoting}
\usepackage{xcolor} % no need for [dvipsnames] unless you need extended colors

% URLs and hyperlinks
\usepackage{hyperref}
\usepackage{url}

% Code listings (optional, if you actually use it)
\usepackage{listings}

% Framed boxes (optional, if you use them)
\usepackage{tcolorbox}
\usepackage{mdframed}

% Citations
\usepackage[backend=biber,style=ieee]{biblatex}
\addbibresource{referencias.bib}

\usepackage{multirow} % Permite criar tabelas com uma célula ocupando várias linhas

\usepackage{setspace}     % Para definir espaçamento entre linhas. (\onehalfspacing, \singlespacing, \doublespacing)

\usepackage{breakcites}   % Para permitir quebra de linha no meio de citações.

\usepackage{array}
\usepackage{wrapfig}
\usepackage{enumitem}

\definecolor{lightgray}{RGB}{240,240,240}

\newenvironment{blockquote}[1][lightgray]{\begin{mdframed}[
	leftline=true,
	topline=false,
	bottomline=false,
	rightline=false,
	linecolor=gray,
	linewidth=2pt,
	backgroundcolor=#1,
	skipabove=\baselineskip,
	skipbelow=\baselineskip,
	innerleftmargin=10pt,
	innerrightmargin=10pt,
	innertopmargin=5pt,
	innerbottommargin=5pt]
}
{\end{mdframed}}

% Counter for proof lines
\newcounter{proofline}

% Custom paired delimiters
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\parens}{(}{)}
\DeclarePairedDelimiter{\curly}{\{}{\}}

% Box spacing tweaks
\setlength{\fboxsep}{0pt}
\setlength{\fboxrule}{1.4pt}

% Paragraph indent
\setlength{\parindent}{2em}

% Page style setup
\pagestyle{fancy}
\lhead{\footnotesize {\sc }}
\chead{}
\rhead{\footnotesize {\sc mac-ime-usp}}
\lfoot{}
\cfoot{}
\rfoot{\thepage}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\begin{document}

\begin{titlepage}

\begin{center}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.3\textwidth]{logo-small.png} % Ajuste o caminho da imagem conforme necessário
	\end{figure}

	\vspace{2cm}

	{\Large \sc UNIVERSIDADE DE SÃO PAULO} \\
	{\Large \sc INSTITUTO DE MATEMÁTICA E ESTATÍSTICA} \\ [0.7cm]
	{\sc DEPARTAMENTO DE CIÊNCIA DA COMPUTAÇÃO} \\

	\vspace{2cm}

		\rule{\linewidth}{2pt}
		
		\vspace{0.2em} % Ajuste ao seu gosto
		
	{\Large \bfseries 
		MAC0215: Relatório Final \\
		O Problema da Visita de Polígonos \\
	}

	\vspace{0.2em} % Ajuste ao seu gosto
	
	\rule{\linewidth}{2pt} \\

\end{center}

\vspace{2.8cm}

\begin{center}
	{\large \bfseries Gabriel Freire Ushijima} \\
\end{center}

\vfill

% Data
\begin{center}
	\makeatletter
	{\large São Paulo, SP \\
	\@date}
	\makeatother
\end{center}

\end{titlepage}

\newpage

\noindent{}

\begin{center}
	\ \\ [1em]
	{\bf \huge Resumo} \\[3em] % Dá um pulo de cerca de 3 linhas
\end{center}

Este relatório apresenta os resultados do projeto de pesquisa desenvolvido na disciplina MAC0215 - Atividade Curricular em Pesquisa (2025), sob a supervisão do Prof. Dr. Ernesto G. Birgin.
O foco do projeto foi o Problema da Visita de Polígonos (Touring Polygons Problem - TPP), um problema de otimização geométrica que envolve encontrar o caminho mais curto que visita uma sequência de polígonos no plano. Foram exploradas três variações do problema: o TPP Irrestrito, o TPP Restrito com cercas e o TPP com polígonos não convexos.

Nesse relatório, apresentamos uma descrição detalhada do problema, a base bibliográfica que fundamenta nosso trabalho, as implementações realizadas, os resultados obtidos e possíveis melhorias e trabalhos futuros. Também discutimos a alocação de tempo ao longo do projeto, justificando o investimento de ao menos 100 horas de trabalho. Finalmente, concluimos que o projeto foi bem sucedido, cumprindo todas as promessas feitas na proposta inicial e contribuindo para a literatura existente sobre o problema.

\newpage

\tableofcontents

\newpage

\section{Introdução}

Esse projeto de pesquisa teve como objetivo explorar o Problema da Visita de Polígonos (Touring Polygons Problem - TPP), um problema de otimização geométrica que envolve encontrar o caminho mais curto que visita uma sequência de polígonos no plano. O projeto foi desenvolvido ao longo do semestre como parte da disciplina MAC0215 - Atividade Curricular em Pesquisa (2025), sendo supervisionado pelo Prof. Dr. Ernesto G. Birgin.

O trabalho feito envolveu a implementação de soluções para três variações do problema: o TPP Irrestrito, o TPP Restrito com cercas e o TPP com polígonos não convexos. Cada uma dessas variações apresenta desafios únicos e requer abordagens específicas para encontrar soluções eficientes. Além do trabalho de implementar os algoritmos, também desenvolvemos uma ferramenta de visualização para facilitar a compreensão do problema e das soluções encontradas. Toda a implementação foi feita em Python, utilizando apenas as estruturas básicas da linguagem e a biblioteca \textit{Matplotlib} para visualização.

Todo o código desenvolvido para esse projeto está disponível no \hypertarget{repo}{\href{https://github.com/YushiPy/TouringPolygons}{repositório do GitHub}}, nele é possível encontrar as soluções para as três variações do problema, assim como visualizações do funcionamento das soluções e instruções para executar o código. Também é possível encontrar nossa ferramenta para geração de instâncias do problema e visualização dos resultados. Finalmente, também incluímos um relatório técnico detalhando os aspectos de implementação dos algoritmos, que pode ser útil para quem deseja entender melhor o funcionamento das soluções propostas.

\section{Materiais e Métodos}

Primeiramente, tomamos o artigo de Dror et al. (2003) \cite{tpp-dror2003} como base para nosso estudo do Problema da Visita de Polígonos. Esse artigo apresenta os conceitos fundamentais do problema, assim como algoritmos para resolver suas variações. A partir desse artigo, desenvolvemos implementações práticas dos algoritmos propostos, adaptando-os conforme necessário para garantir a corretude e eficiência das soluções. Essa é a principal base teórica para esse problema, com pouca literatura adicional disponível.

Em geral, os materiais se resumem ao artigo de Dror et al. (2003) \cite{tpp-dror2003} e o código desenvolvido por nós, disponível no \hyperlink{repo}{repositório do GitHub} associado a esse projeto, que inclui todas as implementações, visualizações e documentação necessária para entender o trabalho realizado. O código foi escrito em Python, utilizando apenas as estruturas básicas da linguagem e a biblioteca \textit{Matplotlib} para visualização.

Nossa metodologia foi baseada na implementação dos algoritmos propostos no artigo, traduzindo as ideias teóricas em código prático. Isso envolveu a leitura cuidadosa do artigo, a compreensão dos conceitos apresentados e a adaptação desses conceitos para uma implementação funcional, acompanhado de testes para garantir a corretude das soluções.

\section{O Problema}

O Problema da Visita de Polígonos (TPP) consiste em encontrar o caminho mais curto que visita um conjunto de polígonos no plano. Esse problema é um caso específico do problema do caixeiro viajante com vizinhanças (TSPN) \cite{tspn-iacopo-2011}, onde o objetivo é visitar regiões genéricas no plano, que é por sua vez uma generalização do problema do caixeiro viajante (TSP) \cite{tsp-applegate2006}, onde o objetivo é visitar pontos específicos.

O enunciado formal do TPP é o seguinte: dado um ponto inicial \(s\), um ponto final \(t\) e uma sequência de polígonos \(P_1, P_2, \ldots, P_k\) no plano, encontrar o menor caminho que começa em \(s\), termina em \(t\) e visita cada polígono \(P_i\) pelo menos uma vez, além disso os polígono devem ser tocados na ordem que são dados. Consideramos que visitar um polígono significa que o caminho pode atravessar ou simplesmente tocar na borda de cada polígono.

Para esse projeto, consideramos três variações do problema, o TPP Irrestrito, onde lidamos com polígonos convexos e disjuntos, o TPP Restrito onde os polígonos ainda devem ser convexos, mas pode ter interseção e consideramos a inclusão de uma "cerca" que restringe nosso movimento e o TPP com polígonos não convexos, onde retornamos ao TPP Irrestrito, mas consideramos que os polígonos pode ser não convexos. Vamos discutir cada um deles nas próximas seções.

\subsection{TPP Irrestrito}

Essa é a primeira variação do problema que abordamos, vamos considerar que recebemos um ponto inicial \(s\), um ponto final \(t\) e uma sequência de polígonos \(P_1, P_2, \ldots, P_k\) e buscamos um caminho mínimo que enconsta em cada polígono no plano, como no enunciado geral do problema. Além dessas suposições, vamos considerar que os polígonos são \textbf{convexos} e são \textbf{disjuntos}.

\begin{wrapfigure}{r}{0.40\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.39\textwidth]{problem1-solution.png}
	\caption{Caminho mínimo para um caso de 3 polígonos.}
	\label{problem1-solution}
\end{wrapfigure}

A figura ao lado \ref{problem1-solution} ilustra um exemplo de entrada e solução para o problema. O caminho mínimo é representado pela linha roxa, que começa no ponto \(s\) (ponto verde), termina no ponto \(t\) (ponto vermelho) e toca o triângulo, trapézio e então pentágono.

O algoritmo que implementamos é descrito no artigo \cite{tpp-dror2003} como tendo complexidade \(O(nk \log(n / k))\), onde \(n\) é o número total de vértices dos polígonos e \(k\) é o número de polígonos. Os autores não descreveram as estruturas de dados nem detalhes que facilitassem a implementação, então tivemos que fazer diversas escolhas de implementação para conseguir a complexidade prometida.

A solução em si se baseia na ideia de, para cada polígono \(P_i\), particionar o plano em três tipos de região, permitindo que façamos consultas do tipo \(q = \text{Query}(p, i)\), onde \(q\) é o último passo do menor caminho que parte de \(s\), toca cada polígono \(P_1, \dots, P_i\) e chega em \(p\). Formulando o problema dessa maneira, podemos observar que, se conseguirmos criar todas as partições para cada polígono, podemos resolver o problema facilmente, definindo \(q_k = \text{Query}(t, k)\), então \(q_{k - 1} = \text{Query}(q_k, k - 1)\), e assim por diante, até chegarmos em \(q_0 = s\). Dessa forma, conseguimos reconstruir o caminho mínimo de trás para frente.

Na figura abaixo \ref{problem1-partitions} é possível ver um exemplo dessas partições, para polígono criamos uma partição diferente, usando as partições anteriores. Dessa forma a primeira partição (a do triângulo) usa apenas o ponto \(s\), a segunda partição (a do trapézio) usa a partição do triângulo e \(s\), e a terceira partição (a do pentágono) usa a partição do triângulo, trapézio e \(s\).

\begin{wrapfigure}{l}{0.60\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.59\textwidth]{problem1-partitions-small.png}
	\caption{Partições para um caso de 3 polígonos.}
	\label{problem1-partitions}
\end{wrapfigure}

Essas regiões são de três tipos, chamdas de regiões de vértice (em vermelho), aresta (em verde) e sombra (em ciano). As regiões de vértice são associadas à um vértice específico do polígono \(P_i\), e consistem em todos os pontos \(p\) tais que o caminho mínimo toca em \(P_i\) nesse vértice e então chega em \(p\). As regiões de aresta são associadas a uma aresta específica do polígono \(P_i\), e consistem em todos os pontos \(p\) tais que o caminho mínimo toca em \(P_i\) nessa aresta e então chega em \(p\). Finalmente, as regiões de sombra são associadas ao polígono em si e consistem em todos os pontos \(p\) tais que o caminho mínimo toca em atravessa \(P_i\) para chegar em \(p\).

A seguir vamos construir o caminho mínimo para o exemplo da figura \ref{problem1-solution}, usando as partições da figura \ref{problem1-partitions}. Começamos com \(q_3 = \text{Query}(t, 3)\), olhando na partição do pentágono, observamos que \(t\) está na região de vértice, assim, sabemos que \(q_3\) deve ser esse vértice de \(P_3\). Em seguida, calculamos \(q_2 = \text{Query}(q_3, 2)\), olhando na partição do trapézio, observamos que \(q_3\) está na região de sombra, assim, podemos essencialmente ignorar \(P_2\), pois qualquer ponto mínimo até \(q_3\) que toque \(P_2\) deve necessariamente atravessá-lo. Finalmente, calculamos \(q_1 = \text{Query}(q_3, 1)\), olhando na partição do triângulo, observamos que \(q_3\) está na região de aresta, assim, sabemos que \(q_1\) deve ser o ponto na aresta de \(P_1\) que minimiza a distância de \(s\) até \(q_2\). Com isso, conseguimos reconstruir o caminho mínimo completo.

Tendo essa ideia geral em mente, resta apenas como desafio criar essas partições e localizar pontos nelas de forma eficiente. Essencialmente, para criar a partição de \(P_i\), devemos calcular um caminho mínimo que toca cada polígono \(P_1, \dots, P_{i - 1}\) até cada vértice de \(P_i\) e apartir da maneira que esse caminho chega nesses vértices, podemos determinar as regiões de vértice. Uma vez que temos as regiões de vértice, notamos que as regiões de aresta e sombra são as regiões restantes no plano, dessa forma, é apenas necessário saber diferenciar essas regiões. Para isso, podemos observar que se um caminho mínimo que chega em um ponto interno de uma aresta de \(P_i\) atravessa \(P_i\), essa aresta deve pertencer à região de sombra, caso contrário, pertence à região de aresta. Com isso, conseguimos construir todas as partições necessárias.

É claro que essa explicação é bastante simplificada, e muitos detalhes de implementação foram omitidos para manter o foco na ideia geral. O artigo original \cite{tpp-dror2003} apresenta todas os lemas e teoremas necessários para garantir a corretude do algoritmo e a complexidade prometida, enquanto temos uma relatório explicando os detalhes de implementação e o código em si por completo no \hyperlink{repo}{repositório do GitHub} associado a esse projeto.

\subsection{TPP Restrito}

Essa variação do problema faz as mesmas suposições do TPP Irrestrito, mas agora permitimos que os polígonos possam se intersectar. Além disso, introduzimos como entrada "cercas" \(F_0, \dots, F_k\) tais que \(F_i\) contém \(P_i\) e \(P_{i + 1}\) para todo \(0 \le i \le k\), considerando \(P_0 = s\) e \(P_{k + 1} = t\), e entre o caminhoo visitar \(P_i\) e \(P_{i + 1}\), ele deve permanecer dentro de \(F_i\).


\begin{wrapfigure}{r}{0.60\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.59\textwidth]{problem2-solution.png}
	\caption{Caminho mínimo para um caso de 2 polígonos e 3 cercas.}
	\label{problem2-solution}
\end{wrapfigure}

Essas cercas devem ser polígonos, mas não necessariamente convexos, na verdade, uma cerca convexa é equivalente a não ter cerca alguma, então faz sentido permitir que as cercas sejam não convexas. A figura ao lado \ref{problem2-solution} ilustra um exemplo de entrada e solução para esse problema, com dois polígons e três cercas. Note que o menor caminho (linha roxa) deve permanecer dentro das cercas (linhas coloridas) ao visitar os polígonos (polígonos preenchidos), criando um caminho diferente do TPP Irrestrito.

O tratamento desse problema no artigo \cite{tpp-dror2003} é ainda mais sucinto do que o TPP Irrestrito, com pouco detalhes e nenhuma visualização do problema, sendo uma leitura extremamente densa e teórica, sem nenhum detalhe de implementação. No entanto, a ideia geral do algoritmo é semelhante ao TPP Irrestrito, onde criamos partições do plano para cada polígono \(P_i\) e usamos essas partições para reconstruir o caminho mínimo. A principal diferença é que, ao criar as partições, devemos considerar as cercas \(F_i\), garantindo que o caminho mínimo permaneça dentro dessas cercas ao visitar os polígonos.

O artigo apresenta um algoritmo com complexidade \(O(n k ^ 2 \log n)\) onde \(n\) é o número total de vértices dos polígonos e cercas, e \(k\) é o número de polígonos. Infelizmente, devido à natureza densa e teórica do artigo, não conseguimos implementar esse algoritmo com a complexidade prometida, mas conseguimos desenvolver uma implementação funcional que resolve o problema corretamente, embora com uma complexidade maior de \(O(n^2 k^2)\).

\subsection{TPP com Polígonos Não Convexos}

Nas duas variações anteriores do problema, consideramos que os polígonos eram convexos, isso é essencial para garintir que os problemas possam ser resolvidos em tempo polinomial, uma vez que podemos mostrar que até o TPP Irrestrito com polígonos não convexos é NP-difícil \cite{tpp-dror2003}.

Ainda assim, decidimos explorar essa variação do problema, uma vez que ele não é descrito no artigo original, implementando uma solução exata para o TPP Irrestrito com polígonos não convexos. A ideia geral do algoritmo é simples, basta decompor cada polígono não convexo em um conjunto de polígonos convexos, e então resolver o TPP Irrestrito normalmente, considerando que visitar o polígono não convexo significa visitar ao menos um dos polígonos convexos que o compõem. Dessa forma, reutilizamos a implementação do TPP Irrestrito que já havíamos desenvolvido.

\begin{wrapfigure}{l}{0.60\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.59\textwidth]{problem3-solution.png}
	\caption{Caminho mínimo para um caso de 2 polígnos não convexos.}
	\label{problem3-solution}
\end{wrapfigure}

Utilizando essa abordagem, conseguimos resolver o problema corretamente, como ilustrado na figura ao lado \ref{problem3-solution}, onde o caminho mínimo (linha roxa) visita os polígonos não convexos (polígonos preenchidos) corretamente, após considerar todas as combinações possíveis de polígonos convexos que os compõem.

No entanto, essa abordagem é extremamente ineficiente, uma vez que frequentemente vamos lidar com uma quantia exponencial de casos para testarmos. Enquanto não tivemos tempo de explorar otimizações para esse algoritmo, acreditamos que é possível usar técnicas de otimização inteira e combinatória para reduzir o número de casos que precisamos testar, tornando o algoritmo mais viável na prática. Esse tratamento seria feito no próximo semestre e muito provavelmente renderia um artigo científico.

Embora não tenhamos conseguido explorar essa variação muito profundamente ainda, a ideia central é tratar o problema como um problema de otimização inteira de uma função quadrática sujeita a restrições lineares. Dessa forma podemos usar técnicas de otimização matemática para otimizar a abordagem inicial, assim como utilizar solvers comerciais para comparar resultados e validar nossa implementação.

\section{Resultados e Discussões}

Consideramos esse projeto como um sucesso, uma vez que conseguimos implementar soluções corretas para todas as variações do problema que propusemos, permitindo o aprendizado profundo sobre o problema e suas soluções. No entanto, na proposta inicial do projeto, fizemos diversas promessas amplas, assim, vamos discutir cada uma delas e analisar se conseguimos cumprir o que prometemos.

\subsection{Mês 1}

\begin{blockquote}
	Implementar a variação sem cercas, com estudo do artigo e testes iniciais. Estima-se cerca de 30 horas, divididos entre uma compreensão dos conceitos fundamentais e criação de uma base sólida de código para as etapas seguintes, assim como a criação de testes unitários para garantir a corretude do algoritmo.
\end{blockquote}

Para o primeiro mês, prometemos que implementaríamos o TPP Irrestrito, estudando o artigo original e realizando testes iniciais. De fato, conseguimos cumprir essa promessa, implementando o algoritmo proposto no artigo \cite{tpp-dror2003} com a complexidade esperada, também realizamos diversos testes para garantir a corretude do algoritmo, criando uma base sólida de código que serviu como base para as variações seguintes do problema. 

Embora tenhamos estimado que investiríamos cerca de 30 horas nesse mês, na prática, acabamos investindo muito mais tempo, cujos detalhes serão discutidos na seção de alocação de tempo. No entanto, acreditamos que esse investimento extra foi justificado, uma vez que nos permitiu compreender profundamente o problema e desenvolver uma implementação robusta e eficiente.

\subsection{Mês 2}

\begin{blockquote}
	Implementar a variação com cercas, utilizando parte do código da primeira variação. Esta etapa, estimada em 30 horas, envolve o aprofundamento do artigo original, adaptação e extensão do código para lidar com a complexidade adicional desta variação e criação de testes para validar a nova implementação.
\end{blockquote}

Para o segundo mês, prometemos implementar o TPP Restrito, reutilizando parte do código desenvolvido para o TPP Irrestrito. De fato, conseguimos cumprir essa promessa, adaptando e estendendo nossa implementação anterior para lidar com as cercas do problema.

Infelizmente, devido à dificuldade do problema, não conseguimos atingir a complexidade prometida no artigo original \cite{tpp-dror2003}, mas desenvolvemos uma implementação funcional que resolve o problema corretamente, embora com uma complexidade maior. Assim como na variação anterior, realizamos diversos testes para garantir a corretude do algoritmo.

Novamente, embora tenhamos estimado um investimento de 30 horas para esse mês, na prática, acabamos investindo muito mais tempo do que o previsto, levando muito tempo para compreender o artigo, implementar o algoritmo e lentamente depurar a implementação. Os detalhes desse investimento extra serão discutidos na seção de alocação de tempo.

\subsection{Mês 3}

\begin{blockquote}
	Explorar soluções para o caso de polígonos não convexos, mesmo que pouco eficientes. Prevê-se cerca de 30 horas, incluindo a idealização de uma abordagem, assim como a implementação dessa solução. Novamente, testes serão fundamentais para validar a solução proposta, mesmo que não seja a mais eficiente.
\end{blockquote}

Para o terceiro mês, prometemos explorar soluções para o TPP Irrestrito com polígonos não convexos, mesmo que essas soluções fossem pouco eficientes. De fato, conseguimos cumprir essa promessa, desenvolvendo uma abordagem que decompõe os polígonos não convexos em polígonos convexos e reutiliza a implementação do TPP Irrestrito para encontrar o caminho mínimo.

\subsection{Mês 4}

\begin{blockquote}
	Desenvolver um software de visualização que permita ao usuário interagir com polígonos, cercas e caminhos encontrados, mostrando também as etapas do algoritmo. Estima-se 20 horas, incluindo criação de interface básica e implementação das funcionalidades de visualização.
\end{blockquote}

Finalmente, para o último mês, prometemos desenvolver um software de visualização que permita ao usuário interagir com os polígonos, cercas e caminhos encontrados, mostrando também as etapas do algoritmo. 

De fato, conseguimos cumprir essa promessa, desenvolvendo uma ferramenta de visualização que permite ao usuário carregar diferentes instâncias do problema, visualizar os polígonos e cercas, e observar o caminho mínimo encontrado pelo algoritmo. A ferramenta também permite visualizar as etapas do algoritmo, facilitando a compreensão do processo de resolução do problema. Por exemplo, todas as figuras apresentadas nesse relatório foram geradas utilizando essa ferramenta de visualização.

Além disso, adicionalmente, investimos tempo extra para melhorar a interface do usuário e adicionar um software extra de geração de instâncias do problema, facilitando a criação de novos casos de teste para o algoritmo, sem que o usuário tenha que digitar manualmente cada coordenada dos polígonos e cercas, podendo simplesmente desenhá-los e visualizar como isso afeta o caminho mínimo encontrado em tempo real.

O tempo investido nessa etapa também acabou sendo consideravelmente maior do que o estimado, uma vez que decidimos adicionar funcionalidades extras e melhorar a experiência do usuário. A implementação também acabou sendo mais desafiadora do que o previsto inicialmente, levando mais tempo para depurar e garantir que tudo funcionasse corretamente. Novamente, os detalhes desse investimento extra serão discutidos na seção de alocação de tempo.

\subsection{Considerações Finais}

Consideramos que conseguimos cumprir todas as promessas feitas na proposta inicial do projeto, desenvolvendo soluções corretas para todas as variações do problema que propusemos, assim como uma ferramenta de visualização funcional e intuitiva. Embora o tempo investido em cada etapa tenha sido maior do que o previsto inicialmente, acreditamos que esse investimento extra foi justificado, permitindo-nos compreender profundamente o problema e desenvolver implementações robustas e eficientes.

\subsection{Exemplos}

A seguir, apresentamos alguns exemplos de entradas e saídas para os algoritmos implementados, incluimos 4 imagens para o TPP Irrestrito e 4 imagens para o TPP Restrito em uma tentativa de iluistrar as possibilidade de instâncias que podem ser resolvidas. 

Enquanto os resultados dos casos anteriores são interessantes por si só, consideramos que as imagens mais chamativas são as que envolvem polígonos não convexos, uma vez que ganhamos muita mais liberdade para criar formas interessantes. Assim, incluímos também 3 imagens adicionais, cada uma ilustrando um conjunto de polígonos não convexo que formam figuras conhecidas, como o logo do IME-USP, personagens do jogo Hollow Knight e um símbolo do anime Fullmetal Alchemist.

\newpage

\begin{figure}[h]
	\centering
	
	% Row 1
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Irrestrito1.png}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Irrestrito2.png}
	\end{subfigure}

	% Row 2
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Irrestrito3.png}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Irrestrito4.png}
	\end{subfigure}

	\caption{Exemplos de entradas e saídas para o TPP Irrestrito.}
\end{figure}

\newpage

\begin{figure}[h]
	\centering
	
	% Row 1
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Restrito1.png}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Restrito2.png}
	\end{subfigure}

	% Row 2
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Restrito3.png}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Resultados/TPP-Restrito4.png}
	\end{subfigure}

	\caption{Exemplos de entradas e saídas para o TPP Restrito.}
\end{figure}

\newpage

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Resultados/ime.png}
	\caption{Logo do IME-USP, formado por polígonos não convexos.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Resultados/hollow_knight.png}
	\caption{Knight e Hornet do jogo \href{https://pt.wikipedia.org/wiki/Hollow_Knight}{Hollow Knight}, formados por polígonos não convexos.}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{Resultados/fullmetal_alchemist.png}
	\caption{Ouroboros do anime \href{https://pt.wikipedia.org/wiki/Fullmetal_Alchemist}{Fullmetal Alchemist}, formado por polígonos não convexos.}
\end{figure}

\newpage

\section{Trabalhos Futuros}

Enquanto consideramos que esse projeto foi muito bem sucedido, ainda há muito espaço para melhorias e trabalhos futuros. Algumas das possíveis direções para trabalhos futuros incluem:

\begin{itemize}

	\item Otimização do algoritmo para o TPP Restrito, buscando atingir a complexidade prometida no artigo original \cite{tpp-dror2003}, ou pelo menos melhorar a complexidade atual da implementação.

	\item Exploração de otimizações para o TPP Irrestrito com polígonos não convexos, utilizando técnicas de otimização inteira e combinatória para reduzir o número de casos que precisam ser testados. Essa tarefa provavelmente será um tanto quanto complicada e seria tratada ao longo do próximo semestre, possivelmente rendendo um artigo científico.

	\item Melhorias na ferramenta de visualização, adicionando mais funcionalidades e melhorando a experiência do usuário.

\end{itemize}

Quaisquer avanços podem ser acompanhados no mesmo \hyperlink{repo}{repositório} que estamos usando atualmente, onde também é possível encontrar o código desenvolvido até agora, assim como instruções para executar os algoritmos implementados.

É extremamente provável que esses trabalhos futuros sejam explorados no próximo semestre, como parte de uma continuação desse projeto de pesquisa, e que a participação nessa matéria seja novamente registrada como parte da atividade curricular em pesquisa.

\section{Alocação de Tempo}

Como requisito para a aprovação na disciplina MAC0215 - Atividade Curricular em Pesquisa, é necessário comprovar um investimento de ao menos 100 horas de trabalho no projeto. A seguir, vamos detalhar como esse tempo foi alocado ao longo do semestre, justificando o investimento realizado. Para a análise a seguir, vamos considerar que o projeto teve início em \textbf{1 de agosto} e terminou em \textbf{30 de novembro}, totalizando cerca de 4 meses de trabalho, ou seja, um semestre acadêmico típico.

Primeiramente, seria possível que simplesmente disséssemos que uma certa quantia de horas foi investida em cada mês, mas essa métrica é muito vaga e não reflete o esforço real investido no projeto. Por esse motivo, desenvolvemos uma métrica objetiva para medir o tempo investido, baseada nos múltiplos \textit{commits} realizados no \hyperlink{repo}{repositório} ao longo do projeto.

\subsection{Uma Heurística Para Medição de Tempo}

Essencialmente, cada \textit{commit} representa uma unidade de trabalho realizada no projeto, seja implementando uma nova funcionalidade, corrigindo um bug ou escrevendo documentação. No entanto, nem todos os \textit{commits} são iguais, alguns representam um esforço maior do que outros, podendo variar desde pequenas correções feitas em poucos minutos até implementações complexas que levaram múltiplas horas para serem concluídas.

Para não fazermos decisões arbitrárias sobre o esforço investido em cada \textit{commit}, decidimos aproveitar que cada \textit{commit} registra o tempo exato em que foi realizado, permitindo que calculemos o tempo entre cada \textit{commit} consecutivo. Dessa forma, podemos somar o tempo entre todos os \textit{commits} realizados ao longo do projeto, obtendo uma métrica objetiva do tempo investido.

No entanto, é claro que essa métrica não é perfeita, uma vez que há momentos em que o trabalho no projeto é interrompido por longos períodos, como pausas para refeições, descanso ou outras atividades. Para mitigar esse problema, decidimos estabelecer um limite máximo de 3 horas entre \textit{commits} consecutivos, ou seja, se o tempo entre dois \textit{commits} for maior do que 3 horas, desconsideramos esse intervalo na soma total, assumindo que o trabalho foi interrompido nesse período.

Essa abordagem é um tanto conservadora, uma vez que sempre ignora o tempo investido no primeiro \textit{commit} do dia, assim como qualquer intervalo maior do que 3 horas, mas acreditamos que é uma forma justa de medir o tempo investido no projeto, evitando inflar artificialmente a métrica com períodos de inatividade.

\subsection{Tempo Investido em Commits}

Uma vez que definimos nossa métrica para medir o tempo investido no projeto, podemos aplicar essa métrica aos mais de 250 \textit{commits} realizados ao longo do semestre, obtendo um total de aproximadamente 100 horas de trabalho investidas no projeto, o que excede o requisito mínimo de 100 horas para aprovação na disciplina.

\begin{wrapfigure}{r}{0.60\textwidth}
	\centering
	\vspace{-10pt}
	\includegraphics[width=0.59\textwidth]{time_on_commits.png}
	\caption{Tempo investido ao longo do projeto, medido em horas ao longo dos meses.}
	\label{time-on-commits}
\end{wrapfigure}

Ao lado, criamos um gráfico \ref{time-on-commits} que ilustra o tempo investido ao longo do projeto, medido em horas ao longo do tempo. Podemos observar que o tempo investido varia ao longo do semestre, com picos de atividade em determinados períodos, refletindo o esforço concentrado em diferentes etapas do projeto. 

Esses picos de atividade geralmente coincidem com as etapas principais do projeto, assim como um período onde tivemos mais tempo livre para trabalhar no projeto, como durante a Semana Santa ou Semana de Break da computação. No entanto, também há períodos de menor atividade, refletindo períodos de provas, outras responsabilidades acadêmicas, pessoais ou simplesmente um período de descanso que limitaram o tempo disponível para o projeto.

Além disso, um fator perceptível no gráfico é um período longo de mais de um mês sem nenhum \textit{commit}, que ocorreu entre o final de setembro e o início de novembro. O motivo para esse hiato é que no início do semestre submetemos uma proposta de projeto de pesquisa para a Fapesp a respeito desse trabalho, no entanto, no final de setembro, recebemos a notícia de que a proposta não foi aprovada, o que causou tanto uma desmotivação temporária quanto uma necessidade de reescrita da proposta e planejamento do projeto, o que acabou atrasando o progresso do projeto em cerca de um mês.

Em compensação, notamos um grande pico de atividade logo após esse hiato, refletindo o esforço concentrado para recuperar o tempo perdido e avançar no projeto. Apesar desse contratempo, conseguimos retomar o ritmo do projeto e avançar significativamente nas etapas seguintes, conforme ilustrado no gráfico.

\subsection{Outros Fatores Considerados}

Na seção anterior, já observamos que mais de 100 horas foram investidas exclusivamente em \textit{commits} no \hyperlink{repo}{repositório}, mas é claro que esse não é o único fator que deve ser considerado na alocação de tempo do projeto. Além do tempo investido em \textit{commits}, também devemos considerar o tempo investido em outras atividades relacionadas ao projeto, como o estudo do tema, leitura de artigos, planejamento do projeto, reuniões com o orientador e outras atividades que contribuíram para o progresso do projeto.

\begin{itemize}

	\item \textbf{Estudo}: Investimos tempo significativo estudando o tema do TPP, compreendendo os conceitos fundamentais, analisando o artigo original \cite{tpp-dror2003} e buscando artigos relacionados para aprofundar nosso entendimento do problema.
	
	\item \textbf{Reuniões com o Orientador}: Realizamos diversas reuniões com o Prof. Dr. Ernesto G. Birgin ao longo do semestre, discutindo o andamento do projeto, esclarecendo dúvidas, recebendo feedback e orientações, e planejando as próximas etapas do trabalho. Foram aproximadamente 8 reuniões, com duração média de 2 horas cada, totalizando cerca de 16 horas investidas em reuniões.
	
	\item \textbf{Participação no SIICUSP}: Participamos do SIICUSP 34, um evento da USP onde apresentamos o projeto para tanto alunos quanto professores do instituto. Esse evento exigiu tempo significativo de preparação, incluindo a criação de um pôster, slides, preparação de uma apresentação oral e prática para garantir que estivéssemos prontos para apresentar o trabalho de forma clara e concisa, além das horas ativamente apresentando o trabalho para os interesados.

\end{itemize}

Enquanto não conseguimos quantificar exatamente o tempo investido nessas atividades adicionais, acreditamos que o tempo total investido no projeto, considerando tanto os \textit{commits} quanto essas outras atividades, excede confortavelmente o requisito mínimo de 100 horas para aprovação na disciplina MAC0215 - Atividade Curricular em Pesquisa.

\subsection{Resumo da Alocação de Tempo}

Levando em consideração tanto o tempo investido em \textit{commits} quanto o tempo investido em outras atividades relacionadas ao projeto, podemos resumir a alocação de tempo ao longo do semestre da seguinte forma:

% Label: Mês 1, M6es 2
\begin{itemize}

	\item Mês 1: Aproximadamente 40 horas, considerando aproximadamente 30 horas em \textit{commits} e mais 10 horas entre estudo, planejamento e reuniões. Esse mês serviu principalmente para implementar o TPP Irrestrito e criar uma base sólida de código para as etapas seguintes.

	\item Mês 2: Aproximadamente 30 horas, considerando aproximadamente 15 horas em \textit{commits} e mais 15 horas entre estudo, planejamento e reuniões. Esse mês foi focado na implementação do TPP Restrito, adaptando e estendendo o código desenvolvido anteriormente, uma quantidade consideravelmente maior de tempo foi investido em estudo e planejamento, devido à dificuldade dessa variação do problema, que não foi tão bem detalhada no artigo original.
	
	\item Mês 3: Aproximadamente 10 horas, considerando pouco tempo registrado em \textit{commits} e mais tempo investido na preparação para o SIICUSP, estudo e planejamento. Esse mês teve menor atividade em geral, devido ao hiato mencionado anteriormente.
	
	\item Mês 4: Aproximadamente 80 horas, considerando aproximadamente 70 horas em \textit{commits} e mais 10 horas entre estudo, planejamento, reuniões e preparação para o SIICUSP. Esse mês foi focado na exploração do TPP Irrestrito com polígonos não convexos e otimização da solução para o TPP Irrestrito. Também investimos uma quantidade consideravel de tempo documentando o código e compilando um arquivo técnico (diferente desse relatório) detalhando a implementação dos algoritmos, que está disponível no \hyperlink{repo}{repositório do GitHub} associado a esse projeto.
	
	Esse mês teve um investimento de tempo consideravelmente maior do que os meses anteriores, refletindo o esforço concentrado para concluir o projeto. No entanto, também obervamos que o tempo foi majoritariamente investido em \textit{commits}, uma vez que a base teórica do problema já havia sido compreendida nos meses anteriores, permitindo que o foco fosse na implementação e desenvolvimento prático do projeto.

\end{itemize}

Vale mencionar que o tempo investido na ferramenta de visualização não está concentrado em um único mês, mas sim distribuído ao longo do semestre, uma vez que a visualização das instâncias e solução é essencial para contruir e depurar os algoritmos implementados, assim como garantir a corretude das soluções encontradas. Dessa forma, adicionamos uma pequena quantia de tempo em cada mês para refletir esse investimento contínuo na ferramenta de visualização.

Obervamos que a alocação de tempo final difere do esperado inicialmente, com um investimento de tempo consideravelmente maior do que o previsto, especialmente no último mês. No entanto, acreditamos que esse investimento extra foi justificado, permitindo-nos compreender profundamente o problema e desenvolver implementações robustas e eficientes.

Levando em consideração todos esses fatores, acreditamos que o tempo total investido no projeto excede confortavelmente o requisito mínimo de 100 horas para aprovação na disciplina MAC0215 - Atividade Curricular em Pesquisa.

\section{Conclusão}

Nesse relatório, apresentamos o trabalho realizado ao longo do semestre como parte da disciplina MAC0215 - Atividade Curricular em Pesquisa, onde exploramos o Problema da Visita de Polígonos (TPP) e suas variações. Discutimos o problema em si, a base bibliográfica que fundamenta nosso trabalho, detalhamos as implementações realizadas, analisamos os resultados obtidos e propusemos possíveis melhorias e trabalhos futuros.

A respeito dos resultados, consideramos o projeto como um sucesso, uma vez que conseguimos implementar soluções corretas para todas as variações do problema que propusemos, permitindo o aprendizado profundo sobre o problema e suas soluções. No entanto, reconhecemos que há espaço para melhorias e trabalhos futuros, que pretendemos explorar no próximo semestre.

Além disso, detalhamos a alocação de tempo ao longo do semestre, justificando o investimento de muito mais de 100 horas de trabalho no projeto, cumprindo assim o requisito para aprovação na disciplina. 

Agradecemos ao Prof. Dr. Ernesto G. Birgin pela orientação e suporte ao longo do projeto, assim como à comunidade acadêmica que contribuiu para o desenvolvimento desse trabalho.

Finalmente, encorajamos o leitor a explorar o código desenvolvido para esse projeto, disponível no \hyperlink{repo}{repositório do GitHub}, assim como acompanhar desenvolvimentos futuros relacionados a esse trabalho.

\printbibliography

\end{document}
